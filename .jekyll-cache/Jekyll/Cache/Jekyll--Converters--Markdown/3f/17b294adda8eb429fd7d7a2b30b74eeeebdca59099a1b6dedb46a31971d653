I"t><p>There are N people indexed by $1,..,N$ (because down with the zero-indexers! Long live <a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano!</a>) standing in a circle. They’re standing such that $i$ is between $i-1$ and $i+1$ (unless $i \in{1,N}$, for obvious reasons).</p>

<p>Then starting with $1$ and going around the circle in turn, each person shoots the person directly to their left. This stops when there’s only one person left alive. For example: if $N=5$, it would go:</p>

<!-- more -->

<ol>
  <li>1 shoots 2</li>
  <li>3 shoots 4</li>
  <li>5 shoots 1</li>
  <li>3 shoots 5</li>
</ol>

<p>and only 3 remains.</p>

<h2 id="the-task">The task</h2>

<p>Given $N$, what is the index (1-indexed, unfortunately) of the last shooter standing? For example: if $N=5$, the answer is $3$.</p>

<h2 id="solution">Solution:</h2>

<div class="hint">
  <p>Every number $N$ can be written uniquely as $2^i + \lambda$, where $i,\lambda\in\mathbb{N}_{\geq 0}$ and $\lambda$ is minimal (hence $i$ maximal).</p>

  <p>The answer to the riddle is $1 + 2\lambda$ for this particular $\lambda$.</p>

  <p>So full disclosure, I kinda cheated on this one. We’ll get to that in a bit; but first let’s go through the motions and let me walk you through my thought process (as if that’s super valuable).</p>

  <p>Firsty, we can immediately tell that every time there are an even number of people in the circle, that round will end up at the same person it started with (as in if there are 6 people in the circle, then 2, 4, and 6 are killed in the first round and we start round two on 1 again.</p>

  <p>From there we can conclude that any power of two should end on 1. e.g.</p>

  <p>if $N = 2^1 = 2$ we have:</p>

  <ol>
    <li>1 shoots 2</li>
  </ol>

  <p>if $N = 2^2 = 4$</p>

  <ol>
    <li>1 shoots 2</li>
    <li>3 shoots 4
and we’re left in pretty much the same scenario as $N=2$.</li>
  </ol>

  <p>If $N=8$,</p>

  <ol>
    <li>1 shoots 2</li>
    <li>3 shoots 4</li>
    <li>5 shoots 6</li>
    <li>7 shoots 8</li>
  </ol>

  <p>and we’re left in pretty much the same scenario as $N=4$. In fact, for $2^{i+1}$, the first iteration will wipe out half of the people and leave us starting on 1 again – thereby leaving us in an analogous scenario as $2^i$.</p>

  <p>What about the other cases? Well, naively we can see that every shot moves the head forward by two slots (when 1 shoots 2, the round robbin starts again at 3 but with one fewer player). We now have to prove that this sort of thing reaches parity at $2^i$ and not beforehand. But I’m feeling lazy and I’m pretty confident that it’s correct, so I’ll just show that it’s true for the first few programmatically…</p>
</div>

<h3 id="the-programmatic-solution">The Programmatic Solution</h3>

<div class="hint">

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="s">"rotate a list n times sending the first elems to the back"</span>
    <span class="k">return</span> <span class="n">lst</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">+</span> <span class="n">lst</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">shoot</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
    <span class="n">lst</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lst</span>

<span class="k">def</span> <span class="nf">play</span><span class="p">(</span><span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">players</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># n-1 shots leaves one standing
</span>        <span class="n">players</span> <span class="o">=</span> <span class="n">shoot</span><span class="p">(</span><span class="n">players</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">players</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"Wrong number of players left"</span>
    <span class="k">return</span> <span class="n">players</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">get_lambda</span><span class="p">(</span><span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">log2</span><span class="p">(</span><span class="n">N</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">i</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">check_theory</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">play</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">get_lambda</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>


<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">check_theory</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span>
</code></pre></div>  </div>

  <p>And we can confirm that the relationship holds, at least for the first 1000 positive integers. To do more, we’ll have to account for python’s speed issues.</p>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>

<span class="o">@</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_rotate</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="s">"rotate a list n times sending the first elems to the back"</span>
    <span class="k">return</span> <span class="n">lst</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">+</span> <span class="n">lst</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>

<span class="o">@</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="n">_rotate</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
    <span class="n">lst</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lst</span>

<span class="o">@</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_play</span><span class="p">(</span><span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">players</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># n-1 shots leaves one standing
</span>        <span class="n">players</span> <span class="o">=</span> <span class="n">_shoot</span><span class="p">(</span><span class="n">players</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">players</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"Wrong number of players left"</span>
    <span class="k">return</span> <span class="n">players</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="o">@</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_get_lambda</span><span class="p">(</span><span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">log2</span><span class="p">(</span><span class="n">N</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">i</span><span class="p">)</span>

<span class="o">@</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_check_theory</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_play</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">_get_lambda</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">_check_theory</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span>
</code></pre></div>  </div>

  <p>And now we run our horse race!</p>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">race</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">max_n</span><span class="p">,</span> <span class="n">num_races</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_races</span><span class="p">):</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">func</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">'no numba'</span><span class="p">)</span>
<span class="n">race</span><span class="p">(</span><span class="n">check_theory</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div>  </div>

  <p>On my machine, that prints something on the order of 1 second for each of the five runs. Now let’s try numba!</p>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">'yes numba'</span><span class="p">)</span>
<span class="n">race</span><span class="p">(</span><span class="n">_check_theory</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div>  </div>

  <p>This one takes about 1.5 seconds for the first one, then consistently half a second for the rest.</p>

  <p>The point being, if you’re going to run a function a bunch of times, it’s probably worth while letting numba have a go at it – it’s super cheap to do after all.</p>
</div>
:ET