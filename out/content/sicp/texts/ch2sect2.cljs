(ns content.sicp.texts.ch2sect2 (:require [tailrecursion.hoplon.markdown :as md] [content.sicp.book-data :as data] [tailrecursion.hoplon :refer [form audio input hgroup do! timeout $text base h1 embed h3 body keygen on-append! progress main cite on-page-load object i p nav ruby check-val! a menu blockquote img $comment span track seq?* data u dl select html thead del eventsource append-child fieldset aside figure figcaption sentinel q on! bdi video address caption parse-args dd rp hr tbody table acronym frame applet html-var add-initfn! pre ul dir html-time add-attributes! html-map sup dfn sub mark script big button wbr strong li dt frameset td tr section th optgroup iframe legend em kbd spliced article isindex abbr command <!-- source output basefont route-cell header datalist tfoot s ins footer title is-ie8 h5 canvas param font div option summary samp center small style textarea loop-tpl* strike h4 tt head add-children! ol details col vector?* label rt when-dom h6 link page-load colgroup meter html-meta text-val! bdo --> b code node? noframes replace-children! noscript safe-nth h2 area br]] [tailrecursion.javelin :refer [input? cell cell? destroy-cell! ^{:private true} last-rank ^{:deprecated true} lift lens? set-formula! cell-doseq* ^{:dynamic true, :private true} *tx* deref* set-cell! lens formula? alts! dosync* cell-map formula]]) (:require-macros [tailrecursion.hoplon.markdown :refer [md]] [tailrecursion.hoplon :refer [text with-timeout sexp defelem def-values with-page-load with-dom loop-tpl with-interval with-init!]] [tailrecursion.javelin :refer [with-let mx2 dosync cell= set-cell!= prop-cell cell-doseq defc cell-let-1 defc= macroexpand-all mx cell-let]]))

(sexp {} "defelem content [_ _]" (div {} (data/sect {:title "Hierarchial Data and the Closure Property"} (md {} "As we have seen, pairs provide a primitive \"glue\" that we can use to\nconstruct compound data objects. [Figure 2.2](#!/sicp/ch/2/fig/2/)\nshows a standard way to visualize a pair -- in this case, the pair\nformed by `(cons 1 2)` in Scheme (we're using Scheme again for these\nexamples, but lists are implemented similarly in Clojure, and after\nall, we don't really care too much about the specifics of their\nimplementation, but rather that they have the characteristics we\ndesire, right?). In this representation, which is called\n*box-and-pointer notation*, each object is shown as a *pointer* to a\nbox. The box for a primitive object contains a representation of the\nobject. For example, the box for a number contains a numeral. The box\nfor a pair is actually a double box, the left part containing (a\npointer to) the `car` of the pair and the right part containing the\n`cdr`. Note that we're using Scheme for this part. Don't worry though,\nwe'll be back to Clojureland soon enough.\n\nWe have already seen that `cons` can be used to combine not only\nnumbers but pairs as well. (You made use of this fact, or should have,\nin doing exercises [2.2](#!/sicp/ch/2/ex/2/) and\n[2.3](#!/sicp/ch/2/ex/3/).) As a consequence, pairs provide a universal\nbuilding block from which we can construct all sorts of data\nstructures. Figure 2.3 shows two ways to use pairs to combine the\nnumbers 1, 2, 3, and 4.") "" (data/fig {:footer "Box-and-pointer representation of (cons 1 2)."}) (data/fig {:footer "Two ways to combine 1,2,3, and 4 using pairs."}) "" (md {} "The ability to create pairs whose elements are pairs is the essence of\nlist structure's importance as a representational tool. We refer to\nthis ability as the *closure property* of `cons` (`cons` is closed in\nClojure as well, but don't just take my word for it, try it out!). In\ngeneral, an operation for combining data objects satisfies the closure\nproperty if the results of combining things with that operation can\nthemselves be combined using the same operation.<<The use of the word\n\"closure\" here comes from abstract algebra, where a set of elements is\nsaid to be closed under an operation if applying the operation to\nelements in the set produces an element that is again an element of the\nset. The Lisp community also (unfortunately) uses the word \"closure\" to\ndescribe a totally unrelated concept: A closure is an implementation\ntechnique for representing procedures with free variables. We do not\nuse the word \"closure\" in this second sense in this book.>> Closure is\nthe key to power in any means of combination because it permits us to\ncreate *hierarchical* structures -- structures made up of parts, which\nthemselves are made up of parts, and so on.\n\nFrom the outset of chapter 1, we've made essential use of closure in\ndealing with procedures, because all but the very simplest programs\nrely on the fact that the elements of a combination can themselves be\ncombinations. In this section, we take up the consequences of closure\nfor compound data. We describe some conventional techniques for using\npairs to represent sequences and trees, and we exhibit a graphics\nlanguage that illustrates closure in a vivid way.<<The notion that a\nmeans of combination should satisfy closure is a straightforward idea.\nUnfortunately, the data combiners provided in many popular programming\nlanguages do not satisfy closure, or make closure cumbersome to\nexploit. In Fortran or Basic, one typically combines data elements by\nassembling them into arrays -- but one cannot form arrays whose\nelements are themselves arrays. Pascal and C admit structures whose\nelements are structures. However, this requires that the programmer\nmanipulate pointers explicitly, and adhere to the restriction that each\nfield of a structure can contain only elements of a prespecified form.\nUnlike Lisp with its pairs, these languages have no built-in\ngeneral-purpose glue that makes it easy to manipulate compound data in\na uniform way. This limitation lies behind Alan Perlis&#39;s comment in\nhis foreword to this book: \"In Pascal the plethora of declarable data\nstructures induces a specialization within functions that inhibits and\npenalizes casual cooperation. It is better to have 100 functions\noperate on one data structure than to have 10 functions operate on 10\ndata structures.\">>")) "" (data/subsect {:title "Representing Sequences"} (data/fig {:footer "The sequence 1, 2, 3, 4 represented as a chain of pairs."}) "" (md {} "One of the useful structures we can build with pairs is a *sequence* --\nan ordered collection of data objects. There are, of course, many ways\nto represent sequences in terms of pairs. One particularly\nstraightforward representation is illustrated in figure 2.4, where the\nsequence 1, 2, 3, 4 is represented as a chain of pairs. The `car` of\neach pair is the corresponding item in the chain, and the cdr of the\npair is the next pair in the chain. The `cdr` of the final pair signals\nthe end of the sequence by pointing to a distinguished value that is\nnot a pair, represented in box-and-pointer diagrams as a diagonal line\nand in programs as the value of the variable `nil`. The entire sequence\nis constructed by nested `cons` operations:\n\n```clj\n(cons 1\n      (cons 2\n            (cons 3\n                  (cons 4 nil))))\n```\n\nSuch a sequence of pairs, formed by nested `cons`es is called a *list*,\nand Scheme provides a primitive called `list` to help in constructing\nlists.<<In this book, we use *list* to mean a chain of pairs terminated\nby the end-of-list marker which is convenient because that is the way\nthey are implemented in Clojure. To test this, type `(= (cons 1 (cons 2\nnil)) (list 1 2))` to see if they are indeed equal. In contrast, the\nterm *list structure* refers to any data structure made out of pairs,\nnot just to lists.>> The above sequence could be produced by `(list 1 2\n3 4)`. In general,\n\n```clj\n(list <a1> <a2> ... <an>)\n```\n\nis equivalent to\n\n```clj\n(cons <a1> (cons <a2> (cons ... (cons <an> nil) ...)))\n```\n\nLisp systems conventionally print lists by printing the sequence of\nelements, enclosed in parentheses. Thus, the data object in [figure\n2.4](#!/sicp/ch/2/fig/4/) is printed as `(1 2 3 4)`:\n\n```clj\n(def one-through-four (list 1 2 3 4)\n\none-through-four\n(1 2 3 4)\n```\n\nBe careful not to confuse the expression `(list 1 2 3 4)` with the list\n`(1 2 3 4)`, which is the result obtained when the expression is\nevaluated. Attempting to evaluate the expression `(1 2 3 4)` will\nsignal an error when the interpreter tries to apply the procedure 1 to\narguments 2,3, and 4.\n\nWe can think of `car` as selecting the first item in the list (as I'm\nsure you surmised `first` does), and of `cdr` as selecting the sublist\nconsisting of the rest of the items (as does `rest`). This is actually\nmore true in Clojure than in Scheme.<<In Clojure the procedure we would\nbe dealing with is, `rest`, which, given a list returns a new list\nconsisting of all but the first item. A key thing to notice here is\nthat unlike `cdr`, when you supply `rest` with a list, it returns a\nlist. Always. So, `(rest (list 1 2))` returns `(2)`, and `(rest (list\n1))` would return `()`, the empty list.>> Nested applications of\n`first` and `rest` can be used to extract the second, third, and\nsubsequent items in the list. Our language, along with `first` has a\n`second` procedure which, given a list returns the second value. The\nconstructor `cons` makes a list like the original one, but with an\nadditional item at the beginning, but Clojure has a more general\nversion called `conj` built in that works well with other sequential\nobjects. So, as we've seen, prepending things on a list is very cheap\n(computationally). That is why `conj` prepends things to lists. There\nare other sequential objects that `conj` operates on and doesn't\nprepend, but we'll get into that later.\n\n```clj\n(first one-through-four)\n1\n\n(rest one-through-four)\n(2 3 4)\n\n(first (rest one-through-four))\n2\n\n(second one-through-four)\n2\n\n(cons 10 one-through-four)\n(10 1 2 3 4)\n\n(conj one-through-four 10)\n(10 1 2 3 4)\n\n(cons 5 one-through-four)\n(5 1 2 3 4)\n\n(conj one-through-four 5)\n(5 1 2 3 4)\n\n(conj one-through-four 5 6 7)\n(7 6 5 1 2 3 4)\n```\n\nNotice in that last one that `conj` put them in backward. That is\nbecause `conj` prepends them one by one in the order they appear. The\nvalue of `nil`, used to terminate the chain of pairs, in Clojure is\nonly named `nil` for legacy reasons. In Scheme, however, `nil` was a\nsequence of no elements or the *empty list*. The word *nil* is a\ncontraction of the Latin word *nihil*, which means \"nothing\".<<It&#39;s\nremarkable how much energy in the standardization of Lisp dialects has\nbeen dissipated in arguments that are literally over nothing: Should\n`nil` be an ordinary name? Should the value of `nil` be a symbol?\nShould it be a list? Should it be a pair? In Scheme, `nil` is an\nordinary name, which we use in this section as a variable whose value\nis the end-of-list marker (just as `true` is an ordinary variable that\nhas a true value). Other dialects of Lisp, including Common Lisp, treat\nnil as a special symbol. The authors of this book, who have endured too\nmany language standardization brawls, would like to avoid the entire\nissue. Once we have introduced quotation in [section\n2.3](#!/sicp/ch/2/sect/3/), we will denote the empty list as `&#39;()`\nand dispense with the variable `nil` entirely.>>")) "" (data/ssub {:title "List Operations"} (md {} "The use of pairs to represent sequences of elements as lists is\naccompanied by conventional programming techniques for manipulating\nlists by successively \"cdring down\" the lists. For example, the\nprocedure `list-ref` in Scheme and `nth` in Clojure takes as arguments\na list and a number \\\\(n\\\\) and returns the \\\\(n\\\\)th item of the list.\nIt is customary to number the elements of the list beginning with 0.\nThe method for computing `nth` is the following:\n\n- For \\\\(n=0\\\\), `nth` should return the `first` of the list.\n\n- Otherwise, `nth` should return the \\\\(n-1\\\\)st item of the `rest` of the list.\n\n```clj\n(defn nth [items n]\n  (loop [things items\n         number n]\n    (if (= number 0)\n        (first things)\n        (recur (rest things) (dec number)))))\n(def squares (list 1 4 9 16 25))\n\n(nth squares 3)\n16\n```\n\nOften we `cdr` down the whole list. To aid in this, Scheme includes a\nprimitive `null?`, which tests whether its argument is the empty list.\nBeing as how Clojure is intended to be more general than that, the\nanalog in Clojure, called `empty?` accepts any collection as an\nargument, and returns true if that collection is empty and false\notherwise. The Scheme procedure `length`, which returns the number of\nitems in a list (called `count` in Clojure), illustrates this typical\npattern of use:\n\n```clj\n(defn count [items]\n  (if (empty? items)\n      0\n      (inc (length (rest items)))))\n(def odds (list 1 3 5 7))\n\n(count odds)\n4\n```\n\nThe `count` procedure implements a simple recursive plan. The reduction step is:\n\n- The `count` of any list is 1 plus the count of the `rest` of the list.\n\nThis is applied successively until we reach the base case:\n\n- The `count` of the empty list is 0.\n\nWe could also compute `count` in an iterative style:\n\n```clj\n(defn count [items]\n  (loop [things items\n         accu   0]\n    (if (empty? things)\n        accu\n        (recur (rest things) (inc accu)))))\n```\n\nAnother conventional programming technique is to \"cons up\" an answer\nlist while cdring down a list, as in the procedure `append` (`concat`\nin Clojure), which takes two lists as arguments and combines their\nelements to make a new list:\n\n```clj\n(concat squares odds)\n(1 4 9 16 25 1 3 5 7)\n\n(concat odds squares)\n(1 3 5 7 1 4 9 16 25)\n```\n\n`concat` is also implemented using a recursive plan. To `concat` lists\n`list1` and `list2`, do the following:\n\n- If `list1` is the empty list, then the result is just `list2`.\n\n- Otherwise, `concat` the `rest` of `list1` and `list2`, and `conj` the\n`first` of `list1` onto the result:\n\n```clj\n(defn concat [list1 list2]\n  (if (empty? list1)\n      list2\n      (conj (concat (rest list1) list2) (first list1))))\n```")) "" (data/exercises {} (data/exercise {} (md {} "Define a procedure `last-pair` that returns the list that contains\nonly the last element of a given (nonempty) list:\n\n```clj\n(last-pair (list 23 72 149 34))\n34\n```") "" (data/q-a {} (md {} "```clj\n(defn last-pair [items]\n  (loop [things items]\n    (if (empty? (rest things))\n        things\n        (recur (rest things)))))\n```"))) "" (data/exercise {} (md {} "Define a procedure `reverse` that takes a list as arguments and\nreturns a list of the same elements in reverse order:\n\n```clj\n(reverse (list 1 4 9 16 25))\n(25 16 9 4 1)\n```") "" (data/q-a {} (md {} "```clj\n(defn reverse [items]\n  (loop [things items\n         accu   nil]\n    (if (empty? things)\n        accu\n        (recur (rest things) (conj accu (first things))))))\n```\n\nClojure already has a procedure `reverse` that does exactly that.\nClojure has many powerful tools for manipulating sequences. You can\ncheck them out at [Clojure.org](http://clojure.org/sequences)."))) "" (data/exercise {} (md {} "Consider the change-counting program of [section\n1.2.2](#!/sicp/ch/1/sect/2/sub/2/). It would be nice to be able to\neasily change the currency used by the program, so that we could\ncompute the number of ways to change a british pound, for example. As\nthe program is written, the knowledge of the currency is distributed\npartly into the procedure `first-denomination` and partly into the\nprocedure `count-change` (which knows that there are five kids of\nU.S. coins). It would be nicer to be able to supply a list of coins\nto be used for making change.\n\nWe want to rewrite the procedure `cc` so that its second argument is\na list of the values of the coins to use rather than an integer\nspecifying which coins to use. We could then have lists that defined\neach kind of currency:\n\n```clj\n(def us-coins (list 50 25 10 5 1))\n(def uk-coins (list 100 50 20 10 5 2 1 0.5))\n```\n\nWe could then call `cc` as follows:\n\n```clj\n(cc 100 us-coins)\n292\n```\n\nTo do this will require changing the program `cc` somewhat. It will\nstill have the same form, but it will access its second argument\ndifferently, as follows:\n\n```clj\n(defn cc [amount coin-values]\n  (cond (= amount 0) 1\n        (or (> 0 amount) (no-more? coin-values)) 0\n        :else (+ (cc amount\n                     (except-first-denomination coin-values))\n                 (cc (- amount \n                        (first-denomination coin-values))\n                     coin-values))))\n```\n\nDefine the procedures `first-denomination`,\n`except-first-denomination`, and `no-more?` in terms of primitive\noperations on list structures. Does the order of the list\n`coin-values` affect the answer produced by `cc`? Why or why not?") "" (data/q-a {} (md {} "```clj\n(defn first-denomination [coins]\n  (first coins))\n(defn except-first-denomination [coins]\n  (rest coins))\n(defn no-more? [coins]\n  (empty? coins))\n```\n\nOr, we could have done it this way,\n\n```clj\n(def first-denomination first)\n(def except-first-denomination rest)\n(def no-more empty?)\n```\n\nwhich requires fewer steps to evaluate.\n\nAs far as the order, the procedure would return the same answer,\nbut it would require a lot more steps and more memory (which might\ncause a stack overflow if the `amount` is high enough. If you don't\nunderstand what I'm saying, draw a diagram of what would happen if\nthe order of the coins were reversed (pennies up to half-dollars in\nUSD)."))) "" (data/exercise {} (md {} "The procedures `+`, `*`, and `list` take arbitrary numbers of\narguments. One way to define such procedures is to use `defn` with\n*dotted-tail notation*. In a procedure definition in Scheme, a\nparameter list that has a dot before the last parameter name\nindicates that, when the procedure is called, the initial parameters\n(if any) will have as values the initial arguments, as usual, but the\nfinal parameter's value will be a list of any remaining arguments.\nClojure has a similar construct, but instead of a dot, we use an\nampersand. For instance, given the definition\n\n```clj\n(defn f [x y & z] <body>)\n```\n\nthe procedure `f` can be called with two or more arguments. If we evaluate\n\n```clj\n(f 1 2 3 4 5 6)\n```\n\nthen in the body of `f`, `x` will be 1, `y` will be 2, and `z` will\nbe the list `(3 4 5 6)`. Given the definition\n\n```clj\n(defn g [& w] <body>)\n```\n\nthe procedure `g` can be called with zero or more arguments. If we evaluate\n\n```clj\n(g 1 2 3 4 5 6)\n```\n\nthen in the body of `g`, `w` will be the list `(1 2 3 4 5 6)`.\n\nUse this notation to write a procedure `same-parity` that takes one\nor more integers and returns a list of all the arguments that have\nthe same even-odd parity as the first argument. For example,\n\n```clj\n(same-parity 1 2 3 4 5 6 7)\n(1 3 5 7)\n\n(same-parity 2 3 4 5 6 7)\n(2 4 6)") "" (data/q-a {} (md {} "```clj\n(defn same-parity* [x items]\n  (let [parity (mod x 2)]\n    (loop [things items\n           accu   (list x)]\n      (cond (empty? things)\n            accu\n            (= (mod (first things) 2) parity)\n            (recur (rest things)\n                   (conj accu (first things)))\n            :else (recur (rest things) accu)))))\n(defn same-parity [x & y]\n  (reverse (same-parity* (x y))))\n```")))) "" (data/ssub {:title "Mapping Over Lists"} (md {} "One extremely useful operation is to apply some transformation to\neach element in a list and generate the list of results. For\ninstance, the following procedure scales each number in a list by a\ngiven factor:\n\n```clj\n(defn scale-list [items factor]\n  (if (empty? items)\n      nil\n      (conj (* (first items) factor)\n        (scale-list (rest items) factor))))\n\n(scale-list (list 1 2 3 4 5) 10)\n(10 20 30 40 50)\n```\n\nIn an effort to get used to writing in ways that won't cause stack\noverflow errors, let's turn this recursive procedure into an\niterative one using `loop`.") "" (data/q-a {} (md {} "```clj\n(defn scale-list* [items factor]\n  (loop [things items\n         accu   (list )]\n    (if (empty? things)\n        accu\n        (recur (rest things)\n               (conj accu\n                     (* factor \n                        (first things)))))))\n(defn scale-list [items factor]\n  (reverse (scale-list* items factor)))\n```")) "" (md {} "We can abstract this general idea and capture it as a common patter\nexpressed as a higher-order procedure, just as in [section\n1.3](#!/sicp/ch/1/sect/3/). The higher-order procedure here is called\n`map`. `map` takes as arguments a procedure of one argument and a\nsequential object (in our case a list), and in our case, returns a\nlist of the results produced by applying the procedure to each\nelement of the list<<Scheme standardly provides a map procedure that\nis more general than the one described here. This more general map\ntakes a procedure of n arguments, together with n lists, and applies\nthe procedure to all the first elements of the lists, all the second\nelements of the lists, and so on, returning a list of the results.\nFor example, `(map + (list 1 2 3) (list 40 50 60) (list 700 800\n900))` returns `(741 852 963)`, and so on.>>\n\n```clj\n(defn map [proc items]\n  (if (empty? items)\n      nil\n      (conj (proc (first items))\n            (map proc (rest items)))))\n(defn abs [x] (Math/abs x))\n(map abs (list -10 2.5 -11.6 17))\n(10 2.5 11.6 17)\n(map (fn [x] (* x x))\n     (list 1 2 3 4))\n(1 4 9 16)\n```\n\nLet's try to make this one iterative as well!") "" (data/q-a {} (md {} "```clj\n(defn map* [proc items]\n  (loop [things items\n         accu   (list )]\n    (if (empty? things)\n        accu\n        (recur (conj accu\n                     (proc (first things)))))))\n(defn map [proc items]\n  (reverse (map* proc items)))\n```")) "" (md {} "Now we can give a new definition of `scale-list` in terms of `map`:\n\n```clj\n(defn scale-list [items factor]\n  (map (fn [x] (* x factor))\n       items))\n```\n\n`map` is an important construct, not only because it captures a\ncommon pattern, but because it establishes a higher level of\nabstraction in dealing with lists. In the original definition of\n`scale-list`, the recursive structure of the program draws attention\nto the element-by-element processing of the list. Defining\n`scale-list` in terms of `map` surpresses that level of detail and\nemphasizes that scaling transforms a list of elements to a list of\nresults. The difference between the two definitions is not that the\ncomputer is performing a differnt process (it isn't) but that we\nthink about the process differently. In effect, `map` helps establish\nan abstraction barrier that isolates the implementation of procedures\nthat transform lists from the details of how the elements of the list\nare extracted and combined. Like the barriers shown in [figure\n2.1](#!/sicp/ch/2/fig/1/), this abstraction gives us the flexibility\nto change the low-level details of how sequences are implemented,\nwhile preserving the conceptual framework of operations that\ntransform sequences to sequences. [Section\n2.2.3](#!/sicp/ch/2/sect/2/sub/3/) expands on this use of sequences\nas a framework for organizing programs.")) "" (data/exercises {} (data/exercise {} (md {} "The procedure `square-list` takes a list of numbers as arguments and\nreturns a list of the squares of those numbers.\n\n```clj\n(square-list (list 1 2 3 4))\n(1 4 9 16)\n```\n\nHere are two different definitions of `square-list`. Complete both of\nthem by filling in the missing expressions:\n\n```clj\n(defn square-list* [items]\n  (loop [things items\n         accu   (list )] \n    (if (empty? items)\n        accu\n        (recur <??> <??>))))\n(defn square-list [items]\n  (reverse (square-list* items)))\n```\n\nAnd,\n\n```clj\n(defn square-list [items]\n  (map <??> <??>))\n```") "" (data/q-a {} (md {} "```clj\n(defn square-list [items]\n  (loop [things items\n         accu   (list )]\n    (if (empty? things)\n        nil\n        (recur (rest things)\n               (conj accu (square (first things)))))))\n\n(defn square-list [items]\n  (map square items))\n```"))) "" (data/exercise {} (md {} "Louis Reasoner tries to rewrite the first `square-list` procedure of\n[exercise 2.21](#!/sicp/ch/2/ex/21/) so that it evolves an iterative\nprocess:\n\n```clj\n(defn square-list [items]\n  (loop [things items\n         accu   (list )]\n    (if (empty? things)\n        accu\n        (recur (rest things)\n               (conj accu \n                     (square (first things)))))))\n```\n\nUnfortunately, defining `square-list` this way produces the answer list in the reverse order of the one desired. Why?") "" (data/q-a {} (md {} "As you probably noticed, I used an auxiliary function (decorated\nwith an asterisk) to define the iterative part, then the actual\nfunction just applies `reverse` to the auxiliary one. The reason\nis, every time we `conj` onto a list, the things get put out in\nfront. So if we take things off the front of one list, then put\nthem on the front of the other, we're reversing the order.")) "" (md {} "Louis then tries to fix his bug by using `cons` instead of `conj`,\nand interchanging the arguments to `cons`:\n\n```clj\n(defn square-list [items]\n  (loop [things items\n         accu   (list )]\n    (if (empty? things)\n        accu\n        (recur (rest things)\n               (cons accu\n                     (square (first things)))))))\n```\n\nThis doesn't work either. Explain.") "" (data/q-a {} (md {} "This is not how lists are constructed. Let's see what happens with\nan actual example. Let's see what this would return:\n\n```clj\n(square-list (list 1 2 3))\n(loop [things (list 1 2 3)\n       accu  (list )]\n  (if (empty? (list 1 2 3))\n      accu\n      (recur (rest (list 1 2 3))\n             (cons accu \n                   (square (first (list 1 2 3)))))))\n(empty? list 1 2 3) ;false, so...\n(recur (rest (list 1 2 3))\n       (cons (list )\n             (square (first (list 1 2 3)))))\n(recur (list 2 3)\n       (cons (list )\n             (square 1)))\n(recur (list 2 3)\n       (cons (list )\n             1))\n;Error: Don't know how to create ISeq from Java Long.\n```\n\nThat happened because `cons` requires a sequential object as its\nsecond argument. Since numbers are not sequential objects, we get\nthat error."))) "" (data/exercise {} (md {} "The Scheme procedure `for-each` is similar to `map`. It takes as\narguments a procedure and a list of elements. However, rather than\nforming a list of the results, `for-each` just applies the procedure\nto each of the elements in turn, from left to right. The values\nreturned by applying the procedure to the elements are not used at\nall --`for-each` is used with procedures that perform an action, such\nas printing. For example,\n\n```scm\n(for-each (lambda (x) (newline) (display x)) \n          (list 57 321 88))\n57\n321\n88\n```\n\nWe have something similar in Clojure, called `doseq`. The function\ndiffers mainly in the syntax for calling it. In the traditional\nClojurian sytnax, it starts out with bindings, then you just say what\nyou want it to do. For example,\n\n```clj\n(doseq [x (list 57 321 88)]\n  (println x))\n57\n321\n88\n```\n\nYou might notice, if you are following along with an open repl trying\nthese things for yourself, that `nil` was printed below the 88. That\nis because, like everything else in Clojure, `doseq` returns a value,\nwhich happens to be `nil`. `doseq` always returns `nil` (just\nsomething to keep in mind).\n\nLet's pretend, however, that we prefer the Scheme version of things.\nGive an implementation of `for-each` (without using `doseq`).") "" (data/q-a {} (md {} "```clj\n(defn for-each [proc items]\n  (loop [things items]\n    (if (empty? things)\n        nil\n        (do (proc (fist things))\n            (recur (rest things))))))\n```")))) "" (data/subsect {:title "Hierarchical Structures"} (md {} "The representation of sequences in terms of lists generalizes naturally\nto represent sequences whose elements may themselves be sequences. For\nexample, we can regard the object `((1 2) 3 4)` constructed by\n\n```clj\n(conj (list 3 4) (list 1 2))\n```\n\nas a list of three items, the first of which is itself a list `(1 2)`.\nIndeed, this is suggested by the form in which the result is printed by\nthe interpreter. [Figure 2.5](#!/sicp/ch/2/fig/5/) shows the\nrepresentation of this structure in terms of pairs.") "" (data/fig {:footer "Structure formed by (conj (list 3 4) (list 1 2))"}) "" (md {} "Another way to think of sequences whose elements are sequences is as\n*trees*. The elements of the sequence are the branches of the tree, and\nelements that are themselves sequences are subtrees. [Figure\n2.6](#!/sicp/ch/2/fig/6/) shows the structure in [Figure\n2.5](#!/sicp/ch/2/fig/5/) viewed as a tree.") "" (data/fig {:footer "The list structure in figure 2.5 viewed as a tree."}) "" (md {} "Recursion is a natural tool for dealing with tree structures, since we\ncan often reduce operations on trees to operations on their branches,\nwhich reduce in tern to operations on the branches of the branches, and\nso on, until we reach the leaves of the tree. As an example, compare\nthe `length` procedure of [section 2.2.1](#!/sicp/ch/2/sect/2/sub/1/)\nwith the `count-leaves` procedure, which returns the total number of\nleaves of a tree:\n\n```clj\n(def x (conj (list 3 4) (list 1 2)))\n((1 2) 3 4)\n\n(length x)\n3\n\n(count-leaves x)\n4\n\n(list x x)\n(((1 2) 3 4) ((1 2) 3 4))\n\n(length (list x x))\n2\n\n(count-leaves (list x x))\n8\n```\n\nTo implement `count-leaves`, recall the recursive plan for computing\n`length`:\n\n- `length` of a list `x` is 1 plus the `length` of the `rest` of `x`.\n\n- `length` of the empty list is 0.\n\n`count-leaves` is similar. The value for the empty list is the same:\n\n- `count-leaves` of the empty list is 0.\n\nBut in the reduction step, where we strip off the `first` of the list,\nwe must take into account that the `first` may itself be a tree whose\nleaves we need to count. Thus, the appropriate reduction step is\n\n- `count-leaves` of a tree `x` is `count-leaves` of the `first` of `x`\nplus `count-leaves` of the `rest` of `x`.\n\nFinally, by taking `first`s we reach actual leaves, so we need another\nbase case:\n\n- `count-leaves` of a leaf is 1.\n\nTo aid in writing recursive procedures on trees, Scheme provides a\nprimitive predicate `pair?`, which tests whether its argument is a\npair. Since pairs aren't really a thing in Clojure, but rather we deal\nin lists directly, what, would you suppose, is the primitive to tell\nwhether something is a list? The procedure `list?`, of course.\nAlternatively, for our program, we could use the more general `seq?`,\nwhich returns `true` when its argument is any sequential object, and\nfalse otherwise. But we'll use `list` because, we don't really know the\nimplications of including vectors and things into this function yet.\nHere is the complete procedure:\n\n```clj\n(defn count-leaves [x]\n  (cond (and (list? x)\n             (empty? x)) 0\n        (not (list? x)) 1\n        :else (+ (count-leaves (first x))\n                 (count-leaves (rest x)))))\n```")) "" (data/exercises {} (data/exercise {} (md {} "Suppose we evaluate the expression `(list 1 (list 2 (list 3 4)))`.\nGive the result printed by the interpreter, the corresponding\nbox-and-pointer structure, and the interpretation of this as a tree\n(as in [figure 2.6](#!/sicp/ch/2/fig/6/)).") "" (data/q-a {} (md {} "```clj\n(list 1 (list 2 (list 3 4)))\n(1 (2 (3 4)))\n```\n\nBut if you didn't see that one already, I think you're missing the\npoint of this site here.\n\nAs for the diagram, I will put that in later... If anyone even\nreads this far... On that note: If you have read this far, please,\nshoot me an email at\n[amniskin@gmail.com](mailto:amniskin@gmail.com). I'd love to hear\nany suggestions or just any feedback at all, really."))) "" (data/exercise {} (md {} "Give combinations of `first` and `rest` that will pick 7 from each of\nthe following lists:\n\n```clj\n(1 3 (5 7) 9)\n\n((7))\n\n(1 (2 (3 (4 (5 (6 7))))))\n```") "" (data/q-a {} (md {} "```clj\n(rest (list 1 3 (5 7) 9))\n(3 (5 7) 9)\n\n(rest (rest (list 1 3 (5 7) 9)))\n((5 7) 9)\n\n(first (rest (rest (list 1 3 (5 7) 9))))\n(5 7)\n\n(rest (first (rest (rest (list 1 3 (5 7) 9)))))\n(7)\n```\n\nSo we want, `first`, `rest`, `first`, `rest`, `rest` (in written\norder, not the order of application).\n\nThe second, we want `first`, `first`.\n\nThe third:\n\n```clj\n(rest (list 1 (2 (3 (4 (5 (6 7)))))))\n((2 (3 (4 (5 (6 7))))))\n```\n\nSo, we can see that we're going to have to do alternating `first`s\nand `rest`s till we get to the answer (if you don't believe me,\nwrite it out a bit, and be sure to check that this hypothesis works\nat the end as well!).\n\nSo our answer is, `first`, `rest`, repeated 6 times (again, in\nwritten order, or equivalently, reverse application order)."))) "" (data/exercise {} (md {} "Suppose we define `x` and `y` to be two lists:\n\n```clj\n(def x (list 1 2 3))\n(def y (list 4 5 6))\n```\n\nWhat result is printed by the interpreter in response to evaluating\neach of the following expressions:\n\n```clj\n(concat x y)\n\n(conj x y)\n\n(list x y)\n```") "" (data/q-a {} (md {} "```clj\n(concat x y)\n(1 2 3 4 5 6)\n\n(conj x y)\n((4 5 6) 1 2 3)\n\n(list x y)\n((1 2 3) (4 5 6))\n```"))) "" (data/exercise {} (md {} "Modify your `reverse` procedure of [exercise\n2.18](#!/sicp/ch/2/ex/18/) to produce a `deep-reverse` procedure that\ntakes a list as argument and returns as its value the list with its\nelements reversed and with all sublists deep-reversed as well. For\nexample,\n\n```clj\n(def x (list (list 1 2) (list 3 4)))\n\nx\n((1 2) (3 4))\n\n(reverse x)\n((3 4) (1 2))\n\n(deep-reverse x)\n((4 3) (2 1))") "" (data/q-a {} (md {} "```clj\n(defn deep-reverse [items]\n  (loop [things items\n         accu   (list )]\n    (cond (and (list? things)\n               (empty? things)) accu\n          (not (list? things)) things\n          :else (recur (rest things)\n                       (conj accu\n                             (deep-reverse (first things)))))))\n```"))) (data/exercise {} (md {} "Write a procedure `fringe` that takes as argument a tree (represented\nas a list) and returns a list whose elements are all the leaves of\nthe tree arranged in left-to-right order. For example,\n\n```clj\n(def x (list (list 1 2) (list 3 4)))\n\n(fringe x)\n(1 2 3 4)\n\n(fringe (list x x))\n(1 2 3 4 1 2 3 4)\n```") "" (data/q-a {} (md {} "```clj\n(defn fringe* [items]\n  (loop [things items\n         accu   (list )]\n    (cond (not (list? things))\n          (throw (Exception. \"Oops. That's not a list.\"))\n          (empty? things)\n          accu\n          (list? (first things))\n          (recur (concat (first things)\n                         (rest things))\n                 accu)\n          :else\n          (recur (rest things)\n                 (conj accu\n                       (first things))))))\n(defn fringe [items]\n  (reverse (fringe* items)))\n```\n\nIf you execute this, it should return an error. The reason being\nthat `concat` doesn't return a `list`, but rather a lazy sequence.\nTo account for this, we could write:\n\n```clj\n(defn fringe* [items]\n  (loop [things items\n         accu   (list )]\n    (cond (not (seq? things))\n          (throw (Exception. \"Oops. That's not a sequential object!.\"))\n          (empty? things)\n          accu\n          (seq? (first things))\n          (recur (concat (first things)\n                         (rest things))\n                 accu)\n          :else\n          (recur (rest things)\n                 (conj accu\n                       (first things))))))\n(defn fringe [items]\n  (reverse (fringe* items)))\n```"))) "" (data/exercise {} (md {} "A binary mobile consists of two branches, a left branch and a right branch. Each branch is a rod of a certain length, from which hangs either a weight or another binary mobile. We can represent a binary mobile using compund data by constructing it from two branches (for example, using `list`):\n\n```clj\n(defn make-mobile [left right]\n  (list left right))\n```\n\nA branch is constructed from a `length` (which must be a number)\ntogether with a `structure`, which may be either a number\n(representing a simple weight) or another mobile:\n\n```clj\n(defn make-branch [length structure]\n  (list length structure))\n```\n\na. Write the corresponding selectors `left-branch` and\n`right-branch`, which return the branches of a mobile, and\n`branch-length` and `branch-structure`, which return the components\nof a branch.") "" (data/q-a {} (md {} "```clj\n(defn left-branch [mobile]\n  (first mobile))\n(defn right-branch [mobile]\n  (second mobile))\n(defn branch-length [branch]\n  (first branch))\n(defn branch-structure [branch]\n  (second branch))\n```")) "" (md {} "b. Using your selectors, define a procedure `total-weight` that\nreturns the total weight of a mobile.") "" (data/q-a {} (md {} "```clj\n(defn total-weight [mobile]\n  (if (seq? mobile)\n      (+ (total-weight (left-branch mobile))\n         (total-weight (right-branch mobile)))\n      mobile))\n```")) "" (md {} "c. A mobile is said to be *balanced* if the torque applied by its\ntop-left branch is equal to that applied by its top-right branch\n(that is, if the length of the left rod multiplied by the weight\nhanging from that rod is equal to the corresponding product for the\nright side) and if each of the submobiles hanging off its branches is\nbalanced. Design a predicate that tests whether a binary mobile is\nbalanced.") "" (data/q-a {} (md {} "```clj\n(def branch-torque [branch]\n  (* (length branch)\n     (total-weight (structure branch))))\n(defn top-level-balanced? [mobile]\n  (= (branch-torque (left-branch mobile))\n     (branch-torque (right-branch mobile))))\n(defn balanced? [mobile]\n  (if (not (seq? mobile))\n      true\n      (and (top-level-balanced? mobile)\n           (balanced? (structure (left-branch mobile)))\n           (balanced? (structure (right-branch mobile))))))\n```")) "" (md {} "d. Now suppose we change the constructor\n\n```clj\n(defn make-mobile [left right]\n  (conj right left))\n```\n\nHow much do you need to change to your programs to convert them to\nthe new representation?") "" (data/q-a {} (md {} "```clj\n(defn left-branch [mobile]\n  (first mobile))\n(defn right-branch [mobile]\n  (rest mobile))\n```\n\nAnd we're good to go.")))) "" (data/ssub {:title "Mapping Over Trees"} (md {} "Just as `map` is a powerful abstraction for dealing with sequences,\n`map` together with recursion is a powerful abstraction for dealing\nwith trees. For instance, the `scale-tree` procedure, analogous to\n`scale-list` of [section 2.2.1](#!/sicp/ch/2/sect/2/sub/1/), takes as\narguments a numeric factor and a tree whose leaves are numbers. It\nreturns a tree of the same shape, where each number is multiplied by\nthe factor. The recursive plan for `scale-tree` is similar to the one\nfor `count-leaves`:\n\n```clj\n(defn scale-tree [tree factor]\n  (cond (not (seq? tree)) (* tree factor)\n        (empty? tree) nil\n        :else (conj (scale-tree (rest tree) factor)\n                    (scale-tree (first tree) factor))))\n\n(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))\n            10)\n(10 (20 (30 40) 50) (60 70))\n```\n\nAnother way to implement `scale-tree` is to regard the tree as a\nsequence of sub-trees and use `map`. We mape over the sequence, scaling\neach sub-tree in turn, and return the list of results. In the base\ncase, where the tree is a leaf, we simply multiply by the factor:\n\n```clj\n(defn scale-tree [tree factor]\n  (map (fn [sub-tree]\n         (if (seq? sub-tree)\n           (scale-tree sub-tree factor)\n           (* sub-tree factor)))\n       tree))\n```\n\nMany tree operations can be implemented by similar combinations of\nsequence operations and recursion.")) "" (data/exercises {} (data/exercise {} (md {} "Define a procedure `square-tree` analogous to the `square-list`\nprocedure of [exercise 2.21](#!/sicp/ch/2/ex/21/). That is,\n`square-tree` should behave as follows:\n\n```clj\n(square-tree\n  (list 1\n        (list 2 (list 3 4) 5)\n        (list 6 7)))\n(1 (4 (9 16) 25) (36 49))\n```\n\nDefine `square-tree` both directly (i.e., without using any\nhigher-order procedures) and also by using `map` and recursion.") "" (data/q-a {} (md {} "```clj\n(defn square-tree [tree]\n  (map (fn [sub-tree]\n         (if (seq? sub-tree)\n             (square-tree sub-tree)\n             (square sub-tree)))\n       tree))\n```\n\nOr,\n\n```clj\n(defn square-tree [tree]\n  (cond (not (seq? tree)) (square tree)\n        (empty? tree) nil\n        :else\n        (conj (square-tree (rest tree))\n              (square-tree (first tree)))))\n```"))) "" (data/exercise {} (md {} "Abstract your answer to [exercise 2.30](#!/sicp/ch/2/ex/30/) to\nproduce a procedure `tree-map` with the property that `square-tree`\ncould be defined as\n\n```clj\n(defn square-tree [tree]\n  (tree-map square tree))\n```") "" (data/q-a {} "```clj\n(defn tree-map [proc tree]\n  (map #(if (seq? %)\n            (tree-map proc %)\n            (proc %))\n       tree))\n```\n\nOr, if you prefer the non-abstraction-beholding version (which I\ndon't see why you would):\n\n```clj\n(defn tree-map [proc tree]\n  (cond (not (seq? tree)) (proc tree)\n        (empty? tree) nil\n        :else\n        (conj (tree-map proc (rest tree))\n              (tree-map proc (first tree)))))\n```")) "" (data/exercise {} (md {} "We can represent a set as a list of distinct elements, and we can\nrepresent the set of all subsets of the set as a list of lists. For\nexample, if the set is `(1 2 3)`, then the set of all subsets is,\n`(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))`. Complete the following\ndefinition of a procedure that generates the set of subsets of a set\nand give a clear explanation of why it works:\n\n```clj\n(defn subsets [s]\n  (if (empty? s)\n      (list (list ))\n      (let [left (subsets (rest s))]\n        (concat left (map <??> left)))))\n```") "" (data/q-a {} "```clj\n(defn subsets [s]\n  (if (empty? s)\n      (list (list ))\n      (let [left (subsets (rest s))]\n        (concat left \n                (map #(conj % \n                            (first s))\n                     left)))))\n```\n\nSo, the procedure in question is, `#(conj % (first s))`. As for why\nthis works, let's build it up inductively -- by that I mean that we\nshould look at this step by step. Let's assume we've already computed\n`(subsets (rest s))`, and see what we have to do to get `(subsets\ns)`.\n\nFirstly, if the list is `(list )` (in which case we can't use our\nassumption), then our procedure returns `(())`, which we know to be\ncorrect.\n\nNext, let's assume that our list `s` is not empty, and that we've\ncomputed `(subsets (rest s))`. If we take any subset `d` of `s` and\ndisregard `(first s)` if it's an element of `d`, then this (possibly)\nnew version of `d` is in `(subsets (rest s))`. Hence, we can generate\nany element of `(subsets s)` by either taking it directly from\n`(subsets (rest s))`, or by \"conjing\" `(first s)` onto something from\n`(subsets (rest s))`. Therefore, `(subsets s)`= `(subsets (rest s))`\n\\\\(\\cup\\\\) `(map #(conj % (first s)) (subsets (rest s)))`.\n\nIf this is at all unclear, please let me know. It's kinda hard to\nexplain things without any feedback."))) "" (data/subsect {:title "Sequences as Conventional Interfaces"} (md {} "In working with compound data, we've stressed how data abstraction\npermits us to design programs without becoming enmeshed in the details\nof data representations, and how abstraction preserves for us the\nflexibility to experiment with alternative representations. In this\nsection, we introduce another powerful design principle for working\nwith data structures -- the use of *conventional interfaces*.\n\nIn [section 1.3](#!/sicp/ch/1/sect/3/) we saw how program abstractions,\nimplemented as higher-order procedures, can capture common patterns in\nprograms that deal with numerical data. Our ability to formulate\nanalogous operations for working with compound data depends crucially\non the style in which we manipulate our data structures. Consider, for\nexample, the following procedure, analogous to the `count-leaves`\nprocedure of [section 2.2.2](#!/sicp/ch/2/sect/2/sub/2/), which takes a\ntree as argument and computes the sum of the squares of the leaves that\nare odd:\n\n```clj\n(defn sum-odd-squares [tree]\n  (cond (empty? tree) 0\n        (not (seq? tree)) (if (odd? tree)\n                              (square tree)\n                              0)\n        :else (+ (sum-odd-squares (first tree))\n                 (sum-odd-squares (rest tree)))))\n```\n\nOn the surface, this procedure is very different from the following\none, which constructs a list of all the even Fibonacci numbers\n\\\\(Fib(k)\\\\), where \\\\(k\\\\) is less than or equal to a given integer\n\\\\(n\\\\):\n\n```clj\n(defn even-fibs [n]\n  (let [next (fn [k] (if (> k n)\n                         (list )\n                         (let [f (fib k)]\n                           (if (even? f)\n                               (conj (next (+ k 1)) f)\n                               (next (+ k 1)))))))\n  (next 0))\n```\n\nDespite the fact that these two procedures are structurally very\ndifferent, a more abstract description of the two computations reveals\na great deal of similarity. The first program\n\n- enumerates the leaves of a tree;\n- filters them, selecting the odd ones;\n- squares each of the selected one; and\n- accumulates the results unsing +, starting with 0.\n\nThe second program\n\n- enumerates the integers from 0 to \\\\(n\\\\);\n- computes the fibonacci number for each integer;\n- filters them, selecting the even ones; and\n- accumulates the results using `conj`, starting with the empty list.\n\nA signal-processing engineer would find it natural to conceptualize\nthese processes in terms of signals flowing through a cascade of\nstages, each of which implements part of the program plan, as shown in\n[figure 2.7](#!/sicp/ch/2/fig/7/). In `sum-odd-squares`, we begin with\nan *enumerator*, which generates a \"signal\" consisting of the leaves of\na given tree. This signal is passed through a *filter*, which\neliminates all but the odd elements. The resulting signal is in turn\npassed through a *map*, which is a \"transducer\" that applies the\n`square` procedure to each element. The output of the map is then fed\nto an *accumulator*, which combines the elements using +, starting from\nan initial 0. The plan for `even-fibs` is analogous.") "" (data/fig {:footer "The signal-flow plans for the procedures sum-odd-squares (top) and even-fibs (bottom) reveal the commonality between the two programs."}) "" (md {} "Unfortunately, the two procedure definitions above fail to exibit this\nsignal-flow structure. For instance, if we examine the\n`sum-odd-squares` procedure, we find that the enumeration is\nimplemented partly by the `empty?` and `seq?` tests and partly by the\ntree-recursive structure of the procedure. Similarly, the accumulation\nis found partly in the tests and partly in the addition used in the\nrecursion. In general, there are no distinct parts of either procedure\nthat correspond to the elements in the signal-flow description. Our two\nprocedures decompose the computations in a different way, spreading the\nenumeration of the program and mingling it with the map, the filter,\nand the accumulation. If we could reorganize our programs to make the\nsignal-flow structure manifest in the procedures we write, this would\nincrease the conceptual clarity of the resulting code.")) "" (data/ssub {:title "Sequence Operations"} (md {} "The key to organizing programs so as to more clearly reflect the\nsignal-flow structure is to concentrate on the \"signals\" that flow from\none stage in the process to the next. If we represent these signals as\nlists, then we can use list operations to implement the processing at\neach of the stages. For instance, we can implement the mapping stages\nof the signal-flow diagrams using the `map` procedure from [section\n2.2.1](@!/sicp/ch/2/sect/2/sub/1/):\n\n```clj\n(map square (list 1 2 3 4 5))\n(1 4 9 16 25)\n```\n\nFiltering a sequence to select only those elements that satisfy a given\npredicate is accomplished by\n\n```clj\n(defn filter [predicate sequence]\n  (cond (empty? sequence) (list )\n        (predicate (first sequence)) (conj (filter predicate \n                                                   (rest sequence))\n                                           (first sequence))\n        :else (filter predicate (rest sequence))))\n```\n\nFor example,\n\n```clj\n(filter odd? (list 1 2 3 4 5))\n(1 3 5)\n```\n\nAccumulations can be implemented by\n\n```clj\n(defn accumulate [op initial sequence]\n  (if (empty? sequence)\n      initial\n      (op (first sequence)\n          (accumulate op initial (rest sequence)))))\n\n(accumulate + 0 (list 1 2 3 4 5))\n15\n\n(accumulate * 1 (list 1 2 3 4 5))\n120\n\n(accumulate cons nil (list 1 2 3 4 5))\n(1 2 3 4 5)\n```\n\nNote: in the original SICP, `accumulate` is defined as:\n\n```scm\n(define (accumulate op initial sequence)\n  (if (null? sequence)\n      initial\n      (op (car sequence)\n          (accumulate op initial (cdr sequence)))))\n```\n\nIf we wanted to define this so as to be able to use `conj` instead of\n`cons`, what would we have to change?\n\nAll that remains to implement signal-flow diagrams is to enumerate the\nsequence of elements to be processed. For `even-fibs`, we need to\ngenerate the sequence of integers in a given range, which we can do as\nfollows:\n\n```clj\n(defn enumerate-interval [low high]\n  (if (> low high)\n      nil\n      (cons low (enumerate-interval (+ low 1) high))))\n(enumerate-interval 2 7)\n(2 3 4 5 6 7)\n```\n\nClojure has such a function, and it is called `range`. `range` is a\nfunction that takes, 1, 2 or 3 arguments. For more information on\n`range`, see\n[clojure.org](http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/range).\nTry to define this using `conj` instead. Does it make a difference? Why\nor why not?\n\nTo enumerate the leaves of a tree, we can use<<This is, in fact,\nprecisely the fringe procedure from exercise 2.28. Here we&#39;ve\nrenamed it to emphasize that it is part of a family of general\nsequence-manipulation procedures.>>\n\n```clj\n(defn enumerate-tree [tree]\n  (cond (empty? tree) nil\n        (not (seq? tree)) (list tree)\n        :else (concat (enumerate-tree (first tree))\n                      (enumerate-tree (rest tree)))))\n(enumerate-tree (list 1 (list 2 (list 3 4)) 5))\n(1 2 3 4 5)\n```\n\nNow we can refomulate `sum-odd-squares` and `even-fibs` as in the\nsignal-flow diagrams. For `sum-odd-squares`, we enumerate teh sequence\nof leaves of the tree, filter this to keep only the odd numbers in the\nsequence, square each element, and sum the results:\n\n```clj\n(defn summ-odd-squares [tree]\n  (accumulate +\n              0\n              (map square\n                   (filter odd?\n                           (enumerate-tree tree)))))\n```\n\nFor `even-fibs`, we enumerate the integers from 0 to \\\\(n\\\\), generate\nthe Fibonacci number for each of these integers, filter the resulting\nsequence to keep only the even elements, and accumulate the results\ninto a list:\n\n```clj\n(defn even-fibs [n]\n  (accumulate cons\n              nil\n              (filter even?\n                      (map fib\n                           (range n)))))\n```\n\nThe value of expressing programs as sequence operations is that this\nhelps us make program designs that are modular, that is, designs that\nare constructed by combining relatively independent pieces. We can\nencourage modular design by providing a library of standard components\ntogether with a conventional interface for connecting the components in\nflexible ways.\n\nModular construction is a powerful strategy for controlling complexity\nin engineering design. In real signal-processing applications, for\nexample, designers regularly build systems by cascading elements\nselected from standard program elements that we can mix and match. For\ninstance, we can reuse pieces from the `sum-odd-squares` and\n`even-fibs` procedures in a program that constructs a list of the\nsquares of the first \\\\(n+1\\\\) Fibonacci numbers:\n\n```clj\n(defn list-fib-squares [n]\n  (accumulate cons\n              nil\n              (map square\n                   (map fib\n                        (range n)))))\n(list-fib-squares 10)\n(0 1 1 4 9 25 64 169 441 1156 3025)\n```\n\nWe can rearrange the pieces and use them in computing the product of\nthe odd integers in a sequence:\n\n```clj\n(defn product-of-squares-of-odd-elements [items]\n  (accumulate *\n              1\n              (map square\n                (filter odd? items))))\n(product-of-squares-of-odd-elements (list 1 2 3 4 5))\n225\n```\n\nThese examples give just a hint of the vast range of operations that\ncan be expressed as sequence operations.<<Richard Waters (1979)\ndeveloped a program that automatically analyzes traditional Fortran\nprograms, viewing them in terms of maps, filters, and accumulations. He\nfound that fully 90 percent of the code in the Fortran Scientific\nSubroutine Package fits neatly into this paradigm. One of the reasons\nfor the success of Lisp as a programming language is that lists provide\na standard medium for expressing ordered collections so that they can\nbe manipulated using higher-order operations. The programming language\nAPL owes much of its power and appeal to a similar choice. In APL all\ndata are represented as arrays, and there is a universal and convenient\nset of generic operators for all sorts of array operations.>>\n\nSequences, implemented here as lists, serve as a conventional interface\nthat permits us to combine processing modules. Additionally, when we\nuniformly represent structures as sequences, we have localized the\ndata-structure dependencies in our programs to a small number of\nsequences, while leaving the overall design of our programs intact. We\nwill exploit this capability in [section 3.5](#!/sicp/ch/3/sect/5/),\nwhen we generalize the sequence-processing paradigm to admit infinite\nsequences.")) "" (data/exercises {} (data/exercise {} (md {} "Fill in the missing expressions to complete the following definitions\nof some basic list-manipulation operations as accumulations:\n\n```clj\n(defn map [p items]\n  (accumulate (fn [x y] <??>) nil sequence))\n\n(defn concat [items1 items2]\n  (accumulate conj <??> <??>))\n\n(defn count [items]\n  (accumulate <??> 0 items))\n```") "" (data/q-a {} (md {} "```clj\n(defn map [p items]\n  (accumulate (fn [x y] (p x)) nil sequence))\n\n(defn concat [items1 items2]\n  (accumulate cons\n              items2\n              (reverse items1)))\n\n(defn count [items]\n  (accumulate (fn [x y] (+ y 1) 0 items)))\n```"))) "" (data/exercise {} (md {} "Evaluating a polynomial in \\\\(x\\\\) at a given value of \\\\(x\\\\) can be\nformulated as an accumulation. We evaluate the polynomial\n\n$$a_nx^n+a_{n-1}x^{n-1}+...+a_1x+a_0$$\n\nusing a well-known algorithm called *Horner's rule*, which structures\nthe computation as\n\n$$(...(a_n x+a_{n-1}) x+...+a_1)x+a_0 $$\n\nIn other words, we start with \\\\(a_n\\\\), multiply by \\\\(x\\\\), add\n\\\\(a_{n-1}\\\\), multiply by \\\\(x\\\\), and so on, until we reach\n\\\\(a_0\\\\).<<According to Knuth (1981), this rule was formulated by W.\nG. Horner early in the nineteenth century, but the method was\nactually used by Newton over a hundred years earlier. Horner&#39;s\nrule evaluates the polynomial using fewer additions and\nmultiplications than does the straightforward method of first\ncomputing an \\\\(x_n\\\\), then adding \\\\(a_{n-1}x_{n-1}\\\\), and so on.\nIn fact, it is possible to prove that any algorithm for evaluating\narbitrary polynomials must use at least as many additions and\nmultiplications as does Horner's rule, and thus Horner's rule is an\noptimal algorithm for polynomial evaluation. This was proved (for the\nnumber of additions) by A. M. Ostrowski in a 1954 paper that\nessentially founded the modern study of optimal algorithms. The\nanalogous statement for multiplications was proved by V. Y. Pan in\n1966. The book by Borodin and Munro (1975) provides an overview of\nthese and other results about optimal algorithms.>> Fill in the\nfollowing template to produce a procedure that evaluates a polynomial\nusing Horner's rule. Assume that the coefficients of the polynomial\nare arranged in a sequence, from \\\\(a_0\\\\) through \\\\(a_n\\\\).\n\n```clj\n(defn horner-eval [x coefficient-sequence]\n  (accumulate (fn [this-coeff higher-terms] <??>)\n              0\n              coefficient-sequence))\n```\n\nFor example, to compute \\\\(1+3x+5x^3+s^5\\\\) at \\\\(x=2\\\\) you would evaluate\n\n```clj\n(horner-eval 2 (list 1 3 0 5 0 1))\n```") "" (data/q-a {} (md {} "```clj\n(defn horner-eval [x coefficient-sequence]\n  (accumulate (fn [this-coeff higher-terms]\n                  (+ this-coeff (* x higher-tems)))\n              0\n              coefficient-sequence))\n```\n\nCan you write a procedure that will compute Horner's rule\niteratively?"))) "" (data/exercise {} (md {} "Redefine `count-leaves` from [section\n2.2.2](#!/sicp/ch/2/sect/2/sub/2/) as an accumulation:\n\n```clj\n(defn count-leaves [t]\n  (accumulate <??> <??> (map <??> <??>)))\n```") "" (data/q-a {} (md {} "```clj\n(defn count-leaves [t]\n  (accumulate +\n              0\n              (map (fn [x]\n                     (if (seq? x)\n                         (count-leaves x)\n                         1))\n                   t)))\n```"))) "" (data/exercise {} (md {} "The procedure `accumulate-n` is similar to `accumulate` except that\nit takes as its third argument a sequence of sequences, which are all\nassumed to have the same number of elements. It applies the\ndesignated accumulation procedure to combine all the first elements\nof the sequences, all the second elements of the sequences, and so\non, and returns a sequence of the results. For instance, if `s` is a\nsequence containing four sequences, `((1 2 3) (4 5 6) (7 8 9) (10 11\n12))`, then the value of `(accumulate-n + 0 s)` should be the\nsequence `(22 26 30)`. Fill in the missing expressions in the\nfollowing definition of `accumulate-n`:\n\n```clj\n(defn accumulate-n [op init items]\n  (if (empty? (first items))\n      nil\n      (cons (accumulate   op init <??>)\n            (accumulate-n op init <??>))))\n```") "" (data/q-a {} (md {} "```clj\n(defn accumulate-n [op init item]\n  (if (empty? (first items))\n      nil\n      (cons (accumulate   op init (map first items))\n            (accumulate-n op init (map rest items)))))\n```"))) "" (data/exercise {} (md {} "Suppose we represent vectors \\\\(v=(v_i)\\\\) as sequences of numbers,\nand matrices \\\\(m=(m_{ij})\\\\) as sequences of vectors (the rows of\nthe matrix). For example, the matrix\n\n$$\\left[\\begin{array}{cccc}\n1 & 2 & 3 & 4 \\\\\\\\\n4 & 5 & 6 & 6 \\\\\\\\\n6 & 7 & 8 & 9\n\\end{array}\\right]$$\n\nis represented as the sequence `((1 2 3 4) (4 5 6 6) (6 7 8 9))`.\nWith this representation, we can use sequence operations to concisely\nexpress the basic matrix and vector operations. These operations\n(which are described in any book on matrix algebra) are the\nfollowing:\n\n$$\\begin{align*} \n(\\text{dot-product }v \\cdot w) & \\text{ returns the sum } \\sum_i v_iw_i \\\\\\\\\n(\\text{matrix times vector }m \\cdot v) & \\text{ returns the vector } t \\text{, where }t_i=\\sum_j m_{ij}v_j \\\\\\\\\n(\\text{matrix times matrix }m \\times n) & \\text{ returns the matrix }p\\text{ where }p_{ij}=\\sum_k m_{ik}n_{kj} \\\\\\\\\n(\\text{transpose }m) & \\text{ returns the matrix }n \\text{ where}n_{ij}=m_{ji} \\\\\\\\\n\\end{align*}$$\n\nWe can define the product as<<This definition uses the extended\nversion of map described in footnote 12. Luckily, our `map` function\ncan already take multiple list arguments. Play around with it and see\nhow it works.>>\n\n```clj\n(defn dot-product [v w]\n  (accumulate + 0 (map * v w)))\n```\n\nFill in the missing expressions in the following procedures for\ncomputing the other matrix operations. (The procedure `accumulate-n`\nis defined in [exercise 2.36](#!/sicp/ch/2/ex/36/).)\n\n```clj\n(defn matrix-*-vector [m v]\n  (map <??> m))\n\n(defn transpose [m]\n  (accumulate-n <??> <??> m))\n\n(defn matrix-*-matrix [m n]\n  (let [cols (transpose n)]\n    (map <??> m)))\n```") "" (data/q-a {} (md {} "```clj\n(defn matrix-*-vector [m v]\n  (map #(dot-product v %) m))\n\n(defn transpose [m]\n  (accumulate-n cons nil m))\n\n(defn matrix-*-matrix [m n]\n  (let [cols (transpose n)]\n    (map #(matrix-*-vector cols %) m))\n```"))) "" (data/exercise {} (md {} "The `accumulate` procedure is also known as `fold-right`, because it\ncombines the first element of the sequence with the result of\ncombining all the elements to the right. There is also a `fold-left`,\nwhich is similar to `fold-right`, except that it combines elements\nworking in the opposite direction:\n\n```clj\n(defn fold-left [op initial items]\n  (loop [result initial\n         things items]\n    (if (empty? things)\n        result\n        (recur (op result (first things))\n               (rest things)))))\n```\n\nWhat are the values of\n\n```clj\n(fold-right / 1 (list 1 2 3))\n```") "" (data/q-a {} (md {} "```clj\n(fold-right / 1 (list 1 2 3))\n(/ 1 (fold-right / 1 (list 2 3)))\n(/ 1 (/ 2 (fold-right / 1 (list 3))))\n(/ 1 (/ 2 (/ 3 1)))\n(/ 1 (/ 2 3))\n3/2\n```")) "" (md {} "```clj\n(fold-left / 1 (list 1 2 3))\n```") "" (data/q-a {} (md {} "```clj\n(fold-left / 1 (list 1 2 3))\n(loop 1 (list 1 2 3))\n(loop 1/1 (list 2 3))\n(loop 1 (list 2 3))\n(loop 1/2 (list 3))\n(loop 1/6 (list ))\n1/6\n```")) "" (md {} "```\n(fold-right list nil (list 1 2 3))\n```") "" (data/q-a {} (md {} "```clj\n(fold-right list nil (list 1 2 3))\n(list 1 (fold-right list nil (list 2 3)))\n(list 1 (list 2 (fold-right list nil (list 3))))\n(list 1 (list 2 (list 3 (fold-right list nil (list )))))\n(list 1 (list 2 (list 3 nil)))\n(1 (2 (3 nil)))\n```")) "" (md {} "```clj\n(fold-left list nil (list 1 2 3))\n```") "" (data/q-a {} (md {} "```clj\n(fold-left list nil (list 1 2 3))\n(loop nil (list 1 2 3))\n(loop (list nil 1) (list 2 3))\n(loop (list (list nil 1) 2) (list 3))\n(loop (list (list (list nil 1) 2) 3) (list ))\n(((nil 1) 2) 3)\n```")) "" (md {} "```clj\n(fold-right cons nil (list 1 2 3))\n```") "" (data/q-a {} (md {} "```clj\n(fold-right cons nil (list 1 2 3))\n(cons 1 (fold-right cons nil (list 2 3)))\n(cons 1 (cons 2 (fold-right cons nil (list 3))))\n(cons 1 (cons 2 (cons 3 (fold-right cons nil (list )))))\n(cons 1 (cons 2 (cons 3 nil)))\n(1 2 3)\n```")) "" (md {} "```clj\n(fold-left cons nil (list 1 2 3))\n```") "" (data/q-a {} (md {} "```clj\n(fold-left cons nil (list 1 2 3))\n(loop nil (list 1 2 3))\n(loop (cons nil 1) (list 2 3))\njava.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long\n```\n\nWhy did that happen?") "" (data/q-a {} (md {} "Because the second argument to `cons` must be a sequential\nobject! Remember the box and pointer drawing? The purpose of\n`cons` is to create linked lists (like the ones depicted in those\nfigures)."))) "" (md {} "Give a property that `op` should satisfy to guarantee that\n`fold-right` and `fold-left` will produce the same values for any\nsequence.") "" (data/q-a {} (md {} "Let's take a simple example: `(fold-left op init (list a))` unfolds as,\n\n```clj\n(op init a)\n```\n\nAnd `(fold-right op init (list a))` unfolds to:\n\n```clj\n(op a init)\n```\n\nSo, we see that we need `op` to be commutative.\n\nNow let's consider a slightly more convoluted example where `op` is\ncommutative (to see whether there are any further requirements on\n`op`). Let's consider `(fold-right op init (list a b))` and see if\nwe can get it in the same form as `(fold-left op init (list a b))`.\n\n```clj\n(fold-right op init (list a b))\n(op a (op b init))\n(op (op b init) a)\n```\n\nAnd `(fold-left op init (list a b))`\n\n```clj\n(op (op init a) b)\n(op b (op init a))\n```\n\nSo, in order for `(fold-right op init (list a b))` to equal\n`(fold-left op init (list a b))`, we require `(op (op b init)\na)`=`(op b (op init a))`. That property is called associativity.\n\nNow let's assume that our operation `op` is both commutative and\nassociative. Let's prove that no matter the size of the list, nor\nthe initial value (as long as it is an acceptable one [eg not 0 for\ndivision]) we will get the same value. This proof might be a little\ntricky to comprehend if you are not mathematically inclined; so if\nfeel free to move on if this doesn't interest you.\n\nLet's prove this by induction on `(count items)`, where `items` is\nthe list argument to the `fold-left` and `fold-right` procedures.\n\nThe base case is already taken care of above (cases `count`=1 and 2\nwere both done above). Now let's pick an \\\\(n>1\\\\) and assume that\nfor all \\\\(k\\lt n\\\\), if the list has \\\\(k\\\\) items, fold left and\nfold right are the same with this list and our specified operation\nand initial value.\n\nThen, we take `items` to be a list with \\\\(n\\\\) items in it. For\nease of notation, I will consider the list to be `(1 2 3 4 ... n)`,\nbut I will not actually consider the elements of the list to be\nnumbers necessarily. I make no assumption as to the content of the\nlist or the nature of the operator (other than it being commutative\nand associative). To reaffirm the fact that we are not dealing with\na concrete list here, I will denote the list as `(1 2... n)`\nwithout the `list` operator in front.\n\n```clj\n(fold-right op init items)\n=(fold-right op init (1 2 ... n))\n=(op 1 (op 2 (op ... (op n init))))\n=(op 1 (op 2 (op ... (op init n))))\n=(op 1 (op 2 (op ... (op (op <n-1> init) n))))\n=(op 1 (op 2 (op ... (op (op init <n-1>) n))))\n...\n=(op (op ... (op init 1) 2) ... n)\n=(fold-left op init items)\n```"))) "" (data/exercise {} (md {} "Complete the following definitions of `reverse` [exercise\n2.18](#!/sicp/ch/2/ex/18/) in terms of `fold-righ` and `fold-left`\nfrom [exercise 2.38](#!/sicp/ch/2/ex/38/):\n\n```clj\n(defn reverse [items]\n  (fold-right (fn [x y] <??>) nil items))\n\n(defn reverse [items]\n  (fold-left (fn [x y] <??>) nil itmes))\n```") "" (data/q-a {} (md {} "```clj\n(defn reverse [items]\n  (fold-right (fn [x y] (concat y (list x))) nil itms))\n\n(defn reverse [items]\n  (fold-left (fn [x y] (conj x y)) nil items))\n```\n\nOr, if we want to use `cons` instead of `conj`:\n\n```clj\n(defn reverse [items]\n  (fold-left (fn [x y] (cons y x)) nil itmes))\n```")))) "" (data/ssub {:title "Nested Mappings"} (md {} "We can extend the sequence paradigm to include many computations that\nare commonly expressed using nested loops.<<This approach to nested\nmappings was shown to us by David Turner, whose languages KRC and\nMiranda provide elegant formalisms for dealing with these constructs.\nThe examples in this section (see also [exercise\n2.42](#!/sicp/ch/2/ex/42/) are adapted from Turner 1981. In [section\n3.5.3](#!/sicp/ch/3/sect/5/sub/3/), we&#39;ll see how this approach\ngeneralizes to infinite sequences.>> Consider this problem: Given a\npositive integer \\\\(n\\\\), find all ordered pairs of distinct positive\nintegers \\\\(i\\\\) and \\\\(j\\\\), where \\\\(1\\lt j\\lt i\\lt n\\\\), such that\n\\\\(i + j\\\\) is prime. For example, if \\\\(n\\\\) is 6, then the pairs are\nthe following:\n\n$$\\begin{array}{l | r r r r r r r}\ni & 2 & 3 & 4 & 4 & 5 & 6 & 6 \\\\\\\\\nj & 1 & 2 & 1 & 3 & 2 & 1 & 5 \\\\\\\\\n\\\\hline\ni+j & 3 & 5 & 5 & 7 & 7 & 7 & 11 \\end{array}$$\n\nA natural way to organize this computation is to generalize the\nsequence of all ordered pairs of positive integers less than or equal\nto \\\\(n\\\\), filter to select those paris whose sum is prime, and then,\nfor each pair \\\\((i,j)\\\\) that passes the filter, produce the triple\n\\\\((i, j, i+j)\\\\).\n\nHere is a way to generate the sequence of pairs: For each integer\n\\\\(i\\leq n\\\\), enumerate the integers \\\\(j\\lt i\\\\), and for each such\n\\\\(i\\\\) and \\\\(j\\\\) generate the pair \\\\((i,j)\\\\). In terms of sequence\noperations, we map along the sequence `(range 1 (inc n))`. For each\n\\\\(i\\\\) in this sequence, we map along the sequence `(range 1 i 1)`.\nFor each \\\\(j\\\\) in this latter sequence, we generate the pair `(list i\nj)`. This gives us a sequence of pairs for each \\\\(i\\\\). Combining all\nthe sequences for all the \\\\(i\\\\) (by accumulating with `concat`)\nproduces the required sequence of pairs:<<Note the behavior of `range`.>>\n\n```clj\n(accumulate concat\n            nil\n            (map (fn [i]\n                   (map (fn [j] (list i j))\n                        (range 1 i)))\n                 (range 1 (inc n))))\n```\n\nThe combination of mapping and accumulating with `concat` is so common\nin this sort of program that we will isolate it as a separate\nprocedure:\n\n```clj\n(defn flatmap [proc seq]\n  (accumulate append nil (map proc seq)))\n```\n\nNow filter this sequence of pairs to find those whose sum is prime. The\nfilter predicate is called for each element of the sequence; its\nargument is a pair and it must extract the integers from the pair.\nThus, the predicate to apply to each element in the sequence is\n\n```clj\n(defn prime-sum? [pair]\n  (prime? (+ (first pair) (second pair))))\n```\n\nFinally, generate the sequence of results by mapping over the filtered\npairs using the following procedure, which constructs a triple\nconsisting of the two elements of the pair along with their sum:\n\n```clj\n(defn make-pair-sum [pair]\n  (list (first pair) (second pair) (+ (first pair) (second pair))))\n```\n\nCombining all these steps yields the complete procedure:\n\n```clj\n(defn prime-sum-pairs [n]\n  (make-pair-sum\n    (filter prime-sum?\n      (flatmap\n        (fn [i]\n          (map (fn [j] (list i j))\n               (range 1 i)))\n        (range 1 (inc n))))))\n```\n\nNested mappings are also useful for sequences other than those that\nenumerate intervals. Suppose we wish to generate all the permutations\nof a set \\\\(S\\\\); that is, all the ways of ordering the items in the\nset. For instance, the permutations of {1,2,3} are {1,2,3}, {1,3,2},\n{2,1,3}, {2,3,1}, {3,1,2}, and {3,2,1}. Here is a plan for generating\nthe permutations of \\\\(S\\\\): For each item \\\\(x\\\\) in \\\\(S\\\\),\nrecursively generate the sequence of permutations of \\\\(S-x\\\\),<<The\nset \\\\(S-x\\\\) is the set of all elements of \\\\(S\\\\), excluding\n\\\\(x\\\\)>> and adjoin \\\\(x\\\\) to the front of each one. This yields, for\neach \\\\(x\\\\) in \\\\(S\\\\), the sequence of permutations of \\\\(S\\\\) that\nbegin with \\\\(x\\\\).  Combining these sequences for all \\\\(x\\\\) gives\nall the permutations of \\\\(S\\\\):<<Semicolons in Scheme code are used to\nintroduce comments. Everything from the semicolon to the end of the\nline is ignored by the interpreter. In this book we don&#39;t use many\ncomments; we try to make our programs self-documenting by using\ndescriptive names.>>\n\n```clj\n(defn permutations [s]\n  (if (empty? s)      ; empty set?\n      (list (list ))  ; sequence containing only the empty list\n      (flatmap (fn [x]\n                 (map (fn [p] (cons x p))\n                      (permutations (remove x s))))\n               s)))\n```\n\nNotice how this strategy reduces the problem of generating permutations\nof \\\\(S\\\\) to the problem of generating the permutations of sets with\nfewer elements than \\\\(S\\\\). In the terminal case, we work our way down\nto the empty list, which represents a set of no elements. For this, we\ngenerate `(list (list ))`, which is a sequence with one item, namely\nthe set with no elements. The remove procedure used in permutations\nreturns all the items in a given sequence except for a given item. This\ncan be expressed as a simple filter:\n\n```clj\n(defn remove [item things]\n  (filter #(not= item %) \n          things))\n```")) "" (data/exercises {})))
