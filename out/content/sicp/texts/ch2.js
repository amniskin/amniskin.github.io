// Compiled by ClojureScript 0.0-3308 {:static-fns true, :optimize-constants true}
goog.provide('content.sicp.texts.ch2');
goog.require('cljs.core');
goog.require('tailrecursion.hoplon.markdown');
goog.require('content.sicp.book_data');
goog.require('tailrecursion.hoplon');
goog.require('tailrecursion.javelin');
/**
 * @param {...*} var_args
 */
content.sicp.texts.ch2.content = (function() { 
var content$sicp$texts$ch2$content__delegate = function (args__10403__auto__){
var vec__133716 = tailrecursion.hoplon.parse_args(args__10403__auto__);
var attr = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__133716,(0),null);
var kids = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__133716,(1),null);
return content.sicp.book_data.chapter.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$title,"Building Abstractions with Data"], null),(function (){var _STAR_references_STAR_133717 = tailrecursion.hoplon.markdown._STAR_references_STAR_;
var _STAR_abbreviations_STAR_133718 = tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_;
tailrecursion.hoplon.markdown._STAR_references_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_references_STAR_,null], 0));

tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_,null], 0));

try{var _STAR_references_STAR_133719 = tailrecursion.hoplon.markdown._STAR_references_STAR_;
var _STAR_abbreviations_STAR_133720 = tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_;
tailrecursion.hoplon.markdown._STAR_references_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_references_STAR_,cljs.core.PersistentArrayMap.EMPTY], 0));

tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_,cljs.core.List.EMPTY], 0));

try{return new cljs.core.PersistentVector(null, 14, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){var G__133721 = cljs.core.PersistentArrayMap.EMPTY;
var G__133722 = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){var G__133723 = cljs.core.PersistentArrayMap.EMPTY;
var G__133724 = new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We now come to the decisive step of mathematical abstraction: we forget about what the symbols stand for. ",(function (){var G__133725 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$ellipsis], null);
var G__133726 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__133725,G__133726) : tailrecursion.hoplon.markdown.simple_node.call(null,G__133725,G__133726));
})(),tailrecursion.hoplon.markdown.ref_link_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 2, [cljs.core.constant$keyword$separator_DASH_space,null,cljs.core.constant$keyword$reference_DASH_key,null], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The mathematician"], null)], 0))," need not be idle; there are many operations which he may carry out with these symbols, without ever having to look at the things they stand for."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__133723,G__133724) : tailrecursion.hoplon.markdown.para_node.call(null,G__133723,G__133724));
})(),(function (){var G__133727 = cljs.core.PersistentArrayMap.EMPTY;
var G__133728 = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Hermann Weyl, ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The Mathematical Way of Thinking"], null)], 0))], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__133727,G__133728) : tailrecursion.hoplon.markdown.para_node.call(null,G__133727,G__133728));
})()], null);
return (tailrecursion.hoplon.markdown.block_quote_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.block_quote_node.cljs$core$IFn$_invoke$arity$2(G__133721,G__133722) : tailrecursion.hoplon.markdown.block_quote_node.call(null,G__133721,G__133722));
})(),(function (){var G__133729 = cljs.core.PersistentArrayMap.EMPTY;
var G__133730 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We concentrated in chapter 1 on computational processes and on the role of procedures in program design. We saw how to use primitive data (numbers) and primitive operations (arithmetic operations), how to combine procedures to form compound procedures through composition, conditionals, and the use of parameters, and how to abstract procedures by using defining forms. We saw that a procedure can be regarded as a pattern for the local evolution of a process, and we classified, reasoned about, and performed simple algorithmic analyses of some common patterns for processes as embodied in procedures. We also saw that higher-order procedures enhance the power of our language by enabling us to manipulate, and thereby to reason in terms of, general methods of computation. This is much of the essence of programming."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__133729,G__133730) : tailrecursion.hoplon.markdown.para_node.call(null,G__133729,G__133730));
})(),(function (){var G__133731 = cljs.core.PersistentArrayMap.EMPTY;
var G__133732 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["In this chapter we are going to look at more complex data. All the procedures in chapter 1 operate on simple numerical data, and simple data are not sufficient for many of the problems we wish to address using computation. Programs are typically designed to model complex phenomena, and more often than not one must construct computational objects that have several parts in order to model real-world phenomena that have several aspects. Thus, whereas our focus in chapter 1 was on building abstractions by combining procedures to form compound procedures, we turn in this chapter to another key aspect of any programming language: the means it provides for building abstractions by combining data objects to form ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["compound data"], null)], 0)),"."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__133731,G__133732) : tailrecursion.hoplon.markdown.para_node.call(null,G__133731,G__133732));
})(),(function (){var G__133733 = cljs.core.PersistentArrayMap.EMPTY;
var G__133734 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Why do we want compound data in a programming language? For the same reasons that we want compound procedures: to elevate the conceptual level at which we can design our programs, to increase the modularity of our designs, and to enhance the expressive power of our language. Just as the ability to define procedures enables us to deal with processes at a higher conceptual level than that of the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__133733,G__133734) : tailrecursion.hoplon.markdown.para_node.call(null,G__133733,G__133734));
})(),(function (){var G__133735 = cljs.core.PersistentArrayMap.EMPTY;
var G__133736 = new cljs.core.PersistentVector(null, 11, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Consider the task of designing a system to perform arithmetic with rational numbers. We could imagine an operation ",(function (){var G__133737 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"add-rat"], null);
var G__133738 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133737,G__133738) : tailrecursion.hoplon.markdown.code_node.call(null,G__133737,G__133738));
})()," that takes two rational numbers and produces their sum. In terms of simple data, a rational number can be thought of as two integers: a numerator and a denominator. Thus, we could design a program in which each rational number would be represented by two integers (a numerator and a denominator) and where add-rat would be implemented by two procedures (one producing the numerator of the sum and one producing the denominator). But this would be awkward, because we would then need to explicitly keep track of which numerators corresponded to which denominators. In a system intended to perform many operations on many rational numbers, such bookkeeping details would clutter the programs substantially, to say nothing of what they would do to our minds. It would be much better if we could ",(function (){var G__133739 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double], null);
var G__133740 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["glue together"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__133739,G__133740) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__133739,G__133740));
})()," a numerator and denominator to form a pair ",(function (){var G__133741 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$endash], null);
var G__133742 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__133741,G__133742) : tailrecursion.hoplon.markdown.simple_node.call(null,G__133741,G__133742));
})()," a ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["compound data object"], null)], 0))," ",(function (){var G__133743 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$endash], null);
var G__133744 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__133743,G__133744) : tailrecursion.hoplon.markdown.simple_node.call(null,G__133743,G__133744));
})()," that our programs could manipulate in a way that would be consistent with regarding a rational number as a single conceptual unit."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__133735,G__133736) : tailrecursion.hoplon.markdown.para_node.call(null,G__133735,G__133736));
})(),(function (){var G__133745 = cljs.core.PersistentArrayMap.EMPTY;
var G__133746 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The use of compound data also enables us to increase the modularity of our programs. If we can manipulate rational numbers directly as objects in their own right, then we can separate the part of our program that deals with rational numbers per se from the details of how rational numbers may be represented as pairs of integers. The general technique of isolating the parts of a program that deal with how data objects are represented from the parts of a program that deal with how data objects are used is a powerful design methodology called ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data abstraction"], null)], 0)),". We will see how data abstraction makes programs much easier to design, maintain, and modify."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__133745,G__133746) : tailrecursion.hoplon.markdown.para_node.call(null,G__133745,G__133746));
})(),(function (){var G__133747 = cljs.core.PersistentArrayMap.EMPTY;
var G__133748 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The use of compound data leads to a real increase in the expressive power of our programming language. Consider the idea of forming a ",(function (){var G__133749 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double], null);
var G__133750 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["linear combination"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__133749,G__133750) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__133749,G__133750));
})()," \\(ax + by\\). We might like to write a procedure that would accept \\(a\\), \\(b\\), \\(x\\), and \\(y\\) as arguments and return the value of \\(ax + by\\). This presents no difficulty if the arguments are to be numbers, because we can readily define the procedure"], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__133747,G__133748) : tailrecursion.hoplon.markdown.para_node.call(null,G__133747,G__133748));
})(),(function (){var G__133751 = (function (){var G__133752 = new cljs.core.PersistentArrayMap(null, 2, [cljs.core.constant$keyword$class,"highlight",cljs.core.constant$keyword$style,"background: #f8f8f8"], null);
var G__133753 = (function (){var G__133754 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"line-height: 125%"], null);
var G__133755 = "(";
var G__133756 = (function (){var G__133779 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #008000; font-weight: bold"], null);
var G__133780 = "defn ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133779,G__133780) : tailrecursion.hoplon.span.call(null,G__133779,G__133780));
})();
var G__133757 = (function (){var G__133781 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133782 = "linear-combination";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133781,G__133782) : tailrecursion.hoplon.span.call(null,G__133781,G__133782));
})();
var G__133758 = " [";
var G__133759 = (function (){var G__133783 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133784 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133783,G__133784) : tailrecursion.hoplon.span.call(null,G__133783,G__133784));
})();
var G__133760 = " ";
var G__133761 = (function (){var G__133785 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133786 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133785,G__133786) : tailrecursion.hoplon.span.call(null,G__133785,G__133786));
})();
var G__133762 = " ";
var G__133763 = (function (){var G__133787 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133788 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133787,G__133788) : tailrecursion.hoplon.span.call(null,G__133787,G__133788));
})();
var G__133764 = " ";
var G__133765 = (function (){var G__133789 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133790 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133789,G__133790) : tailrecursion.hoplon.span.call(null,G__133789,G__133790));
})();
var G__133766 = "]\n  (";
var G__133767 = (function (){var G__133791 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #008000"], null);
var G__133792 = "+ ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133791,G__133792) : tailrecursion.hoplon.span.call(null,G__133791,G__133792));
})();
var G__133768 = "(";
var G__133769 = (function (){var G__133793 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #008000"], null);
var G__133794 = "* ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133793,G__133794) : tailrecursion.hoplon.span.call(null,G__133793,G__133794));
})();
var G__133770 = (function (){var G__133795 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133796 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133795,G__133796) : tailrecursion.hoplon.span.call(null,G__133795,G__133796));
})();
var G__133771 = " ";
var G__133772 = (function (){var G__133797 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133798 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133797,G__133798) : tailrecursion.hoplon.span.call(null,G__133797,G__133798));
})();
var G__133773 = ") (";
var G__133774 = (function (){var G__133799 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #008000"], null);
var G__133800 = "* ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133799,G__133800) : tailrecursion.hoplon.span.call(null,G__133799,G__133800));
})();
var G__133775 = (function (){var G__133801 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133802 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133801,G__133802) : tailrecursion.hoplon.span.call(null,G__133801,G__133802));
})();
var G__133776 = " ";
var G__133777 = (function (){var G__133803 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133804 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133803,G__133804) : tailrecursion.hoplon.span.call(null,G__133803,G__133804));
})();
var G__133778 = ")))\n";
return (tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$25 ? tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$25(G__133754,G__133755,G__133756,G__133757,G__133758,G__133759,G__133760,G__133761,G__133762,G__133763,G__133764,G__133765,G__133766,G__133767,G__133768,G__133769,G__133770,G__133771,G__133772,G__133773,G__133774,G__133775,G__133776,G__133777,G__133778) : tailrecursion.hoplon.pre.call(null,G__133754,G__133755,G__133756,G__133757,G__133758,G__133759,G__133760,G__133761,G__133762,G__133763,G__133764,G__133765,G__133766,G__133767,G__133768,G__133769,G__133770,G__133771,G__133772,G__133773,G__133774,G__133775,G__133776,G__133777,G__133778));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2(G__133752,G__133753) : tailrecursion.hoplon.div.call(null,G__133752,G__133753));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1(G__133751) : tailrecursion.hoplon.div.call(null,G__133751));
})(),(function (){var G__133805 = cljs.core.PersistentArrayMap.EMPTY;
var G__133806 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["But suppose we are not concerned only with numbers. Suppose we would like to express, in procedural terms, the idea that one can form linear combinations whenever addition and multiplication are defined ",(function (){var G__133807 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$endash], null);
var G__133808 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__133807,G__133808) : tailrecursion.hoplon.markdown.simple_node.call(null,G__133807,G__133808));
})()," for rational numbers, complex numbers, polynomials, or whatever. We could express this as a procedure of the form"], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__133805,G__133806) : tailrecursion.hoplon.markdown.para_node.call(null,G__133805,G__133806));
})(),(function (){var G__133809 = (function (){var G__133810 = new cljs.core.PersistentArrayMap(null, 2, [cljs.core.constant$keyword$class,"highlight",cljs.core.constant$keyword$style,"background: #f8f8f8"], null);
var G__133811 = (function (){var G__133812 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"line-height: 125%"], null);
var G__133813 = "(";
var G__133814 = (function (){var G__133839 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #008000; font-weight: bold"], null);
var G__133840 = "defn ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133839,G__133840) : tailrecursion.hoplon.span.call(null,G__133839,G__133840));
})();
var G__133815 = (function (){var G__133841 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133842 = "linear-combination";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133841,G__133842) : tailrecursion.hoplon.span.call(null,G__133841,G__133842));
})();
var G__133816 = " [";
var G__133817 = (function (){var G__133843 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133844 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133843,G__133844) : tailrecursion.hoplon.span.call(null,G__133843,G__133844));
})();
var G__133818 = " ";
var G__133819 = (function (){var G__133845 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133846 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133845,G__133846) : tailrecursion.hoplon.span.call(null,G__133845,G__133846));
})();
var G__133820 = " ";
var G__133821 = (function (){var G__133847 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133848 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133847,G__133848) : tailrecursion.hoplon.span.call(null,G__133847,G__133848));
})();
var G__133822 = " ";
var G__133823 = (function (){var G__133849 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133850 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133849,G__133850) : tailrecursion.hoplon.span.call(null,G__133849,G__133850));
})();
var G__133824 = "]\n  (";
var G__133825 = (function (){var G__133851 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #0000FF"], null);
var G__133852 = "add";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133851,G__133852) : tailrecursion.hoplon.span.call(null,G__133851,G__133852));
})();
var G__133826 = " (";
var G__133827 = (function (){var G__133853 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #0000FF"], null);
var G__133854 = "mul";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133853,G__133854) : tailrecursion.hoplon.span.call(null,G__133853,G__133854));
})();
var G__133828 = " ";
var G__133829 = (function (){var G__133855 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133856 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133855,G__133856) : tailrecursion.hoplon.span.call(null,G__133855,G__133856));
})();
var G__133830 = " ";
var G__133831 = (function (){var G__133857 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133858 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133857,G__133858) : tailrecursion.hoplon.span.call(null,G__133857,G__133858));
})();
var G__133832 = ") (";
var G__133833 = (function (){var G__133859 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #0000FF"], null);
var G__133860 = "mul";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133859,G__133860) : tailrecursion.hoplon.span.call(null,G__133859,G__133860));
})();
var G__133834 = " ";
var G__133835 = (function (){var G__133861 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133862 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133861,G__133862) : tailrecursion.hoplon.span.call(null,G__133861,G__133862));
})();
var G__133836 = " ";
var G__133837 = (function (){var G__133863 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__133864 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__133863,G__133864) : tailrecursion.hoplon.span.call(null,G__133863,G__133864));
})();
var G__133838 = ")))\n";
return (tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$27 ? tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$27(G__133812,G__133813,G__133814,G__133815,G__133816,G__133817,G__133818,G__133819,G__133820,G__133821,G__133822,G__133823,G__133824,G__133825,G__133826,G__133827,G__133828,G__133829,G__133830,G__133831,G__133832,G__133833,G__133834,G__133835,G__133836,G__133837,G__133838) : tailrecursion.hoplon.pre.call(null,G__133812,G__133813,G__133814,G__133815,G__133816,G__133817,G__133818,G__133819,G__133820,G__133821,G__133822,G__133823,G__133824,G__133825,G__133826,G__133827,G__133828,G__133829,G__133830,G__133831,G__133832,G__133833,G__133834,G__133835,G__133836,G__133837,G__133838));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2(G__133810,G__133811) : tailrecursion.hoplon.div.call(null,G__133810,G__133811));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1(G__133809) : tailrecursion.hoplon.div.call(null,G__133809));
})(),(function (){var G__133865 = cljs.core.PersistentArrayMap.EMPTY;
var G__133866 = cljs.core.PersistentVector.fromArray(["where ",(function (){var G__133867 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"add"], null);
var G__133868 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133867,G__133868) : tailrecursion.hoplon.markdown.code_node.call(null,G__133867,G__133868));
})()," and ",(function (){var G__133869 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"mul"], null);
var G__133870 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133869,G__133870) : tailrecursion.hoplon.markdown.code_node.call(null,G__133869,G__133870));
})()," are not the primitive procedures + and * but rather more complex things that will perform the appropriate operations for whatever kinds of data we pass in as the arguments ",(function (){var G__133871 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"a"], null);
var G__133872 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133871,G__133872) : tailrecursion.hoplon.markdown.code_node.call(null,G__133871,G__133872));
})(),", ",(function (){var G__133873 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"b"], null);
var G__133874 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133873,G__133874) : tailrecursion.hoplon.markdown.code_node.call(null,G__133873,G__133874));
})(),", ",(function (){var G__133875 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"x"], null);
var G__133876 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133875,G__133876) : tailrecursion.hoplon.markdown.code_node.call(null,G__133875,G__133876));
})(),", and ",(function (){var G__133877 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"y"], null);
var G__133878 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133877,G__133878) : tailrecursion.hoplon.markdown.code_node.call(null,G__133877,G__133878));
})(),". The key point is that the only thing ",(function (){var G__133879 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"linear-combination"], null);
var G__133880 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133879,G__133880) : tailrecursion.hoplon.markdown.code_node.call(null,G__133879,G__133880));
})()," should need to know about ",(function (){var G__133881 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"a"], null);
var G__133882 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133881,G__133882) : tailrecursion.hoplon.markdown.code_node.call(null,G__133881,G__133882));
})(),", ",(function (){var G__133883 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"b"], null);
var G__133884 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133883,G__133884) : tailrecursion.hoplon.markdown.code_node.call(null,G__133883,G__133884));
})(),", ",(function (){var G__133885 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"x"], null);
var G__133886 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133885,G__133886) : tailrecursion.hoplon.markdown.code_node.call(null,G__133885,G__133886));
})(),", and ",(function (){var G__133887 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"y"], null);
var G__133888 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133887,G__133888) : tailrecursion.hoplon.markdown.code_node.call(null,G__133887,G__133888));
})()," is that the procedures ",(function (){var G__133889 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"add"], null);
var G__133890 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133889,G__133890) : tailrecursion.hoplon.markdown.code_node.call(null,G__133889,G__133890));
})()," and ",(function (){var G__133891 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"mul"], null);
var G__133892 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133891,G__133892) : tailrecursion.hoplon.markdown.code_node.call(null,G__133891,G__133892));
})()," will perform the appropriate manipulations. From the perspective of the procedure ",(function (){var G__133893 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"linear-combination"], null);
var G__133894 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133893,G__133894) : tailrecursion.hoplon.markdown.code_node.call(null,G__133893,G__133894));
})(),", it is irrelevant what ",(function (){var G__133895 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"a"], null);
var G__133896 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133895,G__133896) : tailrecursion.hoplon.markdown.code_node.call(null,G__133895,G__133896));
})(),", ",(function (){var G__133897 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"b"], null);
var G__133898 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133897,G__133898) : tailrecursion.hoplon.markdown.code_node.call(null,G__133897,G__133898));
})(),", ",(function (){var G__133899 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"x"], null);
var G__133900 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133899,G__133900) : tailrecursion.hoplon.markdown.code_node.call(null,G__133899,G__133900));
})(),", and ",(function (){var G__133901 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"y"], null);
var G__133902 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133901,G__133902) : tailrecursion.hoplon.markdown.code_node.call(null,G__133901,G__133902));
})()," are and even more irrelevant how they might happen to be represented in terms of more primitive data. This same example shows why it is important that our programming language provide the ability to manipulate compound objects directly: Without this, there is no way for a procedure such as ",(function (){var G__133903 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"linear-combination"], null);
var G__133904 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133903,G__133904) : tailrecursion.hoplon.markdown.code_node.call(null,G__133903,G__133904));
})()," to pass its arguments along to ",(function (){var G__133905 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"add"], null);
var G__133906 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133905,G__133906) : tailrecursion.hoplon.markdown.code_node.call(null,G__133905,G__133906));
})()," and ",(function (){var G__133907 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"mul"], null);
var G__133908 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133907,G__133908) : tailrecursion.hoplon.markdown.code_node.call(null,G__133907,G__133908));
})()," without having to know their detailed structure.",(function (){var G__133909 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double_DASH_angle], null);
var G__133910 = new cljs.core.PersistentVector(null, 15, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The ability to directly manipulate procedures provides an analogous increase in the expressive power of a programming language. For example, in ",tailrecursion.hoplon.markdown.exp_link_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 2, [cljs.core.constant$keyword$url,"#!/sicp/ch/1/sect/3/sub/1/",cljs.core.constant$keyword$title,""], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["section 1.3.1"], null)], 0))," we introduced the ",(function (){var G__133911 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"sum"], null);
var G__133912 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133911,G__133912) : tailrecursion.hoplon.markdown.code_node.call(null,G__133911,G__133912));
})()," procedure, which takes a procedure ",(function (){var G__133913 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"term"], null);
var G__133914 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133913,G__133914) : tailrecursion.hoplon.markdown.code_node.call(null,G__133913,G__133914));
})()," as an argument and computes the sum of the values of ",(function (){var G__133915 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"term"], null);
var G__133916 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133915,G__133916) : tailrecursion.hoplon.markdown.code_node.call(null,G__133915,G__133916));
})()," over some specified interval. In order to define ",(function (){var G__133917 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"sum"], null);
var G__133918 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133917,G__133918) : tailrecursion.hoplon.markdown.code_node.call(null,G__133917,G__133918));
})(),", it is crucial that we be able to speak of a procedure such as term as an entity in its own right, without regard for how term might be expressed with more primitive operations. Indeed, if we did not have the notion of ",(function (){var G__133919 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double], null);
var G__133920 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["a procedure,"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__133919,G__133920) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__133919,G__133920));
})()," it is doubtful that we would ever even think of the possibility of defining an operation such as ",(function (){var G__133921 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"sum"], null);
var G__133922 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__133921,G__133922) : tailrecursion.hoplon.markdown.code_node.call(null,G__133921,G__133922));
})(),". Moreover, insofar as performing the summation is concerned, the details of how term may be constructed from more primitive operations are irrelevant."], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__133909,G__133910) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__133909,G__133910));
})()," We begin this chapter by implementing the rational-number arithmetic system mentioned above. This will form the background for our discussion of compound data and data abstraction. As with compound procedures, the main issue to be addressed is that of abstraction as a technique for coping with complexity, and we will see how data abstraction enables us to erect suitable ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["abstraction barriers"], null)], 0))," between different parts of a program."], true);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__133865,G__133866) : tailrecursion.hoplon.markdown.para_node.call(null,G__133865,G__133866));
})(),(function (){var G__133923 = cljs.core.PersistentArrayMap.EMPTY;
var G__133924 = new cljs.core.PersistentVector(null, 15, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We will see that the key to forming compound data is that a programming language should provide some kind of ",(function (){var G__133925 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double], null);
var G__133926 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["glue"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__133925,G__133926) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__133925,G__133926));
})()," so that data objects can be combined to form more complex data objects. There are many possible kinds of glue. Indeed, we will discover how to form compound data using no special ",(function (){var G__133927 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double], null);
var G__133928 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__133927,G__133928) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__133927,G__133928));
})()," operations at all, only procedures. This will further blur the distinction between ",(function (){var G__133929 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double], null);
var G__133930 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["procedure"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__133929,G__133930) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__133929,G__133930));
})()," and ",(function (){var G__133931 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double], null);
var G__133932 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data,"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__133931,G__133932) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__133931,G__133932));
})()," which was already becoming tenuous toward the end of chapter 1. We will also explore some conventional techniques for representing sequences and trees. One key idea in dealing with compound data is the notion of ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["closure"], null)], 0))," ",(function (){var G__133933 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$endash], null);
var G__133934 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__133933,G__133934) : tailrecursion.hoplon.markdown.simple_node.call(null,G__133933,G__133934));
})()," that the glue we use for combining data objects should allow us to combine not only primitive data objects, but compound data objects as well. Another key idea is that compound data objects can serve as ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["conventional interfaces"], null)], 0))," for combining program modules in mix-and-match ways. We illustrate some of these ideas by presenting a simple graphics language that exploits closure."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__133923,G__133924) : tailrecursion.hoplon.markdown.para_node.call(null,G__133923,G__133924));
})(),(function (){var G__133935 = cljs.core.PersistentArrayMap.EMPTY;
var G__133936 = new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We will then augment the representational power of our language by introducing ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["symbolic expressions"], null)], 0))," ",(function (){var G__133937 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$endash], null);
var G__133938 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__133937,G__133938) : tailrecursion.hoplon.markdown.simple_node.call(null,G__133937,G__133938));
})()," data whose elementary parts can be arbitrary symbols rather than only numbers. We explore various alternatives for representing sets of objects. We will find that, just as a given numerical function can be computed by many different computational processes, there are many ways in which a given data structure can be represented in terms of simpler objects, and the choice of representation can have significant impact on the time and space requirements of processes that manipulate the data. We will investigate these ideas in the context of symbolic differentiation, the representation of sets, and the encoding of information."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__133935,G__133936) : tailrecursion.hoplon.markdown.para_node.call(null,G__133935,G__133936));
})(),(function (){var G__133939 = cljs.core.PersistentArrayMap.EMPTY;
var G__133940 = new cljs.core.PersistentVector(null, 7, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Next we will take up the problem of working with data that may be represented differently by different parts of a program. This leads to the need to implement generic operations, which must handle many different types of data. Maintaining modularity in the presence of ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["generic operations"], null)], 0))," requires more powerful abstraction barriers than can be erected with simple data abstraction alone. In particular, we introduce ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data-directed programming"], null)], 0))," as a technique that allows individual data representations to be designed in isolation and then combined ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["additively"], null)], 0))," (i.e., without modification). To illustrate the power of this approach to system design, we close the chapter by applying what we have learned to the implementation of a package for performing symbolic arithmetic on polynomials, in which the coefficients of the polynomials can be integers, rational numbers, complex numbers, and even other polynomials."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__133939,G__133940) : tailrecursion.hoplon.markdown.para_node.call(null,G__133939,G__133940));
})()], null);
}finally {tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = _STAR_abbreviations_STAR_133720;

tailrecursion.hoplon.markdown._STAR_references_STAR_ = _STAR_references_STAR_133719;
}}finally {tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = _STAR_abbreviations_STAR_133718;

tailrecursion.hoplon.markdown._STAR_references_STAR_ = _STAR_references_STAR_133717;
}})()], 0));
};
var content$sicp$texts$ch2$content = function (var_args){
var args__10403__auto__ = null;
if (arguments.length > 0) {
var G__133941__i = 0, G__133941__a = new Array(arguments.length -  0);
while (G__133941__i < G__133941__a.length) {G__133941__a[G__133941__i] = arguments[G__133941__i + 0]; ++G__133941__i;}
  args__10403__auto__ = new cljs.core.IndexedSeq(G__133941__a,0);
} 
return content$sicp$texts$ch2$content__delegate.call(this,args__10403__auto__);};
content$sicp$texts$ch2$content.cljs$lang$maxFixedArity = 0;
content$sicp$texts$ch2$content.cljs$lang$applyTo = (function (arglist__133942){
var args__10403__auto__ = cljs.core.seq(arglist__133942);
return content$sicp$texts$ch2$content__delegate(args__10403__auto__);
});
content$sicp$texts$ch2$content.cljs$core$IFn$_invoke$arity$variadic = content$sicp$texts$ch2$content__delegate;
return content$sicp$texts$ch2$content;
})()
;
