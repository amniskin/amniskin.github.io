// Compiled by ClojureScript 0.0-3308 {:static-fns true, :optimize-constants true}
goog.provide('content.sicp.texts.ch2');
goog.require('cljs.core');
goog.require('tailrecursion.hoplon.markdown');
goog.require('content.sicp.book_data');
goog.require('tailrecursion.hoplon');
goog.require('tailrecursion.javelin');
/**
 * @param {...*} var_args
 */
content.sicp.texts.ch2.content = (function() { 
var content$sicp$texts$ch2$content__delegate = function (args__10403__auto__){
var vec__129002 = tailrecursion.hoplon.parse_args(args__10403__auto__);
var attr = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__129002,(0),null);
var kids = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__129002,(1),null);
return content.sicp.book_data.chapter.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$title,"Building Abstractions with Data"], null),(function (){var _STAR_references_STAR_129003 = tailrecursion.hoplon.markdown._STAR_references_STAR_;
var _STAR_abbreviations_STAR_129004 = tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_;
tailrecursion.hoplon.markdown._STAR_references_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_references_STAR_,null], 0));

tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_,null], 0));

try{var _STAR_references_STAR_129005 = tailrecursion.hoplon.markdown._STAR_references_STAR_;
var _STAR_abbreviations_STAR_129006 = tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_;
tailrecursion.hoplon.markdown._STAR_references_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_references_STAR_,cljs.core.PersistentArrayMap.EMPTY], 0));

tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_,cljs.core.List.EMPTY], 0));

try{return new cljs.core.PersistentVector(null, 14, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){var G__129007 = cljs.core.PersistentArrayMap.EMPTY;
var G__129008 = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){var G__129009 = cljs.core.PersistentArrayMap.EMPTY;
var G__129010 = new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We now come to the decisive step of mathematical abstraction: we forget about what the symbols stand for. ",(function (){var G__129011 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$ellipsis], null);
var G__129012 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__129011,G__129012) : tailrecursion.hoplon.markdown.simple_node.call(null,G__129011,G__129012));
})(),tailrecursion.hoplon.markdown.ref_link_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 2, [cljs.core.constant$keyword$separator_DASH_space,null,cljs.core.constant$keyword$reference_DASH_key,null], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The mathematician"], null)], 0))," need not be idle; there are many operations which he may carry out with these symbols, without ever having to look at the things they stand for."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__129009,G__129010) : tailrecursion.hoplon.markdown.para_node.call(null,G__129009,G__129010));
})(),(function (){var G__129013 = cljs.core.PersistentArrayMap.EMPTY;
var G__129014 = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Hermann Weyl, ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The Mathematical Way of Thinking"], null)], 0))], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__129013,G__129014) : tailrecursion.hoplon.markdown.para_node.call(null,G__129013,G__129014));
})()], null);
return (tailrecursion.hoplon.markdown.block_quote_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.block_quote_node.cljs$core$IFn$_invoke$arity$2(G__129007,G__129008) : tailrecursion.hoplon.markdown.block_quote_node.call(null,G__129007,G__129008));
})(),(function (){var G__129015 = cljs.core.PersistentArrayMap.EMPTY;
var G__129016 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We concentrated in chapter 1 on computational processes and on the role of procedures in program design. We saw how to use primitive data (numbers) and primitive operations (arithmetic operations), how to combine procedures to form compound procedures through composition, conditionals, and the use of parameters, and how to abstract procedures by using defining forms. We saw that a procedure can be regarded as a pattern for the local evolution of a process, and we classified, reasoned about, and performed simple algorithmic analyses of some common patterns for processes as embodied in procedures. We also saw that higher-order procedures enhance the power of our language by enabling us to manipulate, and thereby to reason in terms of, general methods of computation. This is much of the essence of programming."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__129015,G__129016) : tailrecursion.hoplon.markdown.para_node.call(null,G__129015,G__129016));
})(),(function (){var G__129017 = cljs.core.PersistentArrayMap.EMPTY;
var G__129018 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["In this chapter we are going to look at more complex data. All the procedures in chapter 1 operate on simple numerical data, and simple data are not sufficient for many of the problems we wish to address using computation. Programs are typically designed to model complex phenomena, and more often than not one must construct computational objects that have several parts in order to model real-world phenomena that have several aspects. Thus, whereas our focus in chapter 1 was on building abstractions by combining procedures to form compound procedures, we turn in this chapter to another key aspect of any programming language: the means it provides for building abstractions by combining data objects to form ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["compound data"], null)], 0)),"."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__129017,G__129018) : tailrecursion.hoplon.markdown.para_node.call(null,G__129017,G__129018));
})(),(function (){var G__129019 = cljs.core.PersistentArrayMap.EMPTY;
var G__129020 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Why do we want compound data in a programming language? For the same reasons that we want compound procedures: to elevate the conceptual level at which we can design our programs, to increase the modularity of our designs, and to enhance the expressive power of our language. Just as the ability to define procedures enables us to deal with processes at a higher conceptual level than that of the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__129019,G__129020) : tailrecursion.hoplon.markdown.para_node.call(null,G__129019,G__129020));
})(),(function (){var G__129021 = cljs.core.PersistentArrayMap.EMPTY;
var G__129022 = new cljs.core.PersistentVector(null, 11, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Consider the task of designing a system to perform arithmetic with rational numbers. We could imagine an operation ",(function (){var G__129023 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"add-rat"], null);
var G__129024 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129023,G__129024) : tailrecursion.hoplon.markdown.code_node.call(null,G__129023,G__129024));
})()," that takes two rational numbers and produces their sum. In terms of simple data, a rational number can be thought of as two integers: a numerator and a denominator. Thus, we could design a program in which each rational number would be represented by two integers (a numerator and a denominator) and where add-rat would be implemented by two procedures (one producing the numerator of the sum and one producing the denominator). But this would be awkward, because we would then need to explicitly keep track of which numerators corresponded to which denominators. In a system intended to perform many operations on many rational numbers, such bookkeeping details would clutter the programs substantially, to say nothing of what they would do to our minds. It would be much better if we could ",(function (){var G__129025 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double], null);
var G__129026 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["glue together"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__129025,G__129026) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__129025,G__129026));
})()," a numerator and denominator to form a pair ",(function (){var G__129027 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$endash], null);
var G__129028 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__129027,G__129028) : tailrecursion.hoplon.markdown.simple_node.call(null,G__129027,G__129028));
})()," a ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["compound data object"], null)], 0))," ",(function (){var G__129029 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$endash], null);
var G__129030 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__129029,G__129030) : tailrecursion.hoplon.markdown.simple_node.call(null,G__129029,G__129030));
})()," that our programs could manipulate in a way that would be consistent with regarding a rational number as a single conceptual unit."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__129021,G__129022) : tailrecursion.hoplon.markdown.para_node.call(null,G__129021,G__129022));
})(),(function (){var G__129031 = cljs.core.PersistentArrayMap.EMPTY;
var G__129032 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The use of compound data also enables us to increase the modularity of our programs. If we can manipulate rational numbers directly as objects in their own right, then we can separate the part of our program that deals with rational numbers per se from the details of how rational numbers may be represented as pairs of integers. The general technique of isolating the parts of a program that deal with how data objects are represented from the parts of a program that deal with how data objects are used is a powerful design methodology called ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data abstraction"], null)], 0)),". We will see how data abstraction makes programs much easier to design, maintain, and modify."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__129031,G__129032) : tailrecursion.hoplon.markdown.para_node.call(null,G__129031,G__129032));
})(),(function (){var G__129033 = cljs.core.PersistentArrayMap.EMPTY;
var G__129034 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The use of compound data leads to a real increase in the expressive power of our programming language. Consider the idea of forming a ",(function (){var G__129035 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double], null);
var G__129036 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["linear combination"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__129035,G__129036) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__129035,G__129036));
})()," \\(ax + by\\). We might like to write a procedure that would accept \\(a\\), \\(b\\), \\(x\\), and \\(y\\) as arguments and return the value of \\(ax + by\\). This presents no difficulty if the arguments are to be numbers, because we can readily define the procedure"], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__129033,G__129034) : tailrecursion.hoplon.markdown.para_node.call(null,G__129033,G__129034));
})(),(function (){var G__129037 = (function (){var G__129038 = new cljs.core.PersistentArrayMap(null, 2, [cljs.core.constant$keyword$class,"highlight",cljs.core.constant$keyword$style,"background: #f8f8f8"], null);
var G__129039 = (function (){var G__129040 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"line-height: 125%"], null);
var G__129041 = "(";
var G__129042 = (function (){var G__129065 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #008000; font-weight: bold"], null);
var G__129066 = "defn ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129065,G__129066) : tailrecursion.hoplon.span.call(null,G__129065,G__129066));
})();
var G__129043 = (function (){var G__129067 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129068 = "linear-combination";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129067,G__129068) : tailrecursion.hoplon.span.call(null,G__129067,G__129068));
})();
var G__129044 = " [";
var G__129045 = (function (){var G__129069 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129070 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129069,G__129070) : tailrecursion.hoplon.span.call(null,G__129069,G__129070));
})();
var G__129046 = " ";
var G__129047 = (function (){var G__129071 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129072 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129071,G__129072) : tailrecursion.hoplon.span.call(null,G__129071,G__129072));
})();
var G__129048 = " ";
var G__129049 = (function (){var G__129073 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129074 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129073,G__129074) : tailrecursion.hoplon.span.call(null,G__129073,G__129074));
})();
var G__129050 = " ";
var G__129051 = (function (){var G__129075 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129076 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129075,G__129076) : tailrecursion.hoplon.span.call(null,G__129075,G__129076));
})();
var G__129052 = "]\n  (";
var G__129053 = (function (){var G__129077 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #008000"], null);
var G__129078 = "+ ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129077,G__129078) : tailrecursion.hoplon.span.call(null,G__129077,G__129078));
})();
var G__129054 = "(";
var G__129055 = (function (){var G__129079 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #008000"], null);
var G__129080 = "* ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129079,G__129080) : tailrecursion.hoplon.span.call(null,G__129079,G__129080));
})();
var G__129056 = (function (){var G__129081 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129082 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129081,G__129082) : tailrecursion.hoplon.span.call(null,G__129081,G__129082));
})();
var G__129057 = " ";
var G__129058 = (function (){var G__129083 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129084 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129083,G__129084) : tailrecursion.hoplon.span.call(null,G__129083,G__129084));
})();
var G__129059 = ") (";
var G__129060 = (function (){var G__129085 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #008000"], null);
var G__129086 = "* ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129085,G__129086) : tailrecursion.hoplon.span.call(null,G__129085,G__129086));
})();
var G__129061 = (function (){var G__129087 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129088 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129087,G__129088) : tailrecursion.hoplon.span.call(null,G__129087,G__129088));
})();
var G__129062 = " ";
var G__129063 = (function (){var G__129089 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129090 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129089,G__129090) : tailrecursion.hoplon.span.call(null,G__129089,G__129090));
})();
var G__129064 = ")))\n";
return (tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$25 ? tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$25(G__129040,G__129041,G__129042,G__129043,G__129044,G__129045,G__129046,G__129047,G__129048,G__129049,G__129050,G__129051,G__129052,G__129053,G__129054,G__129055,G__129056,G__129057,G__129058,G__129059,G__129060,G__129061,G__129062,G__129063,G__129064) : tailrecursion.hoplon.pre.call(null,G__129040,G__129041,G__129042,G__129043,G__129044,G__129045,G__129046,G__129047,G__129048,G__129049,G__129050,G__129051,G__129052,G__129053,G__129054,G__129055,G__129056,G__129057,G__129058,G__129059,G__129060,G__129061,G__129062,G__129063,G__129064));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2(G__129038,G__129039) : tailrecursion.hoplon.div.call(null,G__129038,G__129039));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1(G__129037) : tailrecursion.hoplon.div.call(null,G__129037));
})(),(function (){var G__129091 = cljs.core.PersistentArrayMap.EMPTY;
var G__129092 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["But suppose we are not concerned only with numbers. Suppose we would like to express, in procedural terms, the idea that one can form linear combinations whenever addition and multiplication are defined ",(function (){var G__129093 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$endash], null);
var G__129094 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__129093,G__129094) : tailrecursion.hoplon.markdown.simple_node.call(null,G__129093,G__129094));
})()," for rational numbers, complex numbers, polynomials, or whatever. We could express this as a procedure of the form"], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__129091,G__129092) : tailrecursion.hoplon.markdown.para_node.call(null,G__129091,G__129092));
})(),(function (){var G__129095 = (function (){var G__129096 = new cljs.core.PersistentArrayMap(null, 2, [cljs.core.constant$keyword$class,"highlight",cljs.core.constant$keyword$style,"background: #f8f8f8"], null);
var G__129097 = (function (){var G__129098 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"line-height: 125%"], null);
var G__129099 = "(";
var G__129100 = (function (){var G__129125 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #008000; font-weight: bold"], null);
var G__129126 = "defn ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129125,G__129126) : tailrecursion.hoplon.span.call(null,G__129125,G__129126));
})();
var G__129101 = (function (){var G__129127 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129128 = "linear-combination";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129127,G__129128) : tailrecursion.hoplon.span.call(null,G__129127,G__129128));
})();
var G__129102 = " [";
var G__129103 = (function (){var G__129129 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129130 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129129,G__129130) : tailrecursion.hoplon.span.call(null,G__129129,G__129130));
})();
var G__129104 = " ";
var G__129105 = (function (){var G__129131 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129132 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129131,G__129132) : tailrecursion.hoplon.span.call(null,G__129131,G__129132));
})();
var G__129106 = " ";
var G__129107 = (function (){var G__129133 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129134 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129133,G__129134) : tailrecursion.hoplon.span.call(null,G__129133,G__129134));
})();
var G__129108 = " ";
var G__129109 = (function (){var G__129135 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129136 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129135,G__129136) : tailrecursion.hoplon.span.call(null,G__129135,G__129136));
})();
var G__129110 = "]\n  (";
var G__129111 = (function (){var G__129137 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #0000FF"], null);
var G__129138 = "add";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129137,G__129138) : tailrecursion.hoplon.span.call(null,G__129137,G__129138));
})();
var G__129112 = " (";
var G__129113 = (function (){var G__129139 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #0000FF"], null);
var G__129140 = "mul";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129139,G__129140) : tailrecursion.hoplon.span.call(null,G__129139,G__129140));
})();
var G__129114 = " ";
var G__129115 = (function (){var G__129141 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129142 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129141,G__129142) : tailrecursion.hoplon.span.call(null,G__129141,G__129142));
})();
var G__129116 = " ";
var G__129117 = (function (){var G__129143 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129144 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129143,G__129144) : tailrecursion.hoplon.span.call(null,G__129143,G__129144));
})();
var G__129118 = ") (";
var G__129119 = (function (){var G__129145 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #0000FF"], null);
var G__129146 = "mul";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129145,G__129146) : tailrecursion.hoplon.span.call(null,G__129145,G__129146));
})();
var G__129120 = " ";
var G__129121 = (function (){var G__129147 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129148 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129147,G__129148) : tailrecursion.hoplon.span.call(null,G__129147,G__129148));
})();
var G__129122 = " ";
var G__129123 = (function (){var G__129149 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$style,"color: #19177C"], null);
var G__129150 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__129149,G__129150) : tailrecursion.hoplon.span.call(null,G__129149,G__129150));
})();
var G__129124 = ")))\n";
return (tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$27 ? tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$27(G__129098,G__129099,G__129100,G__129101,G__129102,G__129103,G__129104,G__129105,G__129106,G__129107,G__129108,G__129109,G__129110,G__129111,G__129112,G__129113,G__129114,G__129115,G__129116,G__129117,G__129118,G__129119,G__129120,G__129121,G__129122,G__129123,G__129124) : tailrecursion.hoplon.pre.call(null,G__129098,G__129099,G__129100,G__129101,G__129102,G__129103,G__129104,G__129105,G__129106,G__129107,G__129108,G__129109,G__129110,G__129111,G__129112,G__129113,G__129114,G__129115,G__129116,G__129117,G__129118,G__129119,G__129120,G__129121,G__129122,G__129123,G__129124));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2(G__129096,G__129097) : tailrecursion.hoplon.div.call(null,G__129096,G__129097));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1(G__129095) : tailrecursion.hoplon.div.call(null,G__129095));
})(),(function (){var G__129151 = cljs.core.PersistentArrayMap.EMPTY;
var G__129152 = cljs.core.PersistentVector.fromArray(["where ",(function (){var G__129153 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"add"], null);
var G__129154 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129153,G__129154) : tailrecursion.hoplon.markdown.code_node.call(null,G__129153,G__129154));
})()," and ",(function (){var G__129155 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"mul"], null);
var G__129156 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129155,G__129156) : tailrecursion.hoplon.markdown.code_node.call(null,G__129155,G__129156));
})()," are not the primitive procedures + and * but rather more complex things that will perform the appropriate operations for whatever kinds of data we pass in as the arguments ",(function (){var G__129157 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"a"], null);
var G__129158 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129157,G__129158) : tailrecursion.hoplon.markdown.code_node.call(null,G__129157,G__129158));
})(),", ",(function (){var G__129159 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"b"], null);
var G__129160 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129159,G__129160) : tailrecursion.hoplon.markdown.code_node.call(null,G__129159,G__129160));
})(),", ",(function (){var G__129161 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"x"], null);
var G__129162 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129161,G__129162) : tailrecursion.hoplon.markdown.code_node.call(null,G__129161,G__129162));
})(),", and ",(function (){var G__129163 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"y"], null);
var G__129164 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129163,G__129164) : tailrecursion.hoplon.markdown.code_node.call(null,G__129163,G__129164));
})(),". The key point is that the only thing ",(function (){var G__129165 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"linear-combination"], null);
var G__129166 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129165,G__129166) : tailrecursion.hoplon.markdown.code_node.call(null,G__129165,G__129166));
})()," should need to know about ",(function (){var G__129167 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"a"], null);
var G__129168 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129167,G__129168) : tailrecursion.hoplon.markdown.code_node.call(null,G__129167,G__129168));
})(),", ",(function (){var G__129169 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"b"], null);
var G__129170 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129169,G__129170) : tailrecursion.hoplon.markdown.code_node.call(null,G__129169,G__129170));
})(),", ",(function (){var G__129171 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"x"], null);
var G__129172 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129171,G__129172) : tailrecursion.hoplon.markdown.code_node.call(null,G__129171,G__129172));
})(),", and ",(function (){var G__129173 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"y"], null);
var G__129174 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129173,G__129174) : tailrecursion.hoplon.markdown.code_node.call(null,G__129173,G__129174));
})()," is that the procedures ",(function (){var G__129175 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"add"], null);
var G__129176 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129175,G__129176) : tailrecursion.hoplon.markdown.code_node.call(null,G__129175,G__129176));
})()," and ",(function (){var G__129177 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"mul"], null);
var G__129178 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129177,G__129178) : tailrecursion.hoplon.markdown.code_node.call(null,G__129177,G__129178));
})()," will perform the appropriate manipulations. From the perspective of the procedure ",(function (){var G__129179 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"linear-combination"], null);
var G__129180 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129179,G__129180) : tailrecursion.hoplon.markdown.code_node.call(null,G__129179,G__129180));
})(),", it is irrelevant what ",(function (){var G__129181 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"a"], null);
var G__129182 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129181,G__129182) : tailrecursion.hoplon.markdown.code_node.call(null,G__129181,G__129182));
})(),", ",(function (){var G__129183 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"b"], null);
var G__129184 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129183,G__129184) : tailrecursion.hoplon.markdown.code_node.call(null,G__129183,G__129184));
})(),", ",(function (){var G__129185 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"x"], null);
var G__129186 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129185,G__129186) : tailrecursion.hoplon.markdown.code_node.call(null,G__129185,G__129186));
})(),", and ",(function (){var G__129187 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"y"], null);
var G__129188 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129187,G__129188) : tailrecursion.hoplon.markdown.code_node.call(null,G__129187,G__129188));
})()," are and even more irrelevant how they might happen to be represented in terms of more primitive data. This same example shows why it is important that our programming language provide the ability to manipulate compound objects directly: Without this, there is no way for a procedure such as ",(function (){var G__129189 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"linear-combination"], null);
var G__129190 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129189,G__129190) : tailrecursion.hoplon.markdown.code_node.call(null,G__129189,G__129190));
})()," to pass its arguments along to ",(function (){var G__129191 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"add"], null);
var G__129192 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129191,G__129192) : tailrecursion.hoplon.markdown.code_node.call(null,G__129191,G__129192));
})()," and ",(function (){var G__129193 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"mul"], null);
var G__129194 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129193,G__129194) : tailrecursion.hoplon.markdown.code_node.call(null,G__129193,G__129194));
})()," without having to know their detailed structure.",(function (){var G__129195 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double_DASH_angle], null);
var G__129196 = new cljs.core.PersistentVector(null, 15, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The ability to directly manipulate procedures provides an analogous increase in the expressive power of a programming language. For example, in ",tailrecursion.hoplon.markdown.exp_link_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 2, [cljs.core.constant$keyword$url,"#!/sicp/ch/1/sect/3/sub/1/",cljs.core.constant$keyword$title,""], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["section 1.3.1"], null)], 0))," we introduced the ",(function (){var G__129197 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"sum"], null);
var G__129198 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129197,G__129198) : tailrecursion.hoplon.markdown.code_node.call(null,G__129197,G__129198));
})()," procedure, which takes a procedure ",(function (){var G__129199 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"term"], null);
var G__129200 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129199,G__129200) : tailrecursion.hoplon.markdown.code_node.call(null,G__129199,G__129200));
})()," as an argument and computes the sum of the values of ",(function (){var G__129201 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"term"], null);
var G__129202 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129201,G__129202) : tailrecursion.hoplon.markdown.code_node.call(null,G__129201,G__129202));
})()," over some specified interval. In order to define ",(function (){var G__129203 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"sum"], null);
var G__129204 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129203,G__129204) : tailrecursion.hoplon.markdown.code_node.call(null,G__129203,G__129204));
})(),", it is crucial that we be able to speak of a procedure such as term as an entity in its own right, without regard for how term might be expressed with more primitive operations. Indeed, if we did not have the notion of ",(function (){var G__129205 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double], null);
var G__129206 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["a procedure,"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__129205,G__129206) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__129205,G__129206));
})()," it is doubtful that we would ever even think of the possibility of defining an operation such as ",(function (){var G__129207 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$text,"sum"], null);
var G__129208 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__129207,G__129208) : tailrecursion.hoplon.markdown.code_node.call(null,G__129207,G__129208));
})(),". Moreover, insofar as performing the summation is concerned, the details of how term may be constructed from more primitive operations are irrelevant."], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__129195,G__129196) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__129195,G__129196));
})()," We begin this chapter by implementing the rational-number arithmetic system mentioned above. This will form the background for our discussion of compound data and data abstraction. As with compound procedures, the main issue to be addressed is that of abstraction as a technique for coping with complexity, and we will see how data abstraction enables us to erect suitable ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["abstraction barriers"], null)], 0))," between different parts of a program."], true);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__129151,G__129152) : tailrecursion.hoplon.markdown.para_node.call(null,G__129151,G__129152));
})(),(function (){var G__129209 = cljs.core.PersistentArrayMap.EMPTY;
var G__129210 = new cljs.core.PersistentVector(null, 15, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We will see that the key to forming compound data is that a programming language should provide some kind of ",(function (){var G__129211 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double], null);
var G__129212 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["glue"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__129211,G__129212) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__129211,G__129212));
})()," so that data objects can be combined to form more complex data objects. There are many possible kinds of glue. Indeed, we will discover how to form compound data using no special ",(function (){var G__129213 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double], null);
var G__129214 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__129213,G__129214) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__129213,G__129214));
})()," operations at all, only procedures. This will further blur the distinction between ",(function (){var G__129215 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double], null);
var G__129216 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["procedure"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__129215,G__129216) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__129215,G__129216));
})()," and ",(function (){var G__129217 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$double], null);
var G__129218 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data,"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__129217,G__129218) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__129217,G__129218));
})()," which was already becoming tenuous toward the end of chapter 1. We will also explore some conventional techniques for representing sequences and trees. One key idea in dealing with compound data is the notion of ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["closure"], null)], 0))," ",(function (){var G__129219 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$endash], null);
var G__129220 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__129219,G__129220) : tailrecursion.hoplon.markdown.simple_node.call(null,G__129219,G__129220));
})()," that the glue we use for combining data objects should allow us to combine not only primitive data objects, but compound data objects as well. Another key idea is that compound data objects can serve as ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["conventional interfaces"], null)], 0))," for combining program modules in mix-and-match ways. We illustrate some of these ideas by presenting a simple graphics language that exploits closure."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__129209,G__129210) : tailrecursion.hoplon.markdown.para_node.call(null,G__129209,G__129210));
})(),(function (){var G__129221 = cljs.core.PersistentArrayMap.EMPTY;
var G__129222 = new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We will then augment the representational power of our language by introducing ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["symbolic expressions"], null)], 0))," ",(function (){var G__129223 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.constant$keyword$type,cljs.core.constant$keyword$endash], null);
var G__129224 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__129223,G__129224) : tailrecursion.hoplon.markdown.simple_node.call(null,G__129223,G__129224));
})()," data whose elementary parts can be arbitrary symbols rather than only numbers. We explore various alternatives for representing sets of objects. We will find that, just as a given numerical function can be computed by many different computational processes, there are many ways in which a given data structure can be represented in terms of simpler objects, and the choice of representation can have significant impact on the time and space requirements of processes that manipulate the data. We will investigate these ideas in the context of symbolic differentiation, the representation of sets, and the encoding of information."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__129221,G__129222) : tailrecursion.hoplon.markdown.para_node.call(null,G__129221,G__129222));
})(),(function (){var G__129225 = cljs.core.PersistentArrayMap.EMPTY;
var G__129226 = new cljs.core.PersistentVector(null, 7, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Next we will take up the problem of working with data that may be represented differently by different parts of a program. This leads to the need to implement generic operations, which must handle many different types of data. Maintaining modularity in the presence of ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["generic operations"], null)], 0))," requires more powerful abstraction barriers than can be erected with simple data abstraction alone. In particular, we introduce ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data-directed programming"], null)], 0))," as a technique that allows individual data representations to be designed in isolation and then combined ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.constant$keyword$chars,"*",cljs.core.constant$keyword$closed,true,cljs.core.constant$keyword$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["additively"], null)], 0))," (i.e., without modification). To illustrate the power of this approach to system design, we close the chapter by applying what we have learned to the implementation of a package for performing symbolic arithmetic on polynomials, in which the coefficients of the polynomials can be integers, rational numbers, complex numbers, and even other polynomials."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__129225,G__129226) : tailrecursion.hoplon.markdown.para_node.call(null,G__129225,G__129226));
})()], null);
}finally {tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = _STAR_abbreviations_STAR_129006;

tailrecursion.hoplon.markdown._STAR_references_STAR_ = _STAR_references_STAR_129005;
}}finally {tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = _STAR_abbreviations_STAR_129004;

tailrecursion.hoplon.markdown._STAR_references_STAR_ = _STAR_references_STAR_129003;
}})()], 0));
};
var content$sicp$texts$ch2$content = function (var_args){
var args__10403__auto__ = null;
if (arguments.length > 0) {
var G__129227__i = 0, G__129227__a = new Array(arguments.length -  0);
while (G__129227__i < G__129227__a.length) {G__129227__a[G__129227__i] = arguments[G__129227__i + 0]; ++G__129227__i;}
  args__10403__auto__ = new cljs.core.IndexedSeq(G__129227__a,0);
} 
return content$sicp$texts$ch2$content__delegate.call(this,args__10403__auto__);};
content$sicp$texts$ch2$content.cljs$lang$maxFixedArity = 0;
content$sicp$texts$ch2$content.cljs$lang$applyTo = (function (arglist__129228){
var args__10403__auto__ = cljs.core.seq(arglist__129228);
return content$sicp$texts$ch2$content__delegate(args__10403__auto__);
});
content$sicp$texts$ch2$content.cljs$core$IFn$_invoke$arity$variadic = content$sicp$texts$ch2$content__delegate;
return content$sicp$texts$ch2$content;
})()
;
