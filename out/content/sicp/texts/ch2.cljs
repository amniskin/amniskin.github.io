(ns content.sicp.texts.ch2 (:require [tailrecursion.hoplon.markdown :as md] [content.sicp.book-data :as data] [tailrecursion.hoplon :refer [form audio input hgroup do! timeout $text base h1 embed h3 body keygen on-append! progress main cite on-page-load object i p nav ruby check-val! a menu blockquote img $comment span track seq?* data u dl select html thead del eventsource append-child fieldset aside figure figcaption sentinel q on! bdi video address caption parse-args dd rp hr tbody table acronym frame applet html-var add-initfn! pre ul dir html-time add-attributes! html-map sup dfn sub mark script big button wbr strong li dt frameset td tr section th optgroup iframe legend em kbd spliced article isindex abbr command <!-- source output basefont route-cell header datalist tfoot s ins footer title is-ie8 h5 canvas param font div option summary samp center small style textarea loop-tpl* strike h4 tt head add-children! ol details col vector?* label rt when-dom h6 link page-load colgroup meter html-meta text-val! bdo --> b code node? noframes replace-children! noscript safe-nth h2 area br]] [tailrecursion.javelin :refer [input? cell cell? destroy-cell! ^{:private true} last-rank ^{:deprecated true} lift lens? set-formula! cell-doseq* ^{:dynamic true, :private true} *tx* deref* set-cell! lens formula? alts! dosync* cell-map formula]]) (:require-macros [tailrecursion.hoplon.markdown :refer [md]] [tailrecursion.hoplon :refer [text with-timeout sexp defelem def-values with-page-load with-dom loop-tpl with-interval with-init!]] [tailrecursion.javelin :refer [with-let mx2 dosync cell= set-cell!= prop-cell cell-doseq defc cell-let-1 defc= macroexpand-all mx cell-let]]))

(sexp {} "defelem content [attr kids]" (data/chapter {:title "Building Abstractions with Data"} (md {} "> We now come to the decisive step of mathematical abstraction: we forget\nabout what the symbols stand for. ...[The mathematician] need not be\nidle; there are many operations which he may carry out with these\nsymbols, without ever having to look at the things they stand for.\n\n> Hermann Weyl, *The Mathematical Way of Thinking*\n\nWe concentrated in chapter 1 on computational processes and on the role\nof procedures in program design. We saw how to use primitive data\n(numbers) and primitive operations (arithmetic operations), how to\ncombine procedures to form compound procedures through composition,\nconditionals, and the use of parameters, and how to abstract procedures\nby using defining forms. We saw that a procedure can be regarded as a\npattern for the local evolution of a process, and we classified, reasoned\nabout, and performed simple algorithmic analyses of some common patterns\nfor processes as embodied in procedures. We also saw that higher-order\nprocedures enhance the power of our language by enabling us to\nmanipulate, and thereby to reason in terms of, general methods of\ncomputation. This is much of the essence of programming.\n\nIn this chapter we are going to look at more complex data. All the\nprocedures in chapter 1 operate on simple numerical data, and simple data\nare not sufficient for many of the problems we wish to address using\ncomputation. Programs are typically designed to model complex phenomena,\nand more often than not one must construct computational objects that\nhave several parts in order to model real-world phenomena that have\nseveral aspects. Thus, whereas our focus in chapter 1 was on building\nabstractions by combining procedures to form compound procedures, we turn\nin this chapter to another key aspect of any programming language: the\nmeans it provides for building abstractions by combining data objects to\nform *compound data*.\n\nWhy do we want compound data in a programming language? For the same\nreasons that we want compound procedures: to elevate the conceptual level\nat which we can design our programs, to increase the modularity of our\ndesigns, and to enhance the expressive power of our language. Just as the\nability to define procedures enables us to deal with processes at a\nhigher conceptual level than that of the primitive operations of the\nlanguage, the ability to construct compound data objects enables us to\ndeal with data at a higher conceptual level than that of the primitive\ndata objects of the language.\n\nConsider the task of designing a system to perform arithmetic with\nrational numbers. We could imagine an operation `add-rat` that takes two\nrational numbers and produces their sum. In terms of simple data, a\nrational number can be thought of as two integers: a numerator and a\ndenominator. Thus, we could design a program in which each rational\nnumber would be represented by two integers (a numerator and a\ndenominator) and where add-rat would be implemented by two procedures\n(one producing the numerator of the sum and one producing the\ndenominator). But this would be awkward, because we would then need to\nexplicitly keep track of which numerators corresponded to which\ndenominators. In a system intended to perform many operations on many\nrational numbers, such bookkeeping details would clutter the programs\nsubstantially, to say nothing of what they would do to our minds. It\nwould be much better if we could \"glue together\" a numerator and\ndenominator to form a pair -- a *compound data object* -- that our programs\ncould manipulate in a way that would be consistent with regarding a\nrational number as a single conceptual unit.\n\nThe use of compound data also enables us to increase the modularity of\nour programs. If we can manipulate rational numbers directly as objects\nin their own right, then we can separate the part of our program that\ndeals with rational numbers per se from the details of how rational\nnumbers may be represented as pairs of integers. The general technique of\nisolating the parts of a program that deal with how data objects are\nrepresented from the parts of a program that deal with how data objects\nare used is a powerful design methodology called *data abstraction*. We\nwill see how data abstraction makes programs much easier to design,\nmaintain, and modify.\n\nThe use of compound data leads to a real increase in the expressive power\nof our programming language. Consider the idea of forming a \"linear\ncombination\" \\\\(ax + by\\\\). We might like to write a procedure that would\naccept \\\\(a\\\\), \\\\(b\\\\), \\\\(x\\\\), and \\\\(y\\\\) as arguments and return the\nvalue of \\\\(ax + by\\\\). This presents no difficulty if the arguments are\nto be numbers, because we can readily define the procedure\n\n```clj\n(defn linear-combination [a b x y]\n  (+ (* a x) (* b y)))\n```\n\nBut suppose we are not concerned only with numbers. Suppose we would like\nto express, in procedural terms, the idea that one can form linear\ncombinations whenever addition and multiplication are defined -- for\nrational numbers, complex numbers, polynomials, or whatever. We could\nexpress this as a procedure of the form\n\n```clj\n(defn linear-combination [a b x y]\n  (add (mul a x) (mul b y)))\n```\n\nwhere `add` and `mul` are not the primitive procedures + and * but rather\nmore complex things that will perform the appropriate operations for\nwhatever kinds of data we pass in as the arguments `a`, `b`, `x`, and\n`y`. The key point is that the only thing `linear-combination` should\nneed to know about `a`, `b`, `x`, and `y` is that the procedures `add`\nand `mul` will perform the appropriate manipulations. From the\nperspective of the procedure `linear-combination`, it is irrelevant what\n`a`, `b`, `x`, and `y` are and even more irrelevant how they might happen\nto be represented in terms of more primitive data. This same example\nshows why it is important that our programming language provide the\nability to manipulate compound objects directly: Without this, there is\nno way for a procedure such as `linear-combination` to pass its arguments\nalong to `add` and `mul` without having to know their detailed\nstructure.<<The ability to directly manipulate procedures provides an\nanalogous increase in the expressive power of a programming language. For\nexample, in [section 1.3.1](#!/sicp/ch/1/sect/3/sub/1/) we introduced the\n`sum` procedure, which takes a procedure `term` as an argument and\ncomputes the sum of the values of `term` over some specified interval. In\norder to define `sum`, it is crucial that we be able to speak of a\nprocedure such as term as an entity in its own right, without regard for\nhow term might be expressed with more primitive operations. Indeed, if we\ndid not have the notion of \"a procedure,\" it is doubtful that we would\never even think of the possibility of defining an operation such as\n`sum`. Moreover, insofar as performing the summation is concerned, the\ndetails of how term may be constructed from more primitive operations are\nirrelevant.>> We begin this chapter by implementing the rational-number\narithmetic system mentioned above. This will form the background for our\ndiscussion of compound data and data abstraction. As with compound\nprocedures, the main issue to be addressed is that of abstraction as a\ntechnique for coping with complexity, and we will see how data\nabstraction enables us to erect suitable *abstraction barriers* between\ndifferent parts of a program.\n\nWe will see that the key to forming compound data is that a programming\nlanguage should provide some kind of \"glue\" so that data objects can be\ncombined to form more complex data objects. There are many possible kinds\nof glue. Indeed, we will discover how to form compound data using no\nspecial \"data\" operations at all, only procedures. This will further blur\nthe distinction between \"procedure\" and \"data,\" which was already\nbecoming tenuous toward the end of chapter 1. We will also explore some\nconventional techniques for representing sequences and trees. One key\nidea in dealing with compound data is the notion of *closure* -- that the\nglue we use for combining data objects should allow us to combine not\nonly primitive data objects, but compound data objects as well. Another\nkey idea is that compound data objects can serve as *conventional\ninterfaces* for combining program modules in mix-and-match ways. We\nillustrate some of these ideas by presenting a simple graphics language\nthat exploits closure.\n\nWe will then augment the representational power of our language by\nintroducing *symbolic expressions* -- data whose elementary parts can be\narbitrary symbols rather than only numbers. We explore various\nalternatives for representing sets of objects. We will find that, just as\na given numerical function can be computed by many different\ncomputational processes, there are many ways in which a given data\nstructure can be represented in terms of simpler objects, and the choice\nof representation can have significant impact on the time and space\nrequirements of processes that manipulate the data. We will investigate\nthese ideas in the context of symbolic differentiation, the\nrepresentation of sets, and the encoding of information.\n\nNext we will take up the problem of working with data that may be\nrepresented differently by different parts of a program. This leads to\nthe need to implement generic operations, which must handle many\ndifferent types of data. Maintaining modularity in the presence of\n*generic operations* requires more powerful abstraction barriers than can\nbe erected with simple data abstraction alone. In particular, we\nintroduce *data-directed programming* as a technique that allows\nindividual data representations to be designed in isolation and then\ncombined *additively* (i.e., without modification). To illustrate the\npower of this approach to system design, we close the chapter by applying\nwhat we have learned to the implementation of a package for performing\nsymbolic arithmetic on polynomials, in which the coefficients of the\npolynomials can be integers, rational numbers, complex numbers, and even\nother polynomials.")))
