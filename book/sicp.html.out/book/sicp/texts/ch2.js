// Compiled by ClojureScript 1.7.48 {:static-fns true, :optimize-constants true}
goog.provide('book.sicp.texts.ch2');
goog.require('cljs.core');
goog.require('tailrecursion.hoplon.markdown');
goog.require('book.sicp.book_data');
goog.require('tailrecursion.hoplon');
goog.require('tailrecursion.javelin');
/**
 * @param {...*} var_args
 */
book.sicp.texts.ch2.content = (function() { 
var book$sicp$texts$ch2$content__delegate = function (args__8262__auto__){
var vec__252891 = tailrecursion.hoplon.parse_args(args__8262__auto__);
var attr = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__252891,(0),null);
var kids = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__252891,(1),null);
return book.sicp.book_data.chapter.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$title,"Building Abstractions with Data"], null),(function (){var _STAR_references_STAR_252892 = tailrecursion.hoplon.markdown._STAR_references_STAR_;
var _STAR_abbreviations_STAR_252893 = tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_;
tailrecursion.hoplon.markdown._STAR_references_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_references_STAR_,null], 0));

tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_,null], 0));

try{var _STAR_references_STAR_252894 = tailrecursion.hoplon.markdown._STAR_references_STAR_;
var _STAR_abbreviations_STAR_252895 = tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_;
tailrecursion.hoplon.markdown._STAR_references_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_references_STAR_,cljs.core.PersistentArrayMap.EMPTY], 0));

tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_,cljs.core.List.EMPTY], 0));

try{return new cljs.core.PersistentVector(null, 14, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){var G__252896 = cljs.core.PersistentArrayMap.EMPTY;
var G__252897 = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){var G__252898 = cljs.core.PersistentArrayMap.EMPTY;
var G__252899 = new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We now come to the decisive step of mathematical abstraction: we forget about what the symbols stand for. ",(function (){var G__252900 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$ellipsis], null);
var G__252901 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__252900,G__252901) : tailrecursion.hoplon.markdown.simple_node.call(null,G__252900,G__252901));
})(),tailrecursion.hoplon.markdown.ref_link_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$separator_DASH_space,null,cljs.core.cst$kw$reference_DASH_key,null], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The mathematician"], null)], 0))," need not be idle; there are many operations which he may carry out with these symbols, without ever having to look at the things they stand for."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__252898,G__252899) : tailrecursion.hoplon.markdown.para_node.call(null,G__252898,G__252899));
})(),(function (){var G__252902 = cljs.core.PersistentArrayMap.EMPTY;
var G__252903 = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Hermann Weyl, ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The Mathematical Way of Thinking"], null)], 0))], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__252902,G__252903) : tailrecursion.hoplon.markdown.para_node.call(null,G__252902,G__252903));
})()], null);
return (tailrecursion.hoplon.markdown.block_quote_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.block_quote_node.cljs$core$IFn$_invoke$arity$2(G__252896,G__252897) : tailrecursion.hoplon.markdown.block_quote_node.call(null,G__252896,G__252897));
})(),(function (){var G__252904 = cljs.core.PersistentArrayMap.EMPTY;
var G__252905 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We concentrated in chapter 1 on computational processes and on the role of procedures in program design. We saw how to use primitive data (numbers) and primitive operations (arithmetic operations), how to combine procedures to form compound procedures through composition, conditionals, and the use of parameters, and how to abstract procedures by using defining forms. We saw that a procedure can be regarded as a pattern for the local evolution of a process, and we classified, reasoned about, and performed simple algorithmic analyses of some common patterns for processes as embodied in procedures. We also saw that higher-order procedures enhance the power of our language by enabling us to manipulate, and thereby to reason in terms of, general methods of computation. This is much of the essence of programming."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__252904,G__252905) : tailrecursion.hoplon.markdown.para_node.call(null,G__252904,G__252905));
})(),(function (){var G__252906 = cljs.core.PersistentArrayMap.EMPTY;
var G__252907 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["In this chapter we are going to look at more complex data. All the procedures in chapter 1 operate on simple numerical data, and simple data are not sufficient for many of the problems we wish to address using computation. Programs are typically designed to model complex phenomena, and more often than not one must construct computational objects that have several parts in order to model real-world phenomena that have several aspects. Thus, whereas our focus in chapter 1 was on building abstractions by combining procedures to form compound procedures, we turn in this chapter to another key aspect of any programming language: the means it provides for building abstractions by combining data objects to form ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["compound data"], null)], 0)),"."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__252906,G__252907) : tailrecursion.hoplon.markdown.para_node.call(null,G__252906,G__252907));
})(),(function (){var G__252908 = cljs.core.PersistentArrayMap.EMPTY;
var G__252909 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Why do we want compound data in a programming language? For the same reasons that we want compound procedures: to elevate the conceptual level at which we can design our programs, to increase the modularity of our designs, and to enhance the expressive power of our language. Just as the ability to define procedures enables us to deal with processes at a higher conceptual level than that of the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__252908,G__252909) : tailrecursion.hoplon.markdown.para_node.call(null,G__252908,G__252909));
})(),(function (){var G__252910 = cljs.core.PersistentArrayMap.EMPTY;
var G__252911 = new cljs.core.PersistentVector(null, 11, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Consider the task of designing a system to perform arithmetic with rational numbers. We could imagine an operation ",(function (){var G__252912 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"add-rat"], null);
var G__252913 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__252912,G__252913) : tailrecursion.hoplon.markdown.code_node.call(null,G__252912,G__252913));
})()," that takes two rational numbers and produces their sum. In terms of simple data, a rational number can be thought of as two integers: a numerator and a denominator. Thus, we could design a program in which each rational number would be represented by two integers (a numerator and a denominator) and where add-rat would be implemented by two procedures (one producing the numerator of the sum and one producing the denominator). But this would be awkward, because we would then need to explicitly keep track of which numerators corresponded to which denominators. In a system intended to perform many operations on many rational numbers, such bookkeeping details would clutter the programs substantially, to say nothing of what they would do to our minds. It would be much better if we could ",(function (){var G__252914 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double], null);
var G__252915 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["glue together"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__252914,G__252915) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__252914,G__252915));
})()," a numerator and denominator to form a pair ",(function (){var G__252916 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$endash], null);
var G__252917 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__252916,G__252917) : tailrecursion.hoplon.markdown.simple_node.call(null,G__252916,G__252917));
})()," a ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["compound data object"], null)], 0))," ",(function (){var G__252918 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$endash], null);
var G__252919 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__252918,G__252919) : tailrecursion.hoplon.markdown.simple_node.call(null,G__252918,G__252919));
})()," that our programs could manipulate in a way that would be consistent with regarding a rational number as a single conceptual unit."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__252910,G__252911) : tailrecursion.hoplon.markdown.para_node.call(null,G__252910,G__252911));
})(),(function (){var G__252920 = cljs.core.PersistentArrayMap.EMPTY;
var G__252921 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The use of compound data also enables us to increase the modularity of our programs. If we can manipulate rational numbers directly as objects in their own right, then we can separate the part of our program that deals with rational numbers per se from the details of how rational numbers may be represented as pairs of integers. The general technique of isolating the parts of a program that deal with how data objects are represented from the parts of a program that deal with how data objects are used is a powerful design methodology called ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data abstraction"], null)], 0)),". We will see how data abstraction makes programs much easier to design, maintain, and modify."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__252920,G__252921) : tailrecursion.hoplon.markdown.para_node.call(null,G__252920,G__252921));
})(),(function (){var G__252922 = cljs.core.PersistentArrayMap.EMPTY;
var G__252923 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The use of compound data leads to a real increase in the expressive power of our programming language. Consider the idea of forming a ",(function (){var G__252924 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double], null);
var G__252925 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["linear combination"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__252924,G__252925) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__252924,G__252925));
})()," \\(ax + by\\). We might like to write a procedure that would accept \\(a\\), \\(b\\), \\(x\\), and \\(y\\) as arguments and return the value of \\(ax + by\\). This presents no difficulty if the arguments are to be numbers, because we can readily define the procedure"], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__252922,G__252923) : tailrecursion.hoplon.markdown.para_node.call(null,G__252922,G__252923));
})(),(function (){var G__252979 = (function (){var G__252980 = new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$class,"highlight",cljs.core.cst$kw$style,"background: #f8f8f8"], null);
var G__252981 = (function (){var G__252982 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"line-height: 125%"], null);
var G__252983 = "(";
var G__252984 = (function (){var G__253007 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #008000; font-weight: bold"], null);
var G__253008 = "defn ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253007,G__253008) : tailrecursion.hoplon.span.call(null,G__253007,G__253008));
})();
var G__252985 = (function (){var G__253009 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253010 = "linear-combination";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253009,G__253010) : tailrecursion.hoplon.span.call(null,G__253009,G__253010));
})();
var G__252986 = " [";
var G__252987 = (function (){var G__253011 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253012 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253011,G__253012) : tailrecursion.hoplon.span.call(null,G__253011,G__253012));
})();
var G__252988 = " ";
var G__252989 = (function (){var G__253013 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253014 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253013,G__253014) : tailrecursion.hoplon.span.call(null,G__253013,G__253014));
})();
var G__252990 = " ";
var G__252991 = (function (){var G__253015 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253016 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253015,G__253016) : tailrecursion.hoplon.span.call(null,G__253015,G__253016));
})();
var G__252992 = " ";
var G__252993 = (function (){var G__253017 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253018 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253017,G__253018) : tailrecursion.hoplon.span.call(null,G__253017,G__253018));
})();
var G__252994 = "]\n  (";
var G__252995 = (function (){var G__253019 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #008000"], null);
var G__253020 = "+ ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253019,G__253020) : tailrecursion.hoplon.span.call(null,G__253019,G__253020));
})();
var G__252996 = "(";
var G__252997 = (function (){var G__253021 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #008000"], null);
var G__253022 = "* ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253021,G__253022) : tailrecursion.hoplon.span.call(null,G__253021,G__253022));
})();
var G__252998 = (function (){var G__253023 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253024 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253023,G__253024) : tailrecursion.hoplon.span.call(null,G__253023,G__253024));
})();
var G__252999 = " ";
var G__253000 = (function (){var G__253025 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253026 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253025,G__253026) : tailrecursion.hoplon.span.call(null,G__253025,G__253026));
})();
var G__253001 = ") (";
var G__253002 = (function (){var G__253027 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #008000"], null);
var G__253028 = "* ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253027,G__253028) : tailrecursion.hoplon.span.call(null,G__253027,G__253028));
})();
var G__253003 = (function (){var G__253029 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253030 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253029,G__253030) : tailrecursion.hoplon.span.call(null,G__253029,G__253030));
})();
var G__253004 = " ";
var G__253005 = (function (){var G__253031 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253032 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253031,G__253032) : tailrecursion.hoplon.span.call(null,G__253031,G__253032));
})();
var G__253006 = ")))\n";
return (tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$25 ? tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$25(G__252982,G__252983,G__252984,G__252985,G__252986,G__252987,G__252988,G__252989,G__252990,G__252991,G__252992,G__252993,G__252994,G__252995,G__252996,G__252997,G__252998,G__252999,G__253000,G__253001,G__253002,G__253003,G__253004,G__253005,G__253006) : tailrecursion.hoplon.pre.call(null,G__252982,G__252983,G__252984,G__252985,G__252986,G__252987,G__252988,G__252989,G__252990,G__252991,G__252992,G__252993,G__252994,G__252995,G__252996,G__252997,G__252998,G__252999,G__253000,G__253001,G__253002,G__253003,G__253004,G__253005,G__253006));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2(G__252980,G__252981) : tailrecursion.hoplon.div.call(null,G__252980,G__252981));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1(G__252979) : tailrecursion.hoplon.div.call(null,G__252979));
})(),(function (){var G__253033 = cljs.core.PersistentArrayMap.EMPTY;
var G__253034 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["But suppose we are not concerned only with numbers. Suppose we would like to express, in procedural terms, the idea that one can form linear combinations whenever addition and multiplication are defined ",(function (){var G__253035 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$endash], null);
var G__253036 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__253035,G__253036) : tailrecursion.hoplon.markdown.simple_node.call(null,G__253035,G__253036));
})()," for rational numbers, complex numbers, polynomials, or whatever. We could express this as a procedure of the form"], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__253033,G__253034) : tailrecursion.hoplon.markdown.para_node.call(null,G__253033,G__253034));
})(),(function (){var G__253092 = (function (){var G__253093 = new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$class,"highlight",cljs.core.cst$kw$style,"background: #f8f8f8"], null);
var G__253094 = (function (){var G__253095 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"line-height: 125%"], null);
var G__253096 = "(";
var G__253097 = (function (){var G__253122 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #008000; font-weight: bold"], null);
var G__253123 = "defn ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253122,G__253123) : tailrecursion.hoplon.span.call(null,G__253122,G__253123));
})();
var G__253098 = (function (){var G__253124 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253125 = "linear-combination";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253124,G__253125) : tailrecursion.hoplon.span.call(null,G__253124,G__253125));
})();
var G__253099 = " [";
var G__253100 = (function (){var G__253126 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253127 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253126,G__253127) : tailrecursion.hoplon.span.call(null,G__253126,G__253127));
})();
var G__253101 = " ";
var G__253102 = (function (){var G__253128 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253129 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253128,G__253129) : tailrecursion.hoplon.span.call(null,G__253128,G__253129));
})();
var G__253103 = " ";
var G__253104 = (function (){var G__253130 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253131 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253130,G__253131) : tailrecursion.hoplon.span.call(null,G__253130,G__253131));
})();
var G__253105 = " ";
var G__253106 = (function (){var G__253132 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253133 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253132,G__253133) : tailrecursion.hoplon.span.call(null,G__253132,G__253133));
})();
var G__253107 = "]\n  (";
var G__253108 = (function (){var G__253134 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #0000FF"], null);
var G__253135 = "add";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253134,G__253135) : tailrecursion.hoplon.span.call(null,G__253134,G__253135));
})();
var G__253109 = " (";
var G__253110 = (function (){var G__253136 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #0000FF"], null);
var G__253137 = "mul";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253136,G__253137) : tailrecursion.hoplon.span.call(null,G__253136,G__253137));
})();
var G__253111 = " ";
var G__253112 = (function (){var G__253138 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253139 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253138,G__253139) : tailrecursion.hoplon.span.call(null,G__253138,G__253139));
})();
var G__253113 = " ";
var G__253114 = (function (){var G__253140 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253141 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253140,G__253141) : tailrecursion.hoplon.span.call(null,G__253140,G__253141));
})();
var G__253115 = ") (";
var G__253116 = (function (){var G__253142 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #0000FF"], null);
var G__253143 = "mul";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253142,G__253143) : tailrecursion.hoplon.span.call(null,G__253142,G__253143));
})();
var G__253117 = " ";
var G__253118 = (function (){var G__253144 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253145 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253144,G__253145) : tailrecursion.hoplon.span.call(null,G__253144,G__253145));
})();
var G__253119 = " ";
var G__253120 = (function (){var G__253146 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__253147 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__253146,G__253147) : tailrecursion.hoplon.span.call(null,G__253146,G__253147));
})();
var G__253121 = ")))\n";
return (tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$27 ? tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$27(G__253095,G__253096,G__253097,G__253098,G__253099,G__253100,G__253101,G__253102,G__253103,G__253104,G__253105,G__253106,G__253107,G__253108,G__253109,G__253110,G__253111,G__253112,G__253113,G__253114,G__253115,G__253116,G__253117,G__253118,G__253119,G__253120,G__253121) : tailrecursion.hoplon.pre.call(null,G__253095,G__253096,G__253097,G__253098,G__253099,G__253100,G__253101,G__253102,G__253103,G__253104,G__253105,G__253106,G__253107,G__253108,G__253109,G__253110,G__253111,G__253112,G__253113,G__253114,G__253115,G__253116,G__253117,G__253118,G__253119,G__253120,G__253121));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2(G__253093,G__253094) : tailrecursion.hoplon.div.call(null,G__253093,G__253094));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1(G__253092) : tailrecursion.hoplon.div.call(null,G__253092));
})(),(function (){var G__253148 = cljs.core.PersistentArrayMap.EMPTY;
var G__253149 = cljs.core.PersistentVector.fromArray(["where ",(function (){var G__253150 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"add"], null);
var G__253151 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253150,G__253151) : tailrecursion.hoplon.markdown.code_node.call(null,G__253150,G__253151));
})()," and ",(function (){var G__253152 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"mul"], null);
var G__253153 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253152,G__253153) : tailrecursion.hoplon.markdown.code_node.call(null,G__253152,G__253153));
})()," are not the primitive procedures + and * but rather more complex things that will perform the appropriate operations for whatever kinds of data we pass in as the arguments ",(function (){var G__253154 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"a"], null);
var G__253155 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253154,G__253155) : tailrecursion.hoplon.markdown.code_node.call(null,G__253154,G__253155));
})(),", ",(function (){var G__253156 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"b"], null);
var G__253157 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253156,G__253157) : tailrecursion.hoplon.markdown.code_node.call(null,G__253156,G__253157));
})(),", ",(function (){var G__253158 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"x"], null);
var G__253159 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253158,G__253159) : tailrecursion.hoplon.markdown.code_node.call(null,G__253158,G__253159));
})(),", and ",(function (){var G__253160 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"y"], null);
var G__253161 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253160,G__253161) : tailrecursion.hoplon.markdown.code_node.call(null,G__253160,G__253161));
})(),". The key point is that the only thing ",(function (){var G__253162 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"linear-combination"], null);
var G__253163 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253162,G__253163) : tailrecursion.hoplon.markdown.code_node.call(null,G__253162,G__253163));
})()," should need to know about ",(function (){var G__253164 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"a"], null);
var G__253165 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253164,G__253165) : tailrecursion.hoplon.markdown.code_node.call(null,G__253164,G__253165));
})(),", ",(function (){var G__253166 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"b"], null);
var G__253167 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253166,G__253167) : tailrecursion.hoplon.markdown.code_node.call(null,G__253166,G__253167));
})(),", ",(function (){var G__253168 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"x"], null);
var G__253169 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253168,G__253169) : tailrecursion.hoplon.markdown.code_node.call(null,G__253168,G__253169));
})(),", and ",(function (){var G__253170 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"y"], null);
var G__253171 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253170,G__253171) : tailrecursion.hoplon.markdown.code_node.call(null,G__253170,G__253171));
})()," is that the procedures ",(function (){var G__253172 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"add"], null);
var G__253173 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253172,G__253173) : tailrecursion.hoplon.markdown.code_node.call(null,G__253172,G__253173));
})()," and ",(function (){var G__253174 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"mul"], null);
var G__253175 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253174,G__253175) : tailrecursion.hoplon.markdown.code_node.call(null,G__253174,G__253175));
})()," will perform the appropriate manipulations. From the perspective of the procedure ",(function (){var G__253176 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"linear-combination"], null);
var G__253177 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253176,G__253177) : tailrecursion.hoplon.markdown.code_node.call(null,G__253176,G__253177));
})(),", it is irrelevant what ",(function (){var G__253178 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"a"], null);
var G__253179 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253178,G__253179) : tailrecursion.hoplon.markdown.code_node.call(null,G__253178,G__253179));
})(),", ",(function (){var G__253180 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"b"], null);
var G__253181 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253180,G__253181) : tailrecursion.hoplon.markdown.code_node.call(null,G__253180,G__253181));
})(),", ",(function (){var G__253182 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"x"], null);
var G__253183 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253182,G__253183) : tailrecursion.hoplon.markdown.code_node.call(null,G__253182,G__253183));
})(),", and ",(function (){var G__253184 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"y"], null);
var G__253185 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253184,G__253185) : tailrecursion.hoplon.markdown.code_node.call(null,G__253184,G__253185));
})()," are and even more irrelevant how they might happen to be represented in terms of more primitive data. This same example shows why it is important that our programming language provide the ability to manipulate compound objects directly: Without this, there is no way for a procedure such as ",(function (){var G__253186 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"linear-combination"], null);
var G__253187 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253186,G__253187) : tailrecursion.hoplon.markdown.code_node.call(null,G__253186,G__253187));
})()," to pass its arguments along to ",(function (){var G__253188 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"add"], null);
var G__253189 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253188,G__253189) : tailrecursion.hoplon.markdown.code_node.call(null,G__253188,G__253189));
})()," and ",(function (){var G__253190 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"mul"], null);
var G__253191 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253190,G__253191) : tailrecursion.hoplon.markdown.code_node.call(null,G__253190,G__253191));
})()," without having to know their detailed structure.",(function (){var G__253192 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double_DASH_angle], null);
var G__253193 = new cljs.core.PersistentVector(null, 15, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The ability to directly manipulate procedures provides an analogous increase in the expressive power of a programming language. For example, in ",tailrecursion.hoplon.markdown.exp_link_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$url,"#!/sicp/ch/1/sect/3/sub/1/",cljs.core.cst$kw$title,""], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["section 1.3.1"], null)], 0))," we introduced the ",(function (){var G__253194 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"sum"], null);
var G__253195 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253194,G__253195) : tailrecursion.hoplon.markdown.code_node.call(null,G__253194,G__253195));
})()," procedure, which takes a procedure ",(function (){var G__253196 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"term"], null);
var G__253197 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253196,G__253197) : tailrecursion.hoplon.markdown.code_node.call(null,G__253196,G__253197));
})()," as an argument and computes the sum of the values of ",(function (){var G__253198 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"term"], null);
var G__253199 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253198,G__253199) : tailrecursion.hoplon.markdown.code_node.call(null,G__253198,G__253199));
})()," over some specified interval. In order to define ",(function (){var G__253200 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"sum"], null);
var G__253201 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253200,G__253201) : tailrecursion.hoplon.markdown.code_node.call(null,G__253200,G__253201));
})(),", it is crucial that we be able to speak of a procedure such as term as an entity in its own right, without regard for how term might be expressed with more primitive operations. Indeed, if we did not have the notion of ",(function (){var G__253202 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double], null);
var G__253203 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["a procedure,"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__253202,G__253203) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__253202,G__253203));
})()," it is doubtful that we would ever even think of the possibility of defining an operation such as ",(function (){var G__253204 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"sum"], null);
var G__253205 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__253204,G__253205) : tailrecursion.hoplon.markdown.code_node.call(null,G__253204,G__253205));
})(),". Moreover, insofar as performing the summation is concerned, the details of how term may be constructed from more primitive operations are irrelevant."], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__253192,G__253193) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__253192,G__253193));
})()," We begin this chapter by implementing the rational-number arithmetic system mentioned above. This will form the background for our discussion of compound data and data abstraction. As with compound procedures, the main issue to be addressed is that of abstraction as a technique for coping with complexity, and we will see how data abstraction enables us to erect suitable ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["abstraction barriers"], null)], 0))," between different parts of a program."], true);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__253148,G__253149) : tailrecursion.hoplon.markdown.para_node.call(null,G__253148,G__253149));
})(),(function (){var G__253206 = cljs.core.PersistentArrayMap.EMPTY;
var G__253207 = new cljs.core.PersistentVector(null, 15, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We will see that the key to forming compound data is that a programming language should provide some kind of ",(function (){var G__253208 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double], null);
var G__253209 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["glue"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__253208,G__253209) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__253208,G__253209));
})()," so that data objects can be combined to form more complex data objects. There are many possible kinds of glue. Indeed, we will discover how to form compound data using no special ",(function (){var G__253210 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double], null);
var G__253211 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__253210,G__253211) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__253210,G__253211));
})()," operations at all, only procedures. This will further blur the distinction between ",(function (){var G__253212 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double], null);
var G__253213 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["procedure"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__253212,G__253213) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__253212,G__253213));
})()," and ",(function (){var G__253214 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double], null);
var G__253215 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data,"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__253214,G__253215) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__253214,G__253215));
})()," which was already becoming tenuous toward the end of chapter 1. We will also explore some conventional techniques for representing sequences and trees. One key idea in dealing with compound data is the notion of ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["closure"], null)], 0))," ",(function (){var G__253216 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$endash], null);
var G__253217 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__253216,G__253217) : tailrecursion.hoplon.markdown.simple_node.call(null,G__253216,G__253217));
})()," that the glue we use for combining data objects should allow us to combine not only primitive data objects, but compound data objects as well. Another key idea is that compound data objects can serve as ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["conventional interfaces"], null)], 0))," for combining program modules in mix-and-match ways. We illustrate some of these ideas by presenting a simple graphics language that exploits closure."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__253206,G__253207) : tailrecursion.hoplon.markdown.para_node.call(null,G__253206,G__253207));
})(),(function (){var G__253218 = cljs.core.PersistentArrayMap.EMPTY;
var G__253219 = new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We will then augment the representational power of our language by introducing ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["symbolic expressions"], null)], 0))," ",(function (){var G__253220 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$endash], null);
var G__253221 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__253220,G__253221) : tailrecursion.hoplon.markdown.simple_node.call(null,G__253220,G__253221));
})()," data whose elementary parts can be arbitrary symbols rather than only numbers. We explore various alternatives for representing sets of objects. We will find that, just as a given numerical function can be computed by many different computational processes, there are many ways in which a given data structure can be represented in terms of simpler objects, and the choice of representation can have significant impact on the time and space requirements of processes that manipulate the data. We will investigate these ideas in the context of symbolic differentiation, the representation of sets, and the encoding of information."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__253218,G__253219) : tailrecursion.hoplon.markdown.para_node.call(null,G__253218,G__253219));
})(),(function (){var G__253222 = cljs.core.PersistentArrayMap.EMPTY;
var G__253223 = new cljs.core.PersistentVector(null, 7, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Next we will take up the problem of working with data that may be represented differently by different parts of a program. This leads to the need to implement generic operations, which must handle many different types of data. Maintaining modularity in the presence of ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["generic operations"], null)], 0))," requires more powerful abstraction barriers than can be erected with simple data abstraction alone. In particular, we introduce ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data-directed programming"], null)], 0))," as a technique that allows individual data representations to be designed in isolation and then combined ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["additively"], null)], 0))," (i.e., without modification). To illustrate the power of this approach to system design, we close the chapter by applying what we have learned to the implementation of a package for performing symbolic arithmetic on polynomials, in which the coefficients of the polynomials can be integers, rational numbers, complex numbers, and even other polynomials."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__253222,G__253223) : tailrecursion.hoplon.markdown.para_node.call(null,G__253222,G__253223));
})()], null);
}finally {tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = _STAR_abbreviations_STAR_252895;

tailrecursion.hoplon.markdown._STAR_references_STAR_ = _STAR_references_STAR_252894;
}}finally {tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = _STAR_abbreviations_STAR_252893;

tailrecursion.hoplon.markdown._STAR_references_STAR_ = _STAR_references_STAR_252892;
}})()], 0));
};
var book$sicp$texts$ch2$content = function (var_args){
var args__8262__auto__ = null;
if (arguments.length > 0) {
var G__253224__i = 0, G__253224__a = new Array(arguments.length -  0);
while (G__253224__i < G__253224__a.length) {G__253224__a[G__253224__i] = arguments[G__253224__i + 0]; ++G__253224__i;}
  args__8262__auto__ = new cljs.core.IndexedSeq(G__253224__a,0);
} 
return book$sicp$texts$ch2$content__delegate.call(this,args__8262__auto__);};
book$sicp$texts$ch2$content.cljs$lang$maxFixedArity = 0;
book$sicp$texts$ch2$content.cljs$lang$applyTo = (function (arglist__253225){
var args__8262__auto__ = cljs.core.seq(arglist__253225);
return book$sicp$texts$ch2$content__delegate(args__8262__auto__);
});
book$sicp$texts$ch2$content.cljs$core$IFn$_invoke$arity$variadic = book$sicp$texts$ch2$content__delegate;
return book$sicp$texts$ch2$content;
})()
;
