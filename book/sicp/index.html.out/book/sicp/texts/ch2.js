// Compiled by ClojureScript 1.7.48 {:static-fns true, :optimize-constants true}
goog.provide('book.sicp.texts.ch2');
goog.require('cljs.core');
goog.require('tailrecursion.hoplon.markdown');
goog.require('book.sicp.book_data');
goog.require('tailrecursion.hoplon');
goog.require('tailrecursion.javelin');
/**
 * @param {...*} var_args
 */
book.sicp.texts.ch2.content = (function() { 
var book$sicp$texts$ch2$content__delegate = function (args__8262__auto__){
var vec__276219 = tailrecursion.hoplon.parse_args(args__8262__auto__);
var attr = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__276219,(0),null);
var kids = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__276219,(1),null);
return book.sicp.book_data.chapter.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$title,"Building Abstractions with Data"], null),(function (){var _STAR_references_STAR_276220 = tailrecursion.hoplon.markdown._STAR_references_STAR_;
var _STAR_abbreviations_STAR_276221 = tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_;
tailrecursion.hoplon.markdown._STAR_references_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_references_STAR_,null], 0));

tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_,null], 0));

try{var _STAR_references_STAR_276222 = tailrecursion.hoplon.markdown._STAR_references_STAR_;
var _STAR_abbreviations_STAR_276223 = tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_;
tailrecursion.hoplon.markdown._STAR_references_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_references_STAR_,cljs.core.PersistentArrayMap.EMPTY], 0));

tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_,cljs.core.List.EMPTY], 0));

try{return new cljs.core.PersistentVector(null, 14, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){var G__276224 = cljs.core.PersistentArrayMap.EMPTY;
var G__276225 = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){var G__276226 = cljs.core.PersistentArrayMap.EMPTY;
var G__276227 = new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We now come to the decisive step of mathematical abstraction: we forget about what the symbols stand for. ",(function (){var G__276228 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$ellipsis], null);
var G__276229 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276228,G__276229) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276228,G__276229));
})(),tailrecursion.hoplon.markdown.ref_link_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$separator_DASH_space,null,cljs.core.cst$kw$reference_DASH_key,null], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The mathematician"], null)], 0))," need not be idle; there are many operations which he may carry out with these symbols, without ever having to look at the things they stand for."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276226,G__276227) : tailrecursion.hoplon.markdown.para_node.call(null,G__276226,G__276227));
})(),(function (){var G__276230 = cljs.core.PersistentArrayMap.EMPTY;
var G__276231 = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Hermann Weyl, ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The Mathematical Way of Thinking"], null)], 0))], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276230,G__276231) : tailrecursion.hoplon.markdown.para_node.call(null,G__276230,G__276231));
})()], null);
return (tailrecursion.hoplon.markdown.block_quote_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.block_quote_node.cljs$core$IFn$_invoke$arity$2(G__276224,G__276225) : tailrecursion.hoplon.markdown.block_quote_node.call(null,G__276224,G__276225));
})(),(function (){var G__276232 = cljs.core.PersistentArrayMap.EMPTY;
var G__276233 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We concentrated in chapter 1 on computational processes and on the role of procedures in program design. We saw how to use primitive data (numbers) and primitive operations (arithmetic operations), how to combine procedures to form compound procedures through composition, conditionals, and the use of parameters, and how to abstract procedures by using defining forms. We saw that a procedure can be regarded as a pattern for the local evolution of a process, and we classified, reasoned about, and performed simple algorithmic analyses of some common patterns for processes as embodied in procedures. We also saw that higher-order procedures enhance the power of our language by enabling us to manipulate, and thereby to reason in terms of, general methods of computation. This is much of the essence of programming."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276232,G__276233) : tailrecursion.hoplon.markdown.para_node.call(null,G__276232,G__276233));
})(),(function (){var G__276234 = cljs.core.PersistentArrayMap.EMPTY;
var G__276235 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["In this chapter we are going to look at more complex data. All the procedures in chapter 1 operate on simple numerical data, and simple data are not sufficient for many of the problems we wish to address using computation. Programs are typically designed to model complex phenomena, and more often than not one must construct computational objects that have several parts in order to model real-world phenomena that have several aspects. Thus, whereas our focus in chapter 1 was on building abstractions by combining procedures to form compound procedures, we turn in this chapter to another key aspect of any programming language: the means it provides for building abstractions by combining data objects to form ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["compound data"], null)], 0)),"."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276234,G__276235) : tailrecursion.hoplon.markdown.para_node.call(null,G__276234,G__276235));
})(),(function (){var G__276236 = cljs.core.PersistentArrayMap.EMPTY;
var G__276237 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Why do we want compound data in a programming language? For the same reasons that we want compound procedures: to elevate the conceptual level at which we can design our programs, to increase the modularity of our designs, and to enhance the expressive power of our language. Just as the ability to define procedures enables us to deal with processes at a higher conceptual level than that of the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276236,G__276237) : tailrecursion.hoplon.markdown.para_node.call(null,G__276236,G__276237));
})(),(function (){var G__276238 = cljs.core.PersistentArrayMap.EMPTY;
var G__276239 = new cljs.core.PersistentVector(null, 11, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Consider the task of designing a system to perform arithmetic with rational numbers. We could imagine an operation ",(function (){var G__276240 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"add-rat"], null);
var G__276241 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276240,G__276241) : tailrecursion.hoplon.markdown.code_node.call(null,G__276240,G__276241));
})()," that takes two rational numbers and produces their sum. In terms of simple data, a rational number can be thought of as two integers: a numerator and a denominator. Thus, we could design a program in which each rational number would be represented by two integers (a numerator and a denominator) and where add-rat would be implemented by two procedures (one producing the numerator of the sum and one producing the denominator). But this would be awkward, because we would then need to explicitly keep track of which numerators corresponded to which denominators. In a system intended to perform many operations on many rational numbers, such bookkeeping details would clutter the programs substantially, to say nothing of what they would do to our minds. It would be much better if we could ",(function (){var G__276242 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double], null);
var G__276243 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["glue together"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__276242,G__276243) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__276242,G__276243));
})()," a numerator and denominator to form a pair ",(function (){var G__276244 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$endash], null);
var G__276245 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276244,G__276245) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276244,G__276245));
})()," a ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["compound data object"], null)], 0))," ",(function (){var G__276246 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$endash], null);
var G__276247 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276246,G__276247) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276246,G__276247));
})()," that our programs could manipulate in a way that would be consistent with regarding a rational number as a single conceptual unit."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276238,G__276239) : tailrecursion.hoplon.markdown.para_node.call(null,G__276238,G__276239));
})(),(function (){var G__276248 = cljs.core.PersistentArrayMap.EMPTY;
var G__276249 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The use of compound data also enables us to increase the modularity of our programs. If we can manipulate rational numbers directly as objects in their own right, then we can separate the part of our program that deals with rational numbers per se from the details of how rational numbers may be represented as pairs of integers. The general technique of isolating the parts of a program that deal with how data objects are represented from the parts of a program that deal with how data objects are used is a powerful design methodology called ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data abstraction"], null)], 0)),". We will see how data abstraction makes programs much easier to design, maintain, and modify."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276248,G__276249) : tailrecursion.hoplon.markdown.para_node.call(null,G__276248,G__276249));
})(),(function (){var G__276250 = cljs.core.PersistentArrayMap.EMPTY;
var G__276251 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The use of compound data leads to a real increase in the expressive power of our programming language. Consider the idea of forming a ",(function (){var G__276252 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double], null);
var G__276253 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["linear combination"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__276252,G__276253) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__276252,G__276253));
})()," \\(ax + by\\). We might like to write a procedure that would accept \\(a\\), \\(b\\), \\(x\\), and \\(y\\) as arguments and return the value of \\(ax + by\\). This presents no difficulty if the arguments are to be numbers, because we can readily define the procedure"], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276250,G__276251) : tailrecursion.hoplon.markdown.para_node.call(null,G__276250,G__276251));
})(),(function (){var G__276307 = (function (){var G__276308 = new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$class,"highlight",cljs.core.cst$kw$style,"background: #f8f8f8"], null);
var G__276309 = (function (){var G__276310 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"line-height: 125%"], null);
var G__276311 = "(";
var G__276312 = (function (){var G__276335 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #008000; font-weight: bold"], null);
var G__276336 = "defn ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276335,G__276336) : tailrecursion.hoplon.span.call(null,G__276335,G__276336));
})();
var G__276313 = (function (){var G__276337 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276338 = "linear-combination";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276337,G__276338) : tailrecursion.hoplon.span.call(null,G__276337,G__276338));
})();
var G__276314 = " [";
var G__276315 = (function (){var G__276339 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276340 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276339,G__276340) : tailrecursion.hoplon.span.call(null,G__276339,G__276340));
})();
var G__276316 = " ";
var G__276317 = (function (){var G__276341 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276342 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276341,G__276342) : tailrecursion.hoplon.span.call(null,G__276341,G__276342));
})();
var G__276318 = " ";
var G__276319 = (function (){var G__276343 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276344 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276343,G__276344) : tailrecursion.hoplon.span.call(null,G__276343,G__276344));
})();
var G__276320 = " ";
var G__276321 = (function (){var G__276345 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276346 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276345,G__276346) : tailrecursion.hoplon.span.call(null,G__276345,G__276346));
})();
var G__276322 = "]\n  (";
var G__276323 = (function (){var G__276347 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #008000"], null);
var G__276348 = "+ ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276347,G__276348) : tailrecursion.hoplon.span.call(null,G__276347,G__276348));
})();
var G__276324 = "(";
var G__276325 = (function (){var G__276349 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #008000"], null);
var G__276350 = "* ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276349,G__276350) : tailrecursion.hoplon.span.call(null,G__276349,G__276350));
})();
var G__276326 = (function (){var G__276351 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276352 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276351,G__276352) : tailrecursion.hoplon.span.call(null,G__276351,G__276352));
})();
var G__276327 = " ";
var G__276328 = (function (){var G__276353 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276354 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276353,G__276354) : tailrecursion.hoplon.span.call(null,G__276353,G__276354));
})();
var G__276329 = ") (";
var G__276330 = (function (){var G__276355 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #008000"], null);
var G__276356 = "* ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276355,G__276356) : tailrecursion.hoplon.span.call(null,G__276355,G__276356));
})();
var G__276331 = (function (){var G__276357 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276358 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276357,G__276358) : tailrecursion.hoplon.span.call(null,G__276357,G__276358));
})();
var G__276332 = " ";
var G__276333 = (function (){var G__276359 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276360 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276359,G__276360) : tailrecursion.hoplon.span.call(null,G__276359,G__276360));
})();
var G__276334 = ")))\n";
return (tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$25 ? tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$25(G__276310,G__276311,G__276312,G__276313,G__276314,G__276315,G__276316,G__276317,G__276318,G__276319,G__276320,G__276321,G__276322,G__276323,G__276324,G__276325,G__276326,G__276327,G__276328,G__276329,G__276330,G__276331,G__276332,G__276333,G__276334) : tailrecursion.hoplon.pre.call(null,G__276310,G__276311,G__276312,G__276313,G__276314,G__276315,G__276316,G__276317,G__276318,G__276319,G__276320,G__276321,G__276322,G__276323,G__276324,G__276325,G__276326,G__276327,G__276328,G__276329,G__276330,G__276331,G__276332,G__276333,G__276334));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2(G__276308,G__276309) : tailrecursion.hoplon.div.call(null,G__276308,G__276309));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1(G__276307) : tailrecursion.hoplon.div.call(null,G__276307));
})(),(function (){var G__276361 = cljs.core.PersistentArrayMap.EMPTY;
var G__276362 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["But suppose we are not concerned only with numbers. Suppose we would like to express, in procedural terms, the idea that one can form linear combinations whenever addition and multiplication are defined ",(function (){var G__276363 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$endash], null);
var G__276364 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276363,G__276364) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276363,G__276364));
})()," for rational numbers, complex numbers, polynomials, or whatever. We could express this as a procedure of the form"], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276361,G__276362) : tailrecursion.hoplon.markdown.para_node.call(null,G__276361,G__276362));
})(),(function (){var G__276420 = (function (){var G__276421 = new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$class,"highlight",cljs.core.cst$kw$style,"background: #f8f8f8"], null);
var G__276422 = (function (){var G__276423 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"line-height: 125%"], null);
var G__276424 = "(";
var G__276425 = (function (){var G__276450 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #008000; font-weight: bold"], null);
var G__276451 = "defn ";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276450,G__276451) : tailrecursion.hoplon.span.call(null,G__276450,G__276451));
})();
var G__276426 = (function (){var G__276452 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276453 = "linear-combination";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276452,G__276453) : tailrecursion.hoplon.span.call(null,G__276452,G__276453));
})();
var G__276427 = " [";
var G__276428 = (function (){var G__276454 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276455 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276454,G__276455) : tailrecursion.hoplon.span.call(null,G__276454,G__276455));
})();
var G__276429 = " ";
var G__276430 = (function (){var G__276456 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276457 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276456,G__276457) : tailrecursion.hoplon.span.call(null,G__276456,G__276457));
})();
var G__276431 = " ";
var G__276432 = (function (){var G__276458 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276459 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276458,G__276459) : tailrecursion.hoplon.span.call(null,G__276458,G__276459));
})();
var G__276433 = " ";
var G__276434 = (function (){var G__276460 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276461 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276460,G__276461) : tailrecursion.hoplon.span.call(null,G__276460,G__276461));
})();
var G__276435 = "]\n  (";
var G__276436 = (function (){var G__276462 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #0000FF"], null);
var G__276463 = "add";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276462,G__276463) : tailrecursion.hoplon.span.call(null,G__276462,G__276463));
})();
var G__276437 = " (";
var G__276438 = (function (){var G__276464 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #0000FF"], null);
var G__276465 = "mul";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276464,G__276465) : tailrecursion.hoplon.span.call(null,G__276464,G__276465));
})();
var G__276439 = " ";
var G__276440 = (function (){var G__276466 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276467 = "a";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276466,G__276467) : tailrecursion.hoplon.span.call(null,G__276466,G__276467));
})();
var G__276441 = " ";
var G__276442 = (function (){var G__276468 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276469 = "x";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276468,G__276469) : tailrecursion.hoplon.span.call(null,G__276468,G__276469));
})();
var G__276443 = ") (";
var G__276444 = (function (){var G__276470 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #0000FF"], null);
var G__276471 = "mul";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276470,G__276471) : tailrecursion.hoplon.span.call(null,G__276470,G__276471));
})();
var G__276445 = " ";
var G__276446 = (function (){var G__276472 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276473 = "b";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276472,G__276473) : tailrecursion.hoplon.span.call(null,G__276472,G__276473));
})();
var G__276447 = " ";
var G__276448 = (function (){var G__276474 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$style,"color: #19177C"], null);
var G__276475 = "y";
return (tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.span.cljs$core$IFn$_invoke$arity$2(G__276474,G__276475) : tailrecursion.hoplon.span.call(null,G__276474,G__276475));
})();
var G__276449 = ")))\n";
return (tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$27 ? tailrecursion.hoplon.pre.cljs$core$IFn$_invoke$arity$27(G__276423,G__276424,G__276425,G__276426,G__276427,G__276428,G__276429,G__276430,G__276431,G__276432,G__276433,G__276434,G__276435,G__276436,G__276437,G__276438,G__276439,G__276440,G__276441,G__276442,G__276443,G__276444,G__276445,G__276446,G__276447,G__276448,G__276449) : tailrecursion.hoplon.pre.call(null,G__276423,G__276424,G__276425,G__276426,G__276427,G__276428,G__276429,G__276430,G__276431,G__276432,G__276433,G__276434,G__276435,G__276436,G__276437,G__276438,G__276439,G__276440,G__276441,G__276442,G__276443,G__276444,G__276445,G__276446,G__276447,G__276448,G__276449));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$2(G__276421,G__276422) : tailrecursion.hoplon.div.call(null,G__276421,G__276422));
})();
return (tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1 ? tailrecursion.hoplon.div.cljs$core$IFn$_invoke$arity$1(G__276420) : tailrecursion.hoplon.div.call(null,G__276420));
})(),(function (){var G__276476 = cljs.core.PersistentArrayMap.EMPTY;
var G__276477 = cljs.core.PersistentVector.fromArray(["where ",(function (){var G__276478 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"add"], null);
var G__276479 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276478,G__276479) : tailrecursion.hoplon.markdown.code_node.call(null,G__276478,G__276479));
})()," and ",(function (){var G__276480 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"mul"], null);
var G__276481 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276480,G__276481) : tailrecursion.hoplon.markdown.code_node.call(null,G__276480,G__276481));
})()," are not the primitive procedures + and * but rather more complex things that will perform the appropriate operations for whatever kinds of data we pass in as the arguments ",(function (){var G__276482 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"a"], null);
var G__276483 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276482,G__276483) : tailrecursion.hoplon.markdown.code_node.call(null,G__276482,G__276483));
})(),", ",(function (){var G__276484 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"b"], null);
var G__276485 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276484,G__276485) : tailrecursion.hoplon.markdown.code_node.call(null,G__276484,G__276485));
})(),", ",(function (){var G__276486 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"x"], null);
var G__276487 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276486,G__276487) : tailrecursion.hoplon.markdown.code_node.call(null,G__276486,G__276487));
})(),", and ",(function (){var G__276488 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"y"], null);
var G__276489 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276488,G__276489) : tailrecursion.hoplon.markdown.code_node.call(null,G__276488,G__276489));
})(),". The key point is that the only thing ",(function (){var G__276490 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"linear-combination"], null);
var G__276491 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276490,G__276491) : tailrecursion.hoplon.markdown.code_node.call(null,G__276490,G__276491));
})()," should need to know about ",(function (){var G__276492 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"a"], null);
var G__276493 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276492,G__276493) : tailrecursion.hoplon.markdown.code_node.call(null,G__276492,G__276493));
})(),", ",(function (){var G__276494 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"b"], null);
var G__276495 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276494,G__276495) : tailrecursion.hoplon.markdown.code_node.call(null,G__276494,G__276495));
})(),", ",(function (){var G__276496 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"x"], null);
var G__276497 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276496,G__276497) : tailrecursion.hoplon.markdown.code_node.call(null,G__276496,G__276497));
})(),", and ",(function (){var G__276498 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"y"], null);
var G__276499 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276498,G__276499) : tailrecursion.hoplon.markdown.code_node.call(null,G__276498,G__276499));
})()," is that the procedures ",(function (){var G__276500 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"add"], null);
var G__276501 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276500,G__276501) : tailrecursion.hoplon.markdown.code_node.call(null,G__276500,G__276501));
})()," and ",(function (){var G__276502 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"mul"], null);
var G__276503 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276502,G__276503) : tailrecursion.hoplon.markdown.code_node.call(null,G__276502,G__276503));
})()," will perform the appropriate manipulations. From the perspective of the procedure ",(function (){var G__276504 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"linear-combination"], null);
var G__276505 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276504,G__276505) : tailrecursion.hoplon.markdown.code_node.call(null,G__276504,G__276505));
})(),", it is irrelevant what ",(function (){var G__276506 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"a"], null);
var G__276507 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276506,G__276507) : tailrecursion.hoplon.markdown.code_node.call(null,G__276506,G__276507));
})(),", ",(function (){var G__276508 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"b"], null);
var G__276509 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276508,G__276509) : tailrecursion.hoplon.markdown.code_node.call(null,G__276508,G__276509));
})(),", ",(function (){var G__276510 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"x"], null);
var G__276511 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276510,G__276511) : tailrecursion.hoplon.markdown.code_node.call(null,G__276510,G__276511));
})(),", and ",(function (){var G__276512 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"y"], null);
var G__276513 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276512,G__276513) : tailrecursion.hoplon.markdown.code_node.call(null,G__276512,G__276513));
})()," are and even more irrelevant how they might happen to be represented in terms of more primitive data. This same example shows why it is important that our programming language provide the ability to manipulate compound objects directly: Without this, there is no way for a procedure such as ",(function (){var G__276514 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"linear-combination"], null);
var G__276515 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276514,G__276515) : tailrecursion.hoplon.markdown.code_node.call(null,G__276514,G__276515));
})()," to pass its arguments along to ",(function (){var G__276516 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"add"], null);
var G__276517 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276516,G__276517) : tailrecursion.hoplon.markdown.code_node.call(null,G__276516,G__276517));
})()," and ",(function (){var G__276518 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"mul"], null);
var G__276519 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276518,G__276519) : tailrecursion.hoplon.markdown.code_node.call(null,G__276518,G__276519));
})()," without having to know their detailed structure.",(function (){var G__276520 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double_DASH_angle], null);
var G__276521 = new cljs.core.PersistentVector(null, 15, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The ability to directly manipulate procedures provides an analogous increase in the expressive power of a programming language. For example, in ",tailrecursion.hoplon.markdown.exp_link_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$url,"#!/sicp/ch/1/sect/3/sub/1/",cljs.core.cst$kw$title,""], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["section 1.3.1"], null)], 0))," we introduced the ",(function (){var G__276522 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"sum"], null);
var G__276523 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276522,G__276523) : tailrecursion.hoplon.markdown.code_node.call(null,G__276522,G__276523));
})()," procedure, which takes a procedure ",(function (){var G__276524 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"term"], null);
var G__276525 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276524,G__276525) : tailrecursion.hoplon.markdown.code_node.call(null,G__276524,G__276525));
})()," as an argument and computes the sum of the values of ",(function (){var G__276526 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"term"], null);
var G__276527 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276526,G__276527) : tailrecursion.hoplon.markdown.code_node.call(null,G__276526,G__276527));
})()," over some specified interval. In order to define ",(function (){var G__276528 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"sum"], null);
var G__276529 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276528,G__276529) : tailrecursion.hoplon.markdown.code_node.call(null,G__276528,G__276529));
})(),", it is crucial that we be able to speak of a procedure such as term as an entity in its own right, without regard for how term might be expressed with more primitive operations. Indeed, if we did not have the notion of ",(function (){var G__276530 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double], null);
var G__276531 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["a procedure,"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__276530,G__276531) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__276530,G__276531));
})()," it is doubtful that we would ever even think of the possibility of defining an operation such as ",(function (){var G__276532 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"sum"], null);
var G__276533 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276532,G__276533) : tailrecursion.hoplon.markdown.code_node.call(null,G__276532,G__276533));
})(),". Moreover, insofar as performing the summation is concerned, the details of how term may be constructed from more primitive operations are irrelevant."], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__276520,G__276521) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__276520,G__276521));
})()," We begin this chapter by implementing the rational-number arithmetic system mentioned above. This will form the background for our discussion of compound data and data abstraction. As with compound procedures, the main issue to be addressed is that of abstraction as a technique for coping with complexity, and we will see how data abstraction enables us to erect suitable ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["abstraction barriers"], null)], 0))," between different parts of a program."], true);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276476,G__276477) : tailrecursion.hoplon.markdown.para_node.call(null,G__276476,G__276477));
})(),(function (){var G__276534 = cljs.core.PersistentArrayMap.EMPTY;
var G__276535 = new cljs.core.PersistentVector(null, 15, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We will see that the key to forming compound data is that a programming language should provide some kind of ",(function (){var G__276536 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double], null);
var G__276537 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["glue"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__276536,G__276537) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__276536,G__276537));
})()," so that data objects can be combined to form more complex data objects. There are many possible kinds of glue. Indeed, we will discover how to form compound data using no special ",(function (){var G__276538 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double], null);
var G__276539 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__276538,G__276539) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__276538,G__276539));
})()," operations at all, only procedures. This will further blur the distinction between ",(function (){var G__276540 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double], null);
var G__276541 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["procedure"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__276540,G__276541) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__276540,G__276541));
})()," and ",(function (){var G__276542 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double], null);
var G__276543 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data,"], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__276542,G__276543) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__276542,G__276543));
})()," which was already becoming tenuous toward the end of chapter 1. We will also explore some conventional techniques for representing sequences and trees. One key idea in dealing with compound data is the notion of ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["closure"], null)], 0))," ",(function (){var G__276544 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$endash], null);
var G__276545 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276544,G__276545) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276544,G__276545));
})()," that the glue we use for combining data objects should allow us to combine not only primitive data objects, but compound data objects as well. Another key idea is that compound data objects can serve as ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["conventional interfaces"], null)], 0))," for combining program modules in mix-and-match ways. We illustrate some of these ideas by presenting a simple graphics language that exploits closure."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276534,G__276535) : tailrecursion.hoplon.markdown.para_node.call(null,G__276534,G__276535));
})(),(function (){var G__276546 = cljs.core.PersistentArrayMap.EMPTY;
var G__276547 = new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We will then augment the representational power of our language by introducing ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["symbolic expressions"], null)], 0))," ",(function (){var G__276548 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$endash], null);
var G__276549 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276548,G__276549) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276548,G__276549));
})()," data whose elementary parts can be arbitrary symbols rather than only numbers. We explore various alternatives for representing sets of objects. We will find that, just as a given numerical function can be computed by many different computational processes, there are many ways in which a given data structure can be represented in terms of simpler objects, and the choice of representation can have significant impact on the time and space requirements of processes that manipulate the data. We will investigate these ideas in the context of symbolic differentiation, the representation of sets, and the encoding of information."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276546,G__276547) : tailrecursion.hoplon.markdown.para_node.call(null,G__276546,G__276547));
})(),(function (){var G__276550 = cljs.core.PersistentArrayMap.EMPTY;
var G__276551 = new cljs.core.PersistentVector(null, 7, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Next we will take up the problem of working with data that may be represented differently by different parts of a program. This leads to the need to implement generic operations, which must handle many different types of data. Maintaining modularity in the presence of ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["generic operations"], null)], 0))," requires more powerful abstraction barriers than can be erected with simple data abstraction alone. In particular, we introduce ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data-directed programming"], null)], 0))," as a technique that allows individual data representations to be designed in isolation and then combined ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["additively"], null)], 0))," (i.e., without modification). To illustrate the power of this approach to system design, we close the chapter by applying what we have learned to the implementation of a package for performing symbolic arithmetic on polynomials, in which the coefficients of the polynomials can be integers, rational numbers, complex numbers, and even other polynomials."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276550,G__276551) : tailrecursion.hoplon.markdown.para_node.call(null,G__276550,G__276551));
})()], null);
}finally {tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = _STAR_abbreviations_STAR_276223;

tailrecursion.hoplon.markdown._STAR_references_STAR_ = _STAR_references_STAR_276222;
}}finally {tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = _STAR_abbreviations_STAR_276221;

tailrecursion.hoplon.markdown._STAR_references_STAR_ = _STAR_references_STAR_276220;
}})()], 0));
};
var book$sicp$texts$ch2$content = function (var_args){
var args__8262__auto__ = null;
if (arguments.length > 0) {
var G__276552__i = 0, G__276552__a = new Array(arguments.length -  0);
while (G__276552__i < G__276552__a.length) {G__276552__a[G__276552__i] = arguments[G__276552__i + 0]; ++G__276552__i;}
  args__8262__auto__ = new cljs.core.IndexedSeq(G__276552__a,0);
} 
return book$sicp$texts$ch2$content__delegate.call(this,args__8262__auto__);};
book$sicp$texts$ch2$content.cljs$lang$maxFixedArity = 0;
book$sicp$texts$ch2$content.cljs$lang$applyTo = (function (arglist__276553){
var args__8262__auto__ = cljs.core.seq(arglist__276553);
return book$sicp$texts$ch2$content__delegate(args__8262__auto__);
});
book$sicp$texts$ch2$content.cljs$core$IFn$_invoke$arity$variadic = book$sicp$texts$ch2$content__delegate;
return book$sicp$texts$ch2$content;
})()
;
