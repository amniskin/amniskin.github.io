// Compiled by ClojureScript 1.7.48 {:static-fns true, :optimize-constants true}
goog.provide('book.sicp.texts.ch1');
goog.require('cljs.core');
goog.require('tailrecursion.hoplon.markdown');
goog.require('book.sicp.book_data');
goog.require('tailrecursion.hoplon');
goog.require('tailrecursion.javelin');
/**
 * @param {...*} var_args
 */
book.sicp.texts.ch1.content = (function() { 
var book$sicp$texts$ch1$content__delegate = function (args__8262__auto__){
var vec__276625 = tailrecursion.hoplon.parse_args(args__8262__auto__);
var attr = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__276625,(0),null);
var kids = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__276625,(1),null);
return book.sicp.book_data.chapter.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$title,"Building Abstractions with Procedures"], null),(function (){var _STAR_references_STAR_276626 = tailrecursion.hoplon.markdown._STAR_references_STAR_;
var _STAR_abbreviations_STAR_276627 = tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_;
tailrecursion.hoplon.markdown._STAR_references_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_references_STAR_,null], 0));

tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_,null], 0));

try{var _STAR_references_STAR_276628 = tailrecursion.hoplon.markdown._STAR_references_STAR_;
var _STAR_abbreviations_STAR_276629 = tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_;
tailrecursion.hoplon.markdown._STAR_references_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_references_STAR_,cljs.core.PersistentArrayMap.EMPTY], 0));

tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_,cljs.core.List.EMPTY], 0));

try{return new cljs.core.PersistentVector(null, 12, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){var G__276630 = cljs.core.PersistentArrayMap.EMPTY;
var G__276631 = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){var G__276632 = cljs.core.PersistentArrayMap.EMPTY;
var G__276633 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The acts of the mind, wherein it exerts its power over simple ideas, are chiefly these three: 1. Combining several simple ideas into one compound one, and thus all complex ideas are made. 2. The second is bringing two ideas, whether simple or complex, together, and setting them by one another so as to take a view of them at once, without uniting them into one, by which it gets all its ideas of relations. 3. The third is separating them from all other ideas that accompany them in their real existence: this is called abstraction, and thus all its general ideas are made."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276632,G__276633) : tailrecursion.hoplon.markdown.para_node.call(null,G__276632,G__276633));
})(),(function (){var G__276634 = cljs.core.PersistentArrayMap.EMPTY;
var G__276635 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["John Locke, ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["An Essay Concerning Human Understanding"], null)], 0))," (1690)"], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276634,G__276635) : tailrecursion.hoplon.markdown.para_node.call(null,G__276634,G__276635));
})()], null);
return (tailrecursion.hoplon.markdown.block_quote_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.block_quote_node.cljs$core$IFn$_invoke$arity$2(G__276630,G__276631) : tailrecursion.hoplon.markdown.block_quote_node.call(null,G__276630,G__276631));
})(),(function (){var G__276636 = cljs.core.PersistentArrayMap.EMPTY;
var G__276637 = new cljs.core.PersistentVector(null, 7, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We are about to study the idea of a ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["computational process"], null)], 0)),". Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["data"], null)], 0)),". The evolution of a process is directed by a pattern of rules called a ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["program"], null)], 0)),". People create programs to direct processes. In effect, we conjure the spirits of the computer with our spells."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276636,G__276637) : tailrecursion.hoplon.markdown.para_node.call(null,G__276636,G__276637));
})(),(function (){var G__276638 = cljs.core.PersistentArrayMap.EMPTY;
var G__276639 = new cljs.core.PersistentVector(null, 7, 5, cljs.core.PersistentVector.EMPTY_NODE, ["A computational process is indeed much like a sorcerer",(function (){var G__276640 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$apostrophe], null);
var G__276641 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276640,G__276641) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276640,G__276641));
})(),"s idea of a spirit. It cannot be seen or touched. It is not composed of matter at all. However, it is very real. It can perform intellectual work. It can answer questions. It can affect the world by disbursing money at a bank or by controlling a robot arm in a factory. The programs we use to conjure processes are like a sorcerer",(function (){var G__276642 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$apostrophe], null);
var G__276643 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276642,G__276643) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276642,G__276643));
})(),"s spells. They are carefully composed from symbolic expressions in arcane and esoteric ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["programming languages"], null)], 0))," that prescribe the tasks we want our processes to perform."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276638,G__276639) : tailrecursion.hoplon.markdown.para_node.call(null,G__276638,G__276639));
})(),(function (){var G__276644 = cljs.core.PersistentArrayMap.EMPTY;
var G__276645 = new cljs.core.PersistentVector(null, 7, 5, cljs.core.PersistentVector.EMPTY_NODE, ["A computational process, in a correctly working computer, executes programs precisely and accurately. Thus, like the sorcerer",(function (){var G__276646 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$apostrophe], null);
var G__276647 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276646,G__276647) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276646,G__276647));
})(),"s apprentice, novice programmers must learn to understand and to anticipate the consequences of their conjuring. Even small errors (usually called ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["bugs"], null)], 0))," or ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["glitches"], null)], 0)),") in programs can have complex and unanticipated consequences."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276644,G__276645) : tailrecursion.hoplon.markdown.para_node.call(null,G__276644,G__276645));
})(),(function (){var G__276648 = cljs.core.PersistentArrayMap.EMPTY;
var G__276649 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Fortunately, learning to program is considerably less dangerous than learning sorcery, because the spirits we deal with are conveniently contained in a secure way. Real-world programming, however, requires care, expertise, and wisdom. A small bug in a computer-aided design program, for example, can lead to the catastrophic collapse of an airplane or a dam or the self-destruction of an industrial robot."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276648,G__276649) : tailrecursion.hoplon.markdown.para_node.call(null,G__276648,G__276649));
})(),(function (){var G__276650 = cljs.core.PersistentArrayMap.EMPTY;
var G__276651 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Master software engineers have the ability to organize programs so that they can be reasonably sure that the resulting processes will perform the tasks intended. They can visualize the behavior of their systems in advance. They know how to structure programs so that unanticipated problems do not lead to catastrophic consequences, and when problems do arise, they can ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["debug"], null)], 0))," their programs. Well-designed computational systems, like well-designed automobiles or nuclear reactors, are designed in a modular manner, so that the parts can be constructed, replaced, and debugged separately."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276650,G__276651) : tailrecursion.hoplon.markdown.para_node.call(null,G__276650,G__276651));
})(),tailrecursion.hoplon.markdown.header_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$level,(3)], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Programming in Lisp"], null)], 0)),(function (){var G__276652 = cljs.core.PersistentArrayMap.EMPTY;
var G__276653 = new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, ["We need an appropriate language for describing processes, and we will use for this purpose the programming language Lisp. Just as our everyday thoughts are usually expressed in our natural language (such as English, French, or Japanese), and descriptions of quantitative phenomena are expressed with mathematical notations, our procedural thoughts will be expressed in Lisp. Lisp was invented in the late 1950s as a formalism for reasoning about the use of certain kinds of logical expressions, called ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["recursion equations"], null)], 0)),", as a model for computation. The language was conceived by John McCarthy and is based on his paper ``Recursive Functions of Symbolic Expressions and Their Computation by Machine",(function (){var G__276654 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$apostrophe], null);
var G__276655 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276654,G__276655) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276654,G__276655));
})(),(function (){var G__276656 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$apostrophe], null);
var G__276657 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276656,G__276657) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276656,G__276657));
})()," (McCarthy 1960)."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276652,G__276653) : tailrecursion.hoplon.markdown.para_node.call(null,G__276652,G__276653));
})(),(function (){var G__276658 = cljs.core.PersistentArrayMap.EMPTY;
var G__276659 = new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Despite its inception as a mathematical formalism, Lisp is a practical programming language. A Lisp ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["interpreter"], null)], 0))," is a machine that carries out processes described in the Lisp language. The first Lisp interpreter was implemented by McCarthy with the help of colleagues and students in the Artificial Intelligence Group of the MIT Research Laboratory of Electronics and in the MIT Computation Center.",(function (){var G__276660 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double_DASH_angle], null);
var G__276661 = new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Lisp 1 Programmer",(function (){var G__276662 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$apostrophe], null);
var G__276663 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276662,G__276663) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276662,G__276663));
})(),"s Manual"], null)], 0))," appeared in 1960, and the ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Lisp 1.5 Programmer",(function (){var G__276664 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$apostrophe], null);
var G__276665 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276664,G__276665) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276664,G__276665));
})(),"s Manual"], null)], 0))," (McCarthy 1965) was published in 1962. The early history of Lisp is described in McCarthy 1978."], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__276660,G__276661) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__276660,G__276661));
})()," Lisp, whose name is an acronym for LISt Processing, was designed to provide symbol-manipulating capabilities for attacking programming problems such as the symbolic differentiation and integration of algebraic expressions. It included for this purpose new data objects known as atoms and lists, which most strikingly set it apart from all other languages of the period."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276658,G__276659) : tailrecursion.hoplon.markdown.para_node.call(null,G__276658,G__276659));
})(),(function (){var G__276666 = cljs.core.PersistentArrayMap.EMPTY;
var G__276667 = new cljs.core.PersistentVector(null, 9, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Lisp was not the product of a concerted design effort. Instead, it evolved informally in an experimental manner in response to users",(function (){var G__276668 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$apostrophe], null);
var G__276669 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276668,G__276669) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276668,G__276669));
})()," needs and to pragmatic implementation considerations. Lisp",(function (){var G__276670 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$apostrophe], null);
var G__276671 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276670,G__276671) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276670,G__276671));
})(),"s informal evolution has continued through the years, and the community of Lisp users has traditionally resisted attempts to promulgate any ``official",(function (){var G__276672 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$apostrophe], null);
var G__276673 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276672,G__276673) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276672,G__276673));
})(),(function (){var G__276674 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$apostrophe], null);
var G__276675 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276674,G__276675) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276674,G__276675));
})()," definition of the language. This evolution, together with the flexibility and elegance of the initial conception, has enabled Lisp, which is the second oldest language in widespread use today (only Fortran is older), to continually adapt to encompass the most modern ideas about program design. Thus, Lisp is by now a family of dialects, which, while sharing most of the original features, may differ from one another in significant ways. The dialect of Lisp used in this book is called Scheme.",(function (){var G__276676 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double_DASH_angle], null);
var G__276677 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["The two dialects in which most major Lisp programs of the 1970s were written are MacLisp (Moon 1978; Pitman 1983), developed at the MIT Project MAC, and Interlisp (Teitelman 1974), developed at Bolt Beranek and Newman Inc. and the Xerox Palo Alto Research Center. Portable Standard Lisp (Hearn 1969; Griss 1981) was a Lisp dialect designed to be easily portable between different machines. MacLisp spawned a number of subdialects, such as Franz Lisp, which was developed at the University of California at Berkeley, and Zetalisp (Moon 1981), which was based on a special-purpose processor designed at the MIT Artificial Intelligence Laboratory to run Lisp very efficiently. The Lisp dialect used in this book, called Scheme (Steele 1975), was invented in 1975 by Guy Lewis Steele Jr. and Gerald Jay Sussman of the MIT Artificial Intelligence Laboratory and later reimplemented for instructional use at MIT. Scheme became an IEEE standard in 1990 (IEEE 1990). The Common Lisp dialect (Steele 1982, Steele 1990) was developed by the Lisp community to combine features from the earlier Lisp dialects to make an industrial standard for Lisp. Common Lisp became an ANSI standard in 1994 (ANSI 1994)."], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__276676,G__276677) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__276676,G__276677));
})()], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276666,G__276667) : tailrecursion.hoplon.markdown.para_node.call(null,G__276666,G__276667));
})(),(function (){var G__276678 = cljs.core.PersistentArrayMap.EMPTY;
var G__276679 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["Because of its experimental character and its emphasis on symbol manipulation, Lisp was at first very inefficient for numerical computations, at least in comparison with Fortran. Over the years, however, Lisp compilers have been developed that translate programs into machine code that can perform numerical computations reasonably efficiently. And for special applications, Lisp has been used with great effectiveness.",(function (){var G__276680 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$double_DASH_angle], null);
var G__276681 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, ["One such special application was a breakthrough computation of scientific importance ",(function (){var G__276682 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$endash], null);
var G__276683 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276682,G__276683) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276682,G__276683));
})()," an integration of the motion of the Solar System that extended previous results by nearly two orders of magnitude, and demonstrated that the dynamics of the Solar System is chaotic. This computation was made possible by new integration algorithms, a special-purpose compiler, and a special-purpose computer all implemented with the aid of software tools written in Lisp (Abelson et al. 1992; Sussman and Wisdom 1992)."], null);
return (tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.quoted_node.cljs$core$IFn$_invoke$arity$2(G__276680,G__276681) : tailrecursion.hoplon.markdown.quoted_node.call(null,G__276680,G__276681));
})()," Although Lisp has not yet overcome its old reputation as hopelessly inefficient, Lisp is now used in many applications where efficiency is not the central concern. For example, Lisp has become a language of choice for operating-system shell languages and for extension languages for editors and computer-aided design systems."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276678,G__276679) : tailrecursion.hoplon.markdown.para_node.call(null,G__276678,G__276679));
})(),(function (){var G__276684 = cljs.core.PersistentArrayMap.EMPTY;
var G__276685 = new cljs.core.PersistentVector(null, 10, 5, cljs.core.PersistentVector.EMPTY_NODE, ["If Lisp is not a mainstream language, why are we using it as the framework for our discussion of programming? Because the language possesses unique features that make it an excellent medium for studying important programming constructs and data structures and for relating them to the linguistic features that support them. The most significant of these features is the fact that Lisp descriptions of processes, called ",tailrecursion.hoplon.markdown.strong_emph_super_node.cljs$core$IFn$_invoke$arity$variadic(cljs.core.array_seq([new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$chars,"*",cljs.core.cst$kw$closed,true,cljs.core.cst$kw$strong,false], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, ["procedures"], null)], 0)),", can themselves be represented and manipulated as Lisp data. The importance of this is that there are powerful program-design techniques that rely on the ability to blur the traditional distinction between ",(function (){var G__276686 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$text,"passive'' data and"], null);
var G__276687 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.code_node.cljs$core$IFn$_invoke$arity$2(G__276686,G__276687) : tailrecursion.hoplon.markdown.code_node.call(null,G__276686,G__276687));
})(),"active",(function (){var G__276688 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$apostrophe], null);
var G__276689 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276688,G__276689) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276688,G__276689));
})(),(function (){var G__276690 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$apostrophe], null);
var G__276691 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276690,G__276691) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276690,G__276691));
})()," processes. As we shall discover, Lisp",(function (){var G__276692 = new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$type,cljs.core.cst$kw$apostrophe], null);
var G__276693 = cljs.core.PersistentVector.EMPTY;
return (tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.simple_node.cljs$core$IFn$_invoke$arity$2(G__276692,G__276693) : tailrecursion.hoplon.markdown.simple_node.call(null,G__276692,G__276693));
})(),"s flexibility in handling procedures as data makes it one of the most convenient languages in existence for exploring these techniques. The ability to represent procedures as data also makes Lisp an excellent language for writing programs that must manipulate other programs as data, such as the interpreters and compilers that support computer languages. Above and beyond these considerations, programming in Lisp is great fun."], null);
return (tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2 ? tailrecursion.hoplon.markdown.para_node.cljs$core$IFn$_invoke$arity$2(G__276684,G__276685) : tailrecursion.hoplon.markdown.para_node.call(null,G__276684,G__276685));
})()], null);
}finally {tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = _STAR_abbreviations_STAR_276629;

tailrecursion.hoplon.markdown._STAR_references_STAR_ = _STAR_references_STAR_276628;
}}finally {tailrecursion.hoplon.markdown._STAR_abbreviations_STAR_ = _STAR_abbreviations_STAR_276627;

tailrecursion.hoplon.markdown._STAR_references_STAR_ = _STAR_references_STAR_276626;
}})()], 0));
};
var book$sicp$texts$ch1$content = function (var_args){
var args__8262__auto__ = null;
if (arguments.length > 0) {
var G__276694__i = 0, G__276694__a = new Array(arguments.length -  0);
while (G__276694__i < G__276694__a.length) {G__276694__a[G__276694__i] = arguments[G__276694__i + 0]; ++G__276694__i;}
  args__8262__auto__ = new cljs.core.IndexedSeq(G__276694__a,0);
} 
return book$sicp$texts$ch1$content__delegate.call(this,args__8262__auto__);};
book$sicp$texts$ch1$content.cljs$lang$maxFixedArity = 0;
book$sicp$texts$ch1$content.cljs$lang$applyTo = (function (arglist__276695){
var args__8262__auto__ = cljs.core.seq(arglist__276695);
return book$sicp$texts$ch1$content__delegate(args__8262__auto__);
});
book$sicp$texts$ch1$content.cljs$core$IFn$_invoke$arity$variadic = book$sicp$texts$ch1$content__delegate;
return book$sicp$texts$ch1$content;
})()
;
