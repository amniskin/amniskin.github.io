(ns book.sicp.texts.ch2sect3 (:require [tailrecursion.hoplon.markdown :as md] [book.sicp.book-data :as data] [tailrecursion.hoplon :refer [form audio input hgroup do! timeout $text base h1 embed h3 body keygen on-append! progress main cite on-page-load object i p nav ruby check-val! a menu blockquote img $comment span track seq?* data u dl select html thead del eventsource append-child fieldset aside figure figcaption sentinel q on! bdi video address caption parse-args dd rp hr tbody table acronym frame applet html-var add-initfn! pre ul dir html-time add-attributes! html-map sup dfn sub mark script big button wbr strong li dt frameset td tr section th optgroup iframe legend em kbd spliced article isindex abbr command <!-- source output basefont route-cell header datalist tfoot s ins footer title is-ie8 h5 canvas param font div option summary samp center small style textarea loop-tpl* strike h4 tt head add-children! ol details col vector?* label rt when-dom h6 link page-load colgroup meter html-meta text-val! bdo --> b code node? noframes replace-children! noscript safe-nth h2 area br]] [tailrecursion.javelin :refer [input? cell cell? destroy-cell! ^{:private true} last-rank ^{:deprecated true} lift lens? set-formula! cell-doseq* ^{:dynamic true, :private true} *tx* deref* set-cell! lens formula? alts! dosync* cell-map formula]]) (:require-macros [tailrecursion.hoplon.markdown :refer [md]] [tailrecursion.hoplon :refer [text with-timeout sexp defelem def-values with-page-load with-dom loop-tpl with-interval with-init!]] [tailrecursion.javelin :refer [with-let mx2 dosync cell= set-cell!= prop-cell cell-doseq defc cell-let-1 defc= macroexpand-all mx cell-let]]))

(sexp {} "defelem content [_ _]" (div {} (data/sect {:title "Symbolic Data"} (md {} "All the compound data objects we have used so far were constructed\nultimately from numbers. In this section we extend the representational\ncapability of our language by introducing the ability to work with\narbitrary symbols as data.")) "" (data/subsect {:title "Quotation"} (md {} "If we can form compound data using symbols, we can have lists such as\n\n```clj\n(a b c d)\n(12 45 17)\n((Norah 12) (Molly 9) (Anna 7) (Lauren 6) (Charlotte 4))\n```\n\nLists containing symbols can look just like the exressions of our language:\n\n```clj\n(* (+ 23 45) (+ x 9))\n(defn fact [n] (if (= n 1) 1 (* n (fact (- n 1)))))\n```\n\nIn order to manipulate symbols we need a new element in our language:\nthe ability to *quote* a data object. Suppose we want to construct the\nlist `(a b)`. We can't accomplish this with `(list a b)`, because this\nexpression constructs a list of the *values* of `a` and `b` rather than\nthe symbols themselves. This issue is well known in the context of\nnatural languages, where words and sentences may be regarded either as\nsemantic entities or as character strings (syntactic entities). The\ncommon practice in natural languages is to use quotation marks to\nindicate that a word or a sentence is to be treated literally as a\nstring of characters. For instance, the first letter of \"John\" is\nclearly a \"J.\" If we tell somebody, \"say your name aloud,\" we expect to\nhear that person's name. However, if we tell somebody \"say \\'your\nname\\' aloud,\" we expect to hear the words \"your name.\" Note that we\nare forced to nest quotation marks to describe what somebody else might\nsay.<<Allowing quotation in a language wreaks havoc with the ability to\nreason about the language in simple terms, because it destroys the\nnotion that equals can be substituted for equals. For example, three is\none plus two, but the word \"three\" is not the phrase \"one plus two.\"\nQuotation is powerful because it gives us a way to build expressions\nthat manipulate other expressions (as we will see when we write an\ninterpreter in chapter 4). But allowing statements in a language that\ntalk about other statements in that language makes it very difficult to\nmaintain any coherent principle of what \"equals can be substituted for\nequals\" should mean. For example, if we know that the evening star is\nthe morning star, then from the statement \"the evening star is Venus\"\nwe can deduce \"the morning star is Venus.\" However, given that \"John\nknows that the evening star is Venus\" we cannot infer that \"John knows\nthat the morning star is Venus.\">>\n\n\nw this same practice to identify lists and symbols that are to be\ntreated as data objects rather than as expressions to be evaluated.\nHowever, our format for quoting differs from that of natural languages\nin that we place a quotation mark (traditionally, the single quote\nsymbol ') only at the beginning of the object to be quoted. We can get\naway with this in Scheme syntax because we rely on blanks and\nparentheses to delimit objects. Thus, the meaning of the single quote\ncharacter is to quote the next object.<<The single quote is different\nfrom the double quote we have been using to enclose character strings\nto be printed. Whereas the single quote can be used to denote lists or\nsymbols, the double quote is used only with character strings. In this\nbook, the only use for character strings is as items to be printed.>>\n\nNow we can distinguish between simbols and their values:\n\n```clj\n(def a 1)\n\n(def b 2)\n\n(list a b)\n=>(1 2)\n\n(list 'a 'b)\n=>(a b)\n\n(list 'a b)\n=>(a 2)\n```\n\nQuotation also allows us to type in compound objects, using the\nconventional printed representation for lists:<<Strictly, our use of\nthe quotation mark violates the general rule that all compound\nexpressions in our language should be delimited by parentheses and look\nlike lists. We can recover this consistency by introducing a special\nform quote, which serves the same purpose as the quotation mark. Thus,\nwe would type `(quote a)` instead of `'a`, and we would type `(quote (a\nb c))` instead of `'(a b c)`. This is precisely how the interpreter\nworks.  The quotation mark is just a single-character abbreviation for\nwrapping the next complete expression with quote to form `(quote\n<expression>)`.  This is important because it maintains the principle\nthat any expression seen by the interpreter can be manipulated as a\ndata object.  For instance, we could construct the expression `(first '(a\nb c))`, which is the same as `(first (quote (a b c)))`, by evaluating\n`(list 'first (list 'quote '(a b c)))`.>>\n\n```clj\n(first '(a b c))\n=> a\n\n(rest '(a b c))\n=> (b c)\n```\n\nIn keeping with this, we can obtain the empty list by evaluating `'()`.\n\nTo test whether two symbols are the same, we can use Clojure's `=`\nprimative. In Scheme, due to the lack of the protocol abstraction, this\nprimative had to be a new primative (one which they called `eq?`).<< We\ncan consider two symbols to be \"the same\" if they consist of the same\ncharacters in the same order. Such a definition skirts a deep issue\nthat we are not yet ready to address: the meaning of \"sameness\" in a\nprogramming language. We will return to this in chapter 3 (section\n3.1.3).>> Using `=`, we can implement a useful procedure called `memq`.\nThis takes two arguments, a symbol and a list. If the symbol is not\ncontained in the list (i.e., is not `=` to any item in the list), then\n`memq` returns false. Otherwise it returns the sublist of the list\nbeginning with the first occurrence of the symbol:\n\n```clj\n(defn memq [item x]\n  (loop [things x]\n    (cond (empty? x) false\n          (= item (first x)) x\n          :else (recur (rest x)))))\n```\n\nFor example,\n\n```clj\n(memq 'apple '(pear banana prune))\n=> false\n\n(memq 'apple '(x (apple sauce) y apple pear))\n=> (apple pear)\n```")) "" (data/exercises {} (data/exercise {} (md {} "What would the interpreter print in response to evaluating each of the following expressions?\n\n```clj\n(list 'a 'b 'c)\n```") "" (data/q-a {} (md {} "```clj\n(list 'a 'b 'c)\n=> (a b c)\n```")) "" (md {} "```clj\n(list (list 'george))\n```") "" (data/q-a {} (md {} "```clj\n(list (list 'george))\n=> ((george))\n```")) "" (md {} "```clj\n(second '((x1 x2) (y1 y2)))\n```") "" (data/q-a {} (md {} "```clj\n(second '((x1 x2) (y1 y2)))\n=> (y1 y2)\n```")) "" (md {} "```clj\n(list? (first '(a short list)))\n```") "" (data/q-a {} (md {} "```clj\n(list? (first '(a short list)))\n=> false\n```")) "" (md {} "```clj\n(memq 'red '((red shoes) (blue socks)))\n```") "" (data/q-a {} (md {} "```clj\n(memq 'red '((red shoes) (blue socks)))\n=> false\n```")) "" (md {} "```clj\n(memq 'red '(red shoes blue socks))\n```") "" (data/q-a {} (md {} "```clj\n(memq 'red '(red shoes blue socks))\n=> (red shoes blue socks)\n```"))) "" (data/exercise {} (md {} "Two lists are said to be equal (again we will make use of the diverse\nprotocols included in Clojure's `=` procedure), if they contain equal\nelements arranged in the same order. For example,\n\n```clj\n(= '(this is a list) '(this is a list))\n=> true\n\n(= '(this is a list) '(this (is a) list))\n=> false\n```\n\nTo be more precise, we can define the protocols for `=` recursively\nin terms of the basic `=` protocols we're used to. To do this (for\npurposes of instruction) we will need to define a new procedure `eq?`\nthat will take two arguments and return true if they are not lists\nand they are `=` in the traditional sense. From that, we can define\nour new protocol for `=`, which we will call `more-general-eq?` by\nsaying that `a` and `b` are `more-general-eq?` ifthey are both\nsymbols and `(= a b)`, or if they are both lists such that `(first\na)` is `more-general-eq?` to `(first b)` and `(rest a)` is\n`more-general-eq?` to `(rest b)`. Using this idea, implement `eq?`\nand `more-general-eq?` as procedures.<<In practice, programmers use\n`equal?` to compare lists that contain numbers as well as symbols.\nNumbers are not considered to be symbols. The question of whether two\nnumerically equal numbers (as tested by `=`) are also `eq?` is highly\nimplementation-dependent. A better definition of `equal?` (such as\nthe one that comes as a primitive in Scheme) would also stipulate\nthat if a and b are both numbers, then a and b are equal? if they are\nnumerically equal. I believe Clojure gets around this issue through\nthe use of protocols (something we will go over later). Basically,\nprotocols allow for the use of functions accross many different types\nof arguments. For instance, `first` can be used with a vector, a\nlist, and more generally, any sequential object. In fact, you could\nwrite your own protocols for `first` so that you could use `first` on\nyour own data structures. We&#39;ve actually been using protocols for\na while now via `conj`. When given a vector, `conj` appends the\nargument to the end of the vector; when given a list, `conj`\nprepends. This is due to protocols.>>") "" (data/q-a {} (md {} "```clj\n(defn eq? [a b]\n  (and (= a b)\n       (not (seq? a))))\n\n(defn more-general-eq? [a b]\n  (cond \n    (eq? a b) true\n    (empty? a) (empty? b)\n    (and (list? a) \n         (list? b))\n    (and (more-general-eq? (first a) (first b))\n         (more-general-eq? (rest a) (rest b)))\n    :else false)\n```\n\nThe idea being if `a` and `b` are equal (in this sense) then both\n`a` and `b` must be either: non-empty lists, empty lists, or not\nlists at all. This function takes care of those three cases in\nreverse order and if none are the case, it returns false."))) "" (data/exercise {} (md {} "Eva Lu Ator types to the interpreter the expression\n\n```clj\n(first ''abracadabra)\n```\n\nTo her surprise, the interpreter prints back `quote`. Explain.") "" (data/q-a {} (md {} "First let's take a look at what `''abracadabra` returns.\n\n```clj\n''abracadabra\n`(quote abracadabra)\n(quote (quote abracadabra))\n=> (quote abracadabra)\n```\n\nSo, we see the first thing in this list is the word \"quote\".")))) "" (data/subsect {:title "Example: Symbolic Differentiation"} (md {} "As an illustration of symbol manipulation and a further illustration of\ndata abstraction, consider the design of a procedure that performs\nsymbolic differentiation of algebraic expressions. We would like the\nprocedure to take as arguments an algebraic expression and a variable\nand to return the derivative of the expression with respect to the\nvariable. For example, if the arguments to the procedure are \\\\(ax2 +\nbx + c\\\\) and \\\\(x\\\\), the procedure should return \\\\(2ax + b\\\\).\nSymbolic differentiation is of special historical significance in Lisp.\nIt was one of the motivating examples behind the development of a\ncomputer language for symbol manipulation. Furthermore, it marked the\nbeginning of the line of research that led to the development of\npowerful systems for symbolic mathematical work, which are currently\nbeing used by a growing number of applied mathematicians and\nphysicists.\n\nIn developing the symbolic-differentiation program, we will follow the\nsame strategy of data abstraction that we followed in developing the\nrational-number system of section 2.1.1. That is, we will first define\na differentiation algorithm that operates on abstract objects such as\n\"sums,\" \"products,\" and \"variables\" without worrying about how these\nare to be represented. Only afterward will we address the\nrepresentation problem.")) "" (data/ssub {:title "The Differentiation Program with Abstract Data"} (md {} "In order to keep things simple, we will consider a very simple\nsymbolic-differentiation program that handles expressions that are\nbuilt up using only the operations of addition and multiplication with\ntwo arguments. Differentiation of any such expression can be carried\nout by applying the following reduction rules:\n\n$$\\begin{align*}\n\\frac{dc}{dx}=& 0 \\text{ for } c \\text{ a constant or a variable different from } x\\\\\\\\\n\\frac{dx}{dx}=& 1\\\\\\\\\n\\frac{d(u+v)}{dx}=& \\frac{du}{dx}+\\frac{dv}{dx}\\\\\\\\\n\\frac{d(uv)}{dx}=& u\\left(\\frac{du}{dx}\\right) + v\\left(\\frac{dv}{dx}\\right)\\\\\\\\\n\\end{align*}$$\n\nObserve that the latter two rules are recursive in nature. That is, to\nobtain the derivative of a sum we first find the derivatives of the\nterms and add them. Each of the terms may in turn be an expression that\nneeds to be decomposed. Decomposing into smaller and smaller pieces\nwill eventually produce pieces that are either constants or variables,\nwhose derivatives will be either 0 or 1.\n\nTo embody these rules in a procedure we indulge in a little wishful\nthinking, as we did in designing the rational-number implementation. If\nwe had a means for representing algebraic expressions, we should be\nable to tell whether an expression is a sum, a product, a constant, or\na variable. We should be able to extract the parts of an expression.\nFor a sum, for example we want to be able to extract the addend (first\nterm) and the augend (second term). We should also be able to construct\nexpressions from parts. Let us assume that we already have procedures\nto implement the following selectors, constructors, and predicates:") "" (table {:class "table"} (tbody {} (tr {} (td {} (md {} "`(variable? e)`")) (td {} (md {} "Is `e` a variable?"))) "" (tr {} (td {} (md {} "`(same-variable? v1 v2)`")) (td {} (md {} "Are `v1` and `v2` the same variable?"))) "" (tr {} (td {} (md {} "`(sum? e)`")) (td {} (md {} "Is `e` a sum?"))) "" (tr {} (td {} (md {} "`(addend e)`")) (td {} (md {} "Addend of the sum `e`."))) "" (tr {} (td {} (md {} "`(augend e)`")) (td {} (md {} "Augend of the sum `e`."))) "" (tr {} (td {} (md {} "`(make-sum e)`")) (td {} (md {} "Construct the sum of `a1` and `a2`."))) "" (tr {} (td {} (md {} "`(product? e)`")) (td {} (md {} "Is `e` a product?"))) "" (tr {} (td {} (md {} "`(multiplier e)`")) (td {} (md {} "Multiplier of the product `e`."))) "" (tr {} (td {} (md {} "`(multiplicand e)`")) (td {} (md {} "Multiplicand of the product `e`."))) "" (tr {} (td {} (md {} "`(make-product m1 m2)`")) (td {} (md {} "Construct the product of `m1` and `m2`."))))) "" (md {} "Using these, and the primitive predicate `number?`, which identifies\nnumbers, we can express the differentiation rules as the following\nprocedure:\n\n```clj\n(defn deriv [exp var]\n  (cond (number? exp) 0\n        (variable? exp) (if (same-variable? exp var) \n                            1 \n                            0)\n        (sum? exp) (make-sum\n                     (deriv (addend exp) var)\n                     (deriv (augend exp) var))\n        (product? exp) (make-sum\n                         (make-product (multiplier exp)\n                                       (deriv (multiplicand exp) var))\n                         (make-product (multiplicand exp)\n                                       (deriv (multiplier exp) var)))\n        :else (throw (Exception. \"Unknown expression type -- DERIV\"))))\n```\n\nThis `deriv` procedure inforporates the complete differentiation\nalgorithm. Since it is expressed in terms of abstract data, it will\nwork no matter how we choose to represent algebraic expressions, as\nlong as we design a proper set of selectors and constructors. This is\nthe issue we must address next.")) "" (data/ssub {:title "Representing Algebraic Expressions"} (md {} "We can imagine ways to use list structure to represent algebraic\nexpressions. For example, we could use lists of symbols that mirror the\nusual algebraic notation, representing \\\\(ax+b\\\\) as the list `(a * x +\nb)`. However, one especially straightforward choice is to use the same\nparenthesized prefix notation that Lisp uses for combinations: that is,\nto represent \\\\(ax+b\\\\) as `(+ (* a x) b)`. Then our data\nrepresentation for the differentiation problem is as follows:") "" (ul {} (li {} (md {} "The variables are symbols. They are identified by the primitive predicate `symbol?`: \n\n```clj\n(defn variable? [x]\n  (symbol? x))\n```")) "" (li {} (md {} "Two variables are the same if the symbols representing them are `=`.\n\n```clj\n(defn same-variable? [v1 v2]\n  (and (variable? v1)\n       (variable? v2)\n       (= v1 v2)))\n```")) "" (li {} (md {} "Sums and products are constructed as lists:\n\n```clj\n(defn make-sum [a1 a2]\n  (list '+ a1 a2))\n(defn make-product [m1 m2]\n  (list '* m1 m2))\n```")) "" (li {} (md {} "A sum is a list whose first element is the symbol `+`:\n\n```clj\n(defn sum? [x]\n  (and (seq? x)\n       (= (first x) '+)))\n```")) "" (li {} (md {} "The addend is the second term of the sum list:\n\n```clj\n(defn addend [s]\n  (second s))\n```")) "" (li {} (md {} "The augend is the third term of the sum list:\n\n```clj\n(defn augend [s]\n  (nth s 2))\n```")) "" (li {} (md {} "A product is a list whose first element is the symbol `*`:\n\n```clj\n(defn product? [x]\n  (and (seq? x)\n       (= (first x) '*)))\n```")) "" (li {} (md {} "The multiplier is the second item of the product list:\n\n```clj\n(defn multiplier [p]\n  (second p))\n```")) "" (li {} (md {} "The multiplicand is the third item of the product list:\n\n```clj\n(defn multiplicand [p]\n  (nth p 2))\n```")) "\nThus, we need only combine these with the algorithm as embodied by\n`deriv` in order to have a working symbolic differentiation program.\nLet us look at some examples of its behavior:\n\n```clj\n(deriv '(+ x 3) 'x)\n=> (+ 1 0)\n\n(deriv '(* x y) 'x)\n=> (+ (* x 0) (* 1 y))\n\n(deriv '(* (* x y) (+ x 3)) 'x)\n=> (+ (* (* x y) (+ 1 0))\n      (* (+ (* x 0) (* 1 y))\n         (+ x 3)))\n```\n\nThe program produces answers that are correct; however, they are\nunsimplified. It is true that\n\n$$\\frac{d(xy)}{dx}=x*0+1*y$$\n\nbut we would like the program to know that \\\\(x\\cdot0=0\\\\), \\\\(1\\cdot\ny=y\\\\), and \\\\(0+y=y\\\\). The answer for the second example should have\nbeen simply, \\\\(y\\\\). As the third example shows, this becomes a\nserious issue when the expressions are complex.\n\nOur difficulty is much like the one we encountered with the\nrational-number implementation: we haven't reduced answers to simplest\nform. To accomplish the rational-number reduction, we needed to change\nonly the constructors and the selectors of the implementation. We can\nadopt a similar strategy here. We won't change `deriv` at all.\nInstead, we will change `make-sum` so that if both summands are\nnumbers, `make-sum` will add them and return their sum. Also, if one of\nthe summands is 0, then `make-sum` will return the other summand.\n\n```clj\n(defn make-sum [a1 a2]\n  (cond (= a1 0) a2\n        (= a2 0) a1\n        (and (number? a1)\n             (number? a2)) (+ a1 a2)\n        :else (list '+ a1 a2)))\n```\n\nThis uses the procedure `=`, which, returns `true` if and only if the\ntwo arguments are of the same type and value. Since `0` is a number,\n`(= a1 0)` implies that `a1` must be a number as well. In the original\nSICP, they used a function `=number?` to accomplish this task. We do\nnot need this in Clojure.\n\nSimilarly, we will change `make-product` to build in the rules that 0\ntimes anything is 0 and 1 times anything is the thing itself:\n\n```clj\n(defn make-product [m1 m2]\n  (cond (or (= m1 0)\n            (= m2 0)) 0\n        (= m1 1) m2\n        (= m2 1) m1\n        (and (number? m1)\n             (number? m2)) (* m1 m2)\n        :else (list '* m1 m2)))\n```\n\nHere is how this version works on our three examples:\n\n```clj\n(deriv '(+ x 3) 'x)\n=> 1\n\n(deriv '(* x y) 'x)\n=> y\n\n(deriv '(* (* x y) (+ x 3)) 'x)\n=> (+ (* x y) (* y (+ x 3)))\n```\n\nAlthough this is quite an improvement, the third example shows that\nthere is still a long way to go before we get a program that puts\nexpressions into a form that we might agree is \"simplest.\" The problem\nof algebraic simplification is complex because, among other reasons, a\nform that may be simplest for one purpose may not be for another.")) "" (data/exercises {} (data/exercise {} (md {} "Show how to extend the basic differentiator to handle more kinds of\nexpressions. For instance, implement the differentiation rule\n\n$$\\frac{d(u^n)}{dx}=nu^{n-1}\\left(\\frac{du}{dx}\\right)$$\n\nby adding a new clause to the `deriv` program and defining\nappropriate procedures `exponentiation?`, `base`, `exponent` and\n`make-exponentiation`. (You may use the symbol `**` to denote\nexponentiation.) Build in the rules that anything raised to the power\n0 is 1, and anything raised to the power 1 is the thing itself.") "" (data/q-a {} (md {} "We must add the following clause to the definition of `(deriv exp\nvar)`, where `exp` refers to the expression, and `var` refers to\nthe variable with which we are differentiating.\n\n```clj\n(exponentiation? exp)\n(make-product \n  (make-product \n    (exponent exp)\n    (make-exponentiation \n      (base exp) \n      (exponent (- exp 1))))\n  (deriv (base exp) var))\n```\n\n```clj\n(defn exponentiation? [exp]\n  (= (first exp) '**))\n\n(defn make-exponentiation [base exponent]\n  (list '** base exponent))\n\n(defn base [exp]\n  (second exp))\n\n(defn exponent [exp]\n  (nth exp 2))\n```\n\nBut then we realize that we would like to include the\nsimplification rules, so\n\n```clj\n(defn make-exponentiation [base exponent]\n  (cond (and (number? base)\n             (number? exponent)) (exp base exponent)\n        (= exponent 0) 1\n        (= exponent 1) base\n        :else (list '** base exponent)))\n```"))) "" (data/exercise {} (md {} "Extend the differentiation program to handle sums and products of\narbitrary numbers of (two or more) terms. Then the last example above\ncould be expressed as\n\n```clj\n(deriv '(* x y (+ x 3)) 'x)\n```\n\nTry to do this by changing only the representation for sums and\nproducts without changing the deriv procedure at all. For example,\nthe `addend` of a sum would be the first term, and the `augend` would\nbe the sum of the rest of the terms.\n\nTo do this, it is best to take advantage of our ability to define\nfunctions with mutliple arities.\n\n```clj\n(defn doit\n  ([x y] (+ x y))\n  ([x y z] (* x y z)))\n```\n\nThis function will add its arguments if given two arguments, and\nmultiply them if given three.\n\n```clj\n(defn doit [x y & z]\n  (* x y (reduce + z)))\n```\n\nThis function will add up all arguments after the first two (if there\nare none, it will return 0 for this part). It then returns the\nproduct of that sum and the first two arguments. Play around with\nthis structure for a while to give yourself some familiarity before\nsolving this problem.") "" (data/q-a {} (md {} "```clj\n(defn sum [exp]\n  (= (first exp) '+))\n\n(defn addend [exp]\n  (second exp))\n\n(defn augend [exp]\n  (drop 2 exp))\n\n(defn make-sum\n  ([x y] (cond (= x 0) y\n               (= y 0) x\n               (and (number? x)\n                    (number? y)) (+ x y)\n               :else (list '+ x y)))\n  ([x y & z] (if (empty? z)\n                 (make-sum x y)\n                 (make-sum x\n                           (make-sum y \n                                     (first z) \n                                     & (rest z))))))\n```\n\nThe product version is analogous."))) "" (data/exercise {} (md {} "Suppose we want to modify the differentiation program so that it\nworks with ordinary mathematical notation, in which `+` and `*` are\ninfix rather than prefix operators. Since the differentiation program\nis defined in terms of abstract data, we can modify it to work with\ndifferent representations of expressions solely by changing the\npredicates, selectors, and constructors that define the\nrepresentation of the algebraic expressions on which the\ndifferentiator is to operate.\n\na. Show how to do this in order to differentiate algebraic\nexpressions presented in infix form, such as `(x + (3 * (x + (y +\n2))))`. To simplify the task, assume that `+` and `*` always take two\narguments and that expressions are fully parenthesized.") "" (data/q-a {} (md {} "```clj\n(defn make-sum [x y]\n  (cond (= x 0) y\n        (= y 0) x\n        (and (number? x)\n             (number? y)) (+ x y)\n        :else (list x '+ y)))\n\n(defn addend [exp]\n  (first exp))\n\n(defn augend [exp]\n  (nth exp 2))\n\n(defn sum? [exp]\n  (= (second exp) '+))\n```\n\nThe one for product is analogous.")) "" (md {} "b. The problem becomes substantially harder if we allow standard\nalgebraic notation, such as `(x + 3 * (x + y + 2))`, which drops\nunnecessary parentheses and assumes that multiplication is done\nbefore addition. Can you design appropriate predicates, selectors,\nand constructors for this notation such that our derivative program\nstill works?") "" (data/q-a {} (md {} "This is exactly why 1) prefix notation is so awesome, and 2)\nmacros. But let's try this out without beautiful, beautiful macros.\nThis solution is not a partifularly pretty one, but I'm doing this\none after a VERY long day, so...\n\n```clj\n(defn exponents [expression]\n  (loop [accu (list )\n         left expression]\n    (cond (empty? left) accu\n          (= (second left) '**) (recur accu \n                                       (conj (drop 3 left)\n                                             (make-exponentiation (first left)\n                                                                  (nth left 2))))\n          :else (recur (conj accu (take 2 left))\n                       (drop 2 left)))))\n\n(defn multiplication [expression]\n  (loop [accu (list )\n         left expression]\n    (cond (empty? left) accu\n          (= (second left) '*) (recur accu\n                                      (conj (drop 3 left)\n                                            (make-product (first left)\n                                                          (nth left 2))))\n          :else (recur (conj accu (take 2 left))\n                       (drop 2 left)))))\n\n(defn addition [expression]\n  (loop [accu (list )\n         left expression]\n    (cond (empty? left) accu\n          (= (second left) '+) (recur accu\n                                      (conj (drop 3 left)\n                                            (make-sum (first left)\n                                                      (nth left 2))))\n          :else (recur (conj accu (take 2 left))\n                       (drop 2 left)))))\n\n(defn pemdas [expression]\n  (if (seq? expression) (->> (map pemdas expression)\n                             (exponents)\n                             (multiplication)\n                             (addition))\n      expression))\n```\n\nAfter this, our expression should be in prefix notation with only\ntwo arguments for each operation, so we can use procedures supplied\nin the book. If you are unclear about what I did here (with `->>`)\nlook up Clojure's \"threading macro\" or shoot me an email and I'll\nbe happy to clarify things. Again, I would appreciate hearing\nexactly what is unclear so that I can make this site as clear as\npossible for future readers. So don't be shy! Email me! (My email\naddress is in the footer).")))) "" (data/subsect {:title "Example: Representing Sets"} (md {} "In the previous examples we built representations for two kinds of\ncompound data objects: rational numbers and algebraic expressions. In\none of these examples we had the choice of simplifying (reducing) the\nexpressions at either construction time or selection time, but other\nthan that the choice of a representation for these structures in terms\nof lists was straightforward. When we turn to the representation of\nsets, the choice of a representation is not so obvious. Indeed, there\nare a number of possible representations, and they differ significantly\nfrom one another in several ways.\n\nInformally, a set is simply a collection of distinct objects. To give a\nmore precise definition we can employ the method of data abstraction.\nThat is, we define \"set\" by specifying the operations that are to be\nused on sets. These are `union-set`, `intersection-set`,\n`element-of-set?`, and `adjoin-set`. `Element-of-set?` is a predicate\nthat determines whether a given element is a member of a set.\n`Adjoin-set` takes an object and a set as arguments and returns a set\nthat contains the elements of the original set and also the adjoined\nelement. `Union-set` computes the union of two sets, which is the set\ncontaining each element that appears in either argument.\n`Intersection-set` computes the intersection of two sets, which is the\nset containing only elements that appear in both arguments. From the\nviewpoint of data abstraction, we are free to design any representation\nthat implements these operations in a way consistent with the\ninterpretations given above.")) "" (data/ssub {:title "Sets as Unordered Lists"} (md {} "One way to represent a set is as a list of its elements in which no\nelement appears more than once. The empty set is represented by the\nempty list. In this representation, `element-of-set?` is similar to the\nprocedure `memq` of section 2.3.1.\n\n```clj\n(defn element-of-set? [x set]\n  (loop [things set]\n    (cond (empty? things) false\n          (= x (first things)) true\n          :else  (recur (rest things)))))\n```\n\nUsing this, we can write `adjoin-set`. If the object to be adjoined is\nalready in the set, we just return the set. Otherwise, we use `cons` to\nadd the object to the list that represents the set:\n\n```clj\n(defn adjoin-set [x set]\n  (if (element-of-set? x set)\n      set\n      (conj set x)))\n```\n\nFor `intersection-of-set` we can use a recursive strategy. If we know\nhow to form the intersection of `set2` and the `rest` of `set1`, we\nonly need to decide whether to include the `first` of `set1` in this.\nBut this depends on whether `(first set1)` is also in `set2`. Here is\nthe resulting procedure:\n\n```clj\n(defn intersection-set [set1 set2]\n  (cond (or (empty? set1) (empty? set2)) '()\n        (element-of-set? (first set1) set2)\n          (conj (intersection-set (rest set1) set2)\n                (first set1))\n        :else (intersection-set (rest set1) set2)))\n```\n\nCan you turn this into an iterative procedure using `loop`?") "" (data/q-a {} (md {} "```clj\n(defn intersection-set [set1 set2]\n  (loop [accu   '()\n         things set1]\n    (cond (empty? things) accu\n          (element-of-set? (first things) set2) (recur (conj accu (first things)) (rest things))\n          :else (recur accu (rest things)))))\n```")) "" (md {} "In designing a representation, one of the issues we should be concerned\nwith is efficiency. Consider the number of steps required by our set\noperations. Since they all use `element-of-set?`, the speed of this\noperation has a major impact on the efficiency of the set\nimplementation as a whole. Now, in order to check whether an object is\na member of a set, `element-of-set?` may have to scan the entire set.\n(In the worst case, the object turns out not to be in the set.) Hence,\nif the set has \\\\(n\\\\) elements, `element-of-set?` might take up to\n\\\\(n\\\\) steps. Thus, the number of steps required grows as\n\\\\(\\Theta(n)\\\\). The number of steps required by `adjoin-set`, which\nuses this operation, also grows as \\\\(\\Theta(n)\\\\). For\n`intersection-of-set`, which does an `element-of-set?` check for each\nelement of `set1`, the number of steps required grows as the product of\nthe sizes of the sets involved, or \\\\(\\Theta(n^2)\\\\) for two sets of\nsize \\\\(n\\\\). The same will be true of `union-set`.")) "" (data/exercises {} (data/exercise {} (md {} "Implement the `union-set` operation for the unordered-list\nrepresentation of sets.") "" (data/q-a {} (md {} "```clj\n(defn union-set [set1 set2]\n  (loop [accu   set2\n         things set1]\n    (cond (empty? things) accu\n          (element-of-set? (first things) accu) (recur accu (rest things))\n          :else (recur (conj accu (first things)) (rest things)))))\n```\n\nOr, we could take advantage of the function, `accumulate` we made\nin section 2.2.3\n\n```clj\n(defn union-set [set1 set2]\n  (accumulate #(adjoin-set %1 %2)\n              set1\n              set2))\n```"))) "" (data/exercise {} (md {} "We specified that a set would be represented as a list with no\ndiplicates. Now suppose we allow duplicates. For instance, the set\n\\\\(\\{1,2,3\\}\\\\) could be represented as the list `(2 3 2 1 3 2 2)`.\nDesign procedures `element-of-set?`, `adjoin-set`, `union-set`, and\n`intersection-set` that operation on this representation. How does\nthe efficiency of each compare with the corresponding procedure for\nthe non-duplicate representation? Are there applications for which\nyou would use this representatioin in preference to the non-duplicate\none?") "" (data/q-a {} (md {} "Let's use some of Clojure Core's functions for this. We'll have to\nmake some assumptions about their efficiency (you can look this up\nif you're actually interested).\n\n```clj\n(defn element-of-set? [x set]\n  (loop [things set]\n    (cond (empty? things) false\n          (= (first things) x) true\n          :else (recur (rest things)))))\n\n(defn adjoin-set [x set]\n  (conj set x))\n\n(defn intersection-set [set1 set2]\n  (loop [accu   '()\n         things set1]\n    (cond (empty? things) accu\n          (element-of-set? (first things) set2) (recur (conj accu (first things)) (rest things))\n          :else (recur accu (rest things)))))\n\n(defn union-set [set1 set2]\n  (concat set1 set2))\n```\n\nThis would be a useful representation for client-side computing\n(if we wanted to minimize client-side computation at the cost of\nserver-side computation) where the client can only add things to\nsets, and never remove things (not even in the form of\n`intersection-set`). That way everything is constant time\n\\\\(\\Theta(1)\\\\). For instance, if you wanted to keep a tally of the\nlinks each user clicks while on your site. Since a user cannot\n\"unclick\" a link, we will never have a need for removing items from\nour set (of links clicked for this user). Anything where you need\nto ensure an element is not in this list is going to be costly\n(because we have to use `element-of-set?`).")))) "" (data/ssub {:title "Sets as Ordered Lists"} (md {} "one way to speed up our set operations is to change the representation\nso that the set elements are listed in increasing order. To do this, we\nneed some way to compare two objects so that we can say which is\nbigger. For example, we could compare symbols lexicographically, or we\ncould agree on some method for assigning a unique number to an object\nand then compare the elements by comparing the corresponding numbers.\nTo keep our discussion simple, we will consider only the case where the\nset elements are numbers, so that we can compare elements using\n\\\\(\\gt\\\\) and \\\\(\\lt\\\\). We will represent a set of numbers by listing\nits elements in increasing order. Whereas our first representation\nabove allowed us to represent the set \\\\(\\{1,3,6,10\\}\\\\) by listing the\nelements in any order, our new representation allows only the list `(1\n3 6 10)`.\n\nOne advantage of ordering shows up in element-of-set?: In checking for\nthe presence of an item, we no longer have to scan the entire set. If\nwe reach a set element that is larger than the item we are looking for,\nthen we know that the item is not in the set:\n\n```clj\n(defn element-of-set? [x set]\n  (loop [things set]\n    (cond (= (first things) x) true\n          (> (first things) x) false\n          :else (recur (rest things)))))\n```\n\nHow many steps does this save? In the worst case, the item we are\nlooking for may be the largest one in the set, so the number of steps\nis the same as for the unordered representation. On the other hand, if\nwe search for items of many different sizes we can expect that\nsometimes we will be able to stop searching at a point near the\nbeginning of the list and that other times we will still need to\nexamine most of the list. On the average we should expect to have to\nexamine about half of the items in the set. Thus, the average number of\nsteps required will be about \\\\(n/2\\\\). This is still \\\\(\\Theta(n)\\\\)\ngrowth, but it does save us, on the average, a factor of 2 in number of\nsteps over the previous implementation.\n\nWe obtain a more impressive speedup with `intersection-set`. In the\nunordered representation this operation required \\\\(\\Theta(n^2)\\\\)\nsteps, because we performed a complete scan of `set2` for each element\nof `set1`. But with the ordered representation, we can use a more\nclever method. Begin by comparing the initial elements, `x1` and `x2`,\nof the two sets. If `x1` equals `x2`, then that gives an element of the\nintersection, and the rest of the intersection is the intersection of\nthe `rest` of the two sets.  Suppose, however, that `x1` is less than\n`x2`.  Since `x2` is the smallest element in `set2`, we can immediately\nconclude that `x1` cannot appear anywhere in `set2` and hence is not in\nthe intersection. Hence, the intersection is equal to the intersection\nof `set2` with the `rest` of `set1`.  Similarly, if `x2` is less than\n`x1`, then the intersection is given by the intersection of `set1` with\nthe `rest` of `set2`. Here is the procedure:\n\n```clj\n(defn intersection-set* [set1 set2]\n  (loop [accu    '()\n         things1 set1\n         things2 set2]\n    (if (or (empty? things1) (empty? things2)) accu\n      (let [x1 (first set1)\n            x2 (first set2)]\n        (cond (= x1 x2) (recur (conj accu x1) (rest things1) (rest things2))\n              (< x1 x2) (recur accu (rest things1) things2)\n              (> x1 x2) (recur accu things1 (rest things2)))))))\n\n(defn intersection-set [set1 set2]\n  (reverse (intersection-set* set1 set2)))\n```\n\nTo estimate the number of steps required by this process, observe that\nat each step we reduce the intersection problem to computing\nintersections of smaller sets -- removing the first element from `set1`\nor `set2` or both. Thus, the number of steps required is at most the\nsum of the sizes of `set1` and `set2`, rather than the product of the\nsizes as with the unordered representation. This is \\\\(\\Theta(n)\\\\)\ngrowth rather than \\\\(\\Theta(n^2)\\\\) -- a considerable speedup, even\nfor sets of moderate size.")) "" (data/exercises {} (data/exercise {} (md {} "Give an implementation of `adjoin-set` using the ordered\nrepresentation. By analogy with `element-of-set?` show how to take\nadvantage of the ordering to produce a procedure that requires on\naverage about half as many steps as with the unordered\nrepresentatioin.") "" (data/q-a {} (md {} "```clj\n(defn adjoin-set [x set]\n  (loop [searched  '()\n         searching set]\n    (cond (empty? searching) (reverse (conj searched x))\n          (= x (first searching)) set\n          (< x (first searching)) (recur (conj searched (first searching))\n                                         (rest searching))\n          (> x (first searching)) (concat (reverse searched) (conj searching x))\n          :else (throw (Exception. \"Something went wrong with the adjoin. Try again.\")))))\n```"))) "" (data/exercise {} (md {} "Give a \\\\(\\Theta(n)\\\\) implementation of `union-set` for sets\nrepresented as ordered lists.") "" (data/q-a {} (md {} "```clj\n(defn union-set [set1 set2]\n  (loop [accu    '()\n         things1 set1\n         things2 set2]\n    (let [x1 (first set1)\n          x2 (first set2)]\n      (cond (empty? things2) (concat (reverse accu) (things1))\n            (empty? things1) (concat (reverse accu) (things2))\n            (<= x1 x2) (recur (conj accu x1) (rest things1) things2)\n            (>  x1 x2) (recur (conj accu x2) things1 (rest things2))\n            :else (throw (Exception. \"Something went wrong with the union. Try again.\"))))))\n```")))) "" (data/ssub {:title "Sets as Binary Trees"} (md {} "We can do better than the ordered-list representation by arranging the\nset elements in the form of a tree. Each node of the tree holds one\nelement of the set, called the \"entry\" at that node, and a link to each\nof two other (possibly empty) nodes. The \"left\" link points to elements\nsmaller than the one at the node, and the \"right\" link to elements\ngreater than one at the node. Figure 2.16 shows some trees that\nrepresent the set \\\\(\\{1,3,5,7,9,11\\}\\\\). The same set may be\nrepresented by a tree in a number of different ways. The only thing we\nrequire for valid representation is that all elements in the left\nsubtree be smaller than the node entry and that all elements in the\nright subtree be larger.") "" (data/fig {:footer "Various binary trees represent the set {1,3,5,7,9,11}"}) "" (md {} "The advantage of the tree representation is this: Suppose we want to\ncheck whether a number \\\\(x\\\\) is contained in a set. We begin by\ncomparing \\\\(x\\\\) with the entry in the top node. If \\\\(x\\\\) is less\nthan this, we know that we need only search the left subtree; if\n\\\\(x\\\\) is greater, we need only search the right subtree. Now, if the\ntree is \"balanced,\" each of these subtrees will be about half the size\nof the original. Thus, in one step we have reduced the problem of\nsearching a tree of size \\\\(n\\\\) to searching a tree of size \\\\(n/2\\\\).\nSince the size of the tree is halved at each step, we should expect\nthat the number of steps needed to search a tree of size \\\\(n\\\\) grows\nas \\\\(\\Theta(\\log n)\\\\).<<Halving the size of the problem at each step\nis the distinguishing characteristic of logarithmic growth, as we saw\nwith the fast-exponentiation algorithm of section 1.2.4 and the\nhalf-interval search method of section 1.3.3.>> For large sets, this\nwill be a significant speedup over the previous representations.\n\nWe can represent trees by using lists. Each node will be a list of\nthree items: the entry at the node, the left subtree, and the right\nsubtree. A left or right subtree of the empty list will indicate that\nthere is no subtree connected there. We can describe this\nrepresentation by the following procedure:<<We are representing sets in\nterms of trees, and trees in terms of lists -- in effect, a data\nabstraction built upon a data abstraction. We can regard the procedures\nentry, left-branch, right-branch, and make-tree as a way of isolating\nthe abstraction of a \"binary tree\" from the particular way we might\nwish to represent such a tree in terms of list structure.>>\n\n```clj\n(defn entry [tree]\n  (first tree))\n\n(defn left-branch [tree]\n  (second tree))\n\n(defn right-branch [tree]\n  (nth tree 2))\n\n(defn make-tree [entry left right]\n  (list entry left right))\n```\n\nNow we can write the `element-of-set?` procedure using the strategy\ndescribed above:\n\n```clj\n(defn element-of-set? [x set]\n  (cond (empty? set) false\n        (= x (entry set)) true\n        (< x (entry set)) (element-of-set? x (left-branch set))\n        (> x (entry set)) (element-of-set? x (right-branch set))\n        :else (throw (Exception. \"Something went wrong with element-of-set?\"))))\n```\n\nBut since this involves recursion, we should try to formulate this\nusing `loop` and `recur` as follows:\n\n```clj\n(defn element-of-set? [x set]\n  (loop [things set]\n    (cond (empty? things) false\n          (= x (entry things)) true\n          (< x (entry things)) (recur x (left-branch things))\n          (> x (entry things)) (recur x (right-branch things))\n          :else (throw (Exception. \"Something went wrong with element-of-set?\")))))\n```\n\nAdjoining an item to a set is implemented similarly and also requires\n\\\\(\\Theta(\\log n)\\\\) steps. To adjoin an item \\\\(x\\\\), we compare\n\\\\(x\\\\) with the node entry to determine whether \\\\(x\\\\) should be\nadded to the right or to the left branch, and having adjoined \\\\(x\\\\)\nto the appropriate branch we piece this newly constructed branch\ntogether with the original entry and the other branch. If \\\\(x\\\\) is\nequal to the entry, we just return the node. If we are asked to adjoin\n\\\\(x\\\\) to an empty tree, we generate a tree that has \\\\(x\\\\) as the\nentry and empty right and left branches. Here is the procedure:\n\n```clj\n(defn adjoin-set [x set]\n  (cond (empty? set) (make-tree x '() '())\n        (= x (entry set)) set\n        (< x (entry set)) (make-tree (entry set)\n                                     (adjoin x (left-branch set))\n                                     (right-branch set))\n        (> x (entry set)) (make-tree (entry set)\n                                     (left-branch set)\n                                     (adjoin x (right-branch set)))\n        :else (throw (Exception. \"Something went wrong with adjoin-set\"))))\n```\n\nThe above claim that searching the tree can be performed in a\nlogarithmic number of steps rests on the assumption that the tree is\n\"balanced,\" i.e., that the left and right subtree of every tree have\napproximately the same number of elements, so that each subtree\ncontains about half the elements of its parent. But how can we be\ncertain that the trees we construct will be balanced? Even if we start\nwith a balanced tree, adding elements with `adjoin-set` may produce an\nunbalanced result. Since the position of a newly adjoined element\ndepends on how the element compares with the items already in the set,\nwe can expect that if we add elements \"randomly\" the tree will tend to\nbe balanced on the average (note: in this example, the top level might\nnot be balanced, but as we add more and more elements in this \"random\"\nfashion, we can safely assume that on the average, each level\napproximately halves the number of elements, even if it's not true for\nthe first level in particular). But this is not a guarantee. For\nexample, if we start with an ampty set and adjoin the numbers 1 through\n7 in a sequence we end up with the highly unbalanced tree shown in\nfigure 2.17. In this tree all the left subtrees are empty, so it has no\nadvantage over a simple ordered list. One way to solve this problem is\nto define an operation that transforms an arbitrary tree into a\nbalanced tree with the same elements. Then we can perform this\ntransformation after every few `adjoin-set` operations to keep our set\nin balance. There are also other ways to solve this problem, most of\nwhich involve designing new data structures for which searching and\ninsertion both can be done in \\\\(\\Theta(\\log n)\\\\) setps.<<Examples of\nsuch structures include *B-trees* and *red-black trees*. There is a\nlarge literature on data structures devoted to this problem. See\nCormen, Leiserson, and Rivest 1990.>>") "" (data/fig {:footer "Unbalanced tree produced by adjoining 1 through 7 in sequence."})) "" (data/exercises {} (data/exercise {} (md {} "Each of the following two procedures converts a binary tree to a list.\n\n```clj\n(defn tree->list-1 [tree]\n  (if (empty? tree)\n      '()\n      (concat (tree->list-1 (left-branch tree))\n              (conj (tree->list-1 (right-branch tree))\n                    (entry tree)))))\n\n(defn tree->list-2 [tree]\n  (let [copy-to-list (fn [tree result-list]\n                       (if (empty? tree)\n                           result-list\n                           (copy-to-list (left-branch tree)\n                                         (conj (copy-to-list \n                                                 (right-branch tree)\n                                                 result-list)\n                                               (entry tree)))))]\n    (copy-to-list tree '())))\n```\n\na. Do the two procedures produce the same result for every tree? If\nnot, how do the results differ? What lists do the two procedures\nproduce for the trees in figure 2.16?") "" (data/q-a {} (md {} "Since both procedures put the `entry` in the middle of the \"lesser\"\nelements and the \"greater\" elements, we can be guaranteed that the\nelements of the tree will show up in the same order. It is for that\nreason we also know that each of the trees in figure 2.16 will give\nthe same list with both procedures. Each of them turns this sort of\ntree into an ordered list, so the trees from figure 2.16 would turn\ninto,\n\n```clj\n=> (1 3 5 7 9 11)\n```")) "" (md {} "b. Do the two procedures have the same order of growth in the number\nof steps required to convert a balanced tree with \\\\(n\\\\) elements to\na list? If not, which one grows more slowly?") "" (data/q-a {} (md {} "Since the `concat` function is \\\\(\\Theta(n)\\\\) in terms of steps\nrequired and the length of the first list (the prepending one), we\ncan see that `tree->list-1` is going to take more steps than\n`tree->list-2`. Exactly how many more, we can only estimate (it\ndepends on how balanced the tree is).\n\nIf we assume that the tree is balanced, then every level doubles\nthe number of calls to `concat` but halves the number of elements\nin each `concat`. Hence the number of computations done in an\n`concat` procedure remains constant at \\\\(n\\\\) (roughly) accross\nall levels. Since there are approximately \\\\(\\log n\\\\) levels, we\ncan conclude that the calls to `concat` take \\\\(\\theta(n\\log n)\\\\)\nsteps. If we are to include the calls to `conj` as well, we find\n(through similar reasoning), that the total number of steps should\nbe approximately \\\\(\\Theta(n\\log n+n)=\\Theta(n\\log n)\\\\) steps.\n\nThe second procedure, `tree->list-2`, however, uses `conj` which is\nalways constant time \\\\(\\Theta(1)\\\\) as the main building block,\nwhich really speeds things up for larger trees. As a matter of\nfact, if we notice that `conj` is called approximately once per\nelement, we find that the number of steps required is approximately\n\\\\(\\Theta(n)\\\\). So, to answer the question, `tree->list-2` grows\nmore slowly (which is to say it is faster) than `tree->list-1`."))) "" (data/exercise {} (md {} "The following procedure `list->tree` converts an ordered list to a\nbalanced binary tree. The helper procedure `partial-tree` takes as\narguments an integer \\\\(n\\\\) and list of at least \\\\(n\\\\) elements\nand constructs a balanced tree containing the first \\\\(n\\\\) elements\nof the list. The result returned by `partial-tree` is a pair (formed\nwith `conj`) whose `first` is the constructed tree and whose `rest`\nis the list of elements not included in the tree.\n\n```clj\n(defn list->tree [elements]\n  (first (partial-tree elements (count elements))))\n```\n\nWhere,\n\n```clj\n(defn partial-tree [elts n]\n  (if (= n 0)\n      (conj elts '())\n      (let [left-size      (quotient (dec n) 2)\n            left-result    (partial-tree elts left-size)\n            left-tree      (first left-result)\n            non-left-elts  (rest left-result)\n            right-size     (- n (inc left-size))\n            this-entry     (first non-left-elts)\n            right-result   (partial-tree (rest non-left-elts) right-size)\n            right-tree     (first right-result)\n            remaining-elts (rest right-result)]\n        (conj remaining-elts (make-tree this-entry left-tree right-tree)))))\n```\n\nand we can define `quotient` as,\n\n```clj\n(defn quotient [a b]\n  (/ (- a (mod a b)) b))\n```\n\na. Write a short paragraph explaining as clearly as you can how\n`partial-tree` works. Draw the tree produced by `list->tree` for the\nlist `(1 3 5 7 9 11)`.") "" (data/q-a {} (md {} "For each \\\\(n\\\\), `(partial-tree elts n)` breaks the tree into a\nlist where the first element is a tree of the first \\\\(n\\\\)\nelements, and the rest of the list is the rest of the elements\n(after the first \\\\(n\\\\) are taken out). So in a sense,\n`(partial-tree elts n)` is like `(conj (drop n elts)\ntree-made-from-first-n-elts)`. So, if we define `n` as `(count\nelts)` and `m` as `(quotient (dec n) 2)`, then `(partial-tree elts\nm)` would be a list where the first element is a tree made from the\nfirst \\\\(m\\\\) elements, and the rest of the tree is `(drop m elts)`\n(a list of the remaining elements).\n\nIn our procedure we make use of this fact by using the same\nprocedure again on the remaining elements (hence making the right\nbranch of the tree).")) "" (md {} "b. What is the order of growth in the number of steps required by\n`list->tree` to convert a list of \\\\(n\\\\) elements?") "" (data/q-a {} (md {} "Since `partial-tree` uses only the most efficient list opperations\n(like `conj`, `first`, etc.) which are all constant time, if we\ntemporarily exclude the recursive calls, `partial-tree` is a\nconstant time procedure. Now let's compute how the recursive calls\naffect the order of growth. Note that `partial-tree` is called once\nper element of the list and once or twice for each leaf.\n\nSo, the `list->tree` procedure, which uses `count` (a\n\\\\(\\Theta(n)\\\\) procedure), would be about\n\\\\(\\Theta(2n+number-of-leaves)\\\\) which is \\\\(\\Theta(n)\\\\). So the\nprocedure should have a growth rate of \\\\(\\Theta(n)\\\\)."))) "" (data/exercise {} (md {} "Use the results of exercises 2.63 and 2.64 to give \\\\(\\Theta(n)\\\\)\nimplementations of `unioin-set` and `intersection-set` for sets\nimplemented as (balanced) binary trees.<<Exercises 2.63-2.65 are due\nto Paul Hilfinger.>>") "" (data/q-a {} (md {} "We can use the `intersection-set` and `unioin-set` procedures\ndeveloped for sets as ordered lists.\n\n```clj\n(defn union-set* [set1 set2]\n  (list->tree\n    (union-set (tree->list-2 set1)\n               (tree->list-2 set2))))\n```\n\nAnd similarly,\n\n```clj\n(defn intersection-set* [set1 set2]\n  (list->tree\n    (intersection-set (tree->list-2 set1)\n                      (tree->list-2 set2))))\n```")))) "" (data/ssub {:title "Sets and Information Retrieval"} (md {} "We have examined options for using lists to represent sets and have\nseen how the choice of representation for a data object can have a\nlarge impact on the performance of the programs that use the data.\nAnother reason for concentrating on sets is that the techniques\ndiscussed here appear again and again in applications involving\ninformation retrieval.\n\nConsider a data base containing a large number of individual records,\nsuch as the personnel files for a company or the transactions in an\naccounting system. A typical data-management system spends a large\namount of time accessing or modifying the data in the records and\ntherefore requires an efficient method for accessing records. This is\ndone by identifying a part of each record to serve as an identifying\n*key*. A key can be anything that uniquely identifies the record. For a\npersonnel file, it might be an employee's ID number. For an accounting\nsystem, it might be a transaction number. Whatever the key is, when we\ndefine the record as a data structure we should include a key selector\nprocedure that retrieves the key associated with a given record.\n\nNow we represent the data base as a set of records. To locate the\nrecord with a given key we use a procedure `lookup`, which takes as\narguments a key and a data base and which returns the record that has\nthat key, or `nil` if there is no such record. `Lookup` is implemented\nin almost the same way as `element-of-set?`. For example, if the set of\nrecords is implemented as an unordered list, we could use\n\n```clj\n(defn lookup [given-key set-of-records]\n  (loop [things set-of-records]\n    (cond (empty? things) nil\n          (= given-key (key (first things))) (first things)\n          :else (recur (rest things)))))\n```\n\nOf course, there are better ways to represent large sets than as\nunordered lists. Information-retrieval systems in which records have to\nbe \"randomly accessed\" are typically implemented by a tree-based\nmethod, such as the binary-tree representation discussed previously. In\ndesigning such a system the methodology of data abstraction can be a\ngreat help. The designer can create an initial implementation using a\nsimple, straightforward representation such as unordered lists. This\nwill be unsuitable for the eventual system, but it can be useful in\nproviding a \"quick and dirty\" data base with which to test the rest of\nthe system. Later on, the data representation can be modified to be\nmore sophisticated. If the data base is accessed in terms of abstract\nselectors and constructors, this change in representation will not\nrequire any changes to the rest of the system.")) "" (data/exercises {} (data/exercise {} (md {} "Implement the `lookup` procedure for the case where the set of\nrecords is structured as a binary tree, ordered by the numerical\nvalues of the keys.") "" (data/q-a {} (md {} "For now let's assume that the keys are all integers (so that we can\nuse the ordering that already exists for integers). Before we can\nimplement the `lookup` procedure for binary trees, we need to\ndefine the `key` procedure we see in their definition (which\namounts to defining how key-value pairs are to be stored). One way\nwould be to consider key value pairs to be lists where the first\nelement is the key and the second is the value. So,\n\n```clj\n(defn make-key-val-pair [key val]\n  (list key val))\n(def key first)\n(def val second)\n```\n\nThen,\n\n```clj\n(defn lookup [given-key set-of-records]\n  (loop [things set-of-records]\n    (cond (empty? things) nil\n          (= given-key (key (first things))) (val (first things))\n          (< given-key (key (entry things))) (recur (left-branch things))\n          (> given-key (key (entry things))) (recur (right-branch things))\n          :else (throw (Exception. \"Something went wrong with binary-tree-lookup\")))))\n```")))) "" (data/ssub {:title "Example: Huffman Encoding Trees"} (md {} "This section provides practice in the use of list structure and data\nabstraction to manipulate sets and trees. The application is to methods\nfor representing data as sequences of ones and zeros (bits). For\nexample, the ASCII standard code used to represent text in computers\nencodes each character as a sequence of seven bits. Using seven bits\nallows us to distinguish \\\\(2^7\\\\), or 128, possible different\ncharacters. In general, if we want to distinguish \\\\(n\\\\) different\nsymbols, we will need to use \\\\(log_2 n\\\\) bits per symbol. If all our\nmessages are made up of the eight symbols A, B, C, D, E, F, G, and H,\nwe can choose a code with three bits per character, for example\n\n$$\\begin{array}{llll}\n\\text{A } 000 & \\text{C } 010 & \\text{E } 100 & \\text{G } 110\\\\\\\\\n\\text{B } 001 & \\text{D } 011 & \\text{F } 101 & \\text{H } 111\n\\end{array}$$\n\nwith this code, the message\n\nBACADAEAFABBAAAGAH\n\nis encoded into the string of 54 bits\n\n001000010000011000100000101000001001000000000110000111\n\nCodes such as ASCII and the A-through-H code above are known as\n*fixed-length* codes, because they represent each symbol in the message\nwith the same number of bits. It is sometimes advantageous to use\n*variable-length* codes, in which different symbols may be represented\nby different numbers of bits. For example, Morse code does not use the\nsame number of dots and dashes for each letter of the alphabet. In\nparticular, E, the most frequent letter, is represented by a single\ndot. In general, if our messages are such that some symbols appear very\nfrequently and some very rarely, we can encode data more efficiently\n(i.e., using fewer bits per message) if we assign shorter codes to the\nfrequent symbols. Consider the following alternative code for the\nletters A through H:\n\n$$\\begin{array}{llll}\n\\text{A } 0 & \\text{C } 1010 & \\text{E } 1100 & \\text{G } 1110\\\\\\\\\n\\text{B } 100 & \\text{D } 1011 & \\text{F } 1101 & \\text{H } 1111\n\\end{array}$$\n\nwith this code, the same message as above is encoded as the string\n\n100010100101101100011010100100000111001111\n\nThis string contains 42 bits, so it saves more than 20% in space in\ncomparison with the fixed-length code shown above.\n\nOne of the difficulties of using a variable-length code is knowing when\nyou have reached the end of a symbol in reading a sequence of zeros and\nones. Morse code solves this problem by using a special *separator\ncode* (in this case, a pause) after the sequence of dots and dashes for\neach letter. Another solution is to design the code in such a way that\nno complete code for any symbol is the beginning (or prefix) of the\ncode for another symbol. Such a code is called a *prefix code*. In the\nexample above, A is encoded by 0 and B is encoded by 100, so no other\nsymbol can have a code that begins with 0 or with 100.\n\nIn general, we can attain significant savings if we use variable-length\nprefix codes that take advantage of the relative frequencies of the\nsymbols in the messages to be encoded. One particular scheme for doing\nthis is called the Huffman encoding method, after its discoverer, David\nHuffman. A Huffman code can be represented as a binary tree whose\nleaves are the symbols that are encoded. At each non-leaf node of the\ntree there is a set containing all the symbols in the leaves that lie\nbelow the node. In addition, each symbol at a leaf is assigned a weight\n(which is its relative frequency), and each non-leaf node contains a\nweight that is the sum of all the weights of the leaves lying below it.\nThe weights are not used in the encoding or the decoding process. We\nwill see below how they are used to help construct the tree.") "" (data/fig {:footer "A Huffman encoding tree."}) "" (md {} "Figure 2.18 shows the Huffman tree for the A-through-H code given\nabove. The weights at the leaves indicate that the tree was designed\nfor messages in which A appears with relative frequency 8, B with\nrelative frequency 3, and the other letters each with relative\nfrequency 1.\n\nGiven a Huffman tree, we can find the encoding of any symbol by\nstarting at the root and moving down until we reach the leaf that holds\nthe symbol. Each time we move down a left branch we add a 0 to the\ncode, and each time we move down a right branch we add a 1. (We decide\nwhich branch to follow by testing to see which branch either is the\nleaf node for the symbol or contains the symbol in its set.) For\nexample, starting from the root of the tree in figure 2.18, we arrive\nat the leaf for D by following a right branch, then a left branch, then\na right branch, then a right branch; hence, the code for D is 1011.\n\nTo decode a bit sequence using a Huffman tree, we begin at the root and\nuse the successive zeros and ones of the bit sequence to determine\nwhether to move down the left or the right branch. Each time we come to\na leaf, we have generated a new symbol in the message, at which point\nwe start over from the root of the tree to find the next symbol. For\nexample, suppose we are given the tree above and the sequence 10001010.\nStarting at the root, we move down the right branch, (since the first\nbit of the string is 1), then down the left branch (since the second\nbit is 0), then down the left branch (since the third bit is also 0).\nThis brings us to the leaf for B, so the first symbol of the decoded\nmessage is B. Now we start again at the root, and we make a left move\nbecause the next bit in the string is 0. This brings us to the leaf for\nA. Then we start again at the root with the rest of the string 1010, so\nwe move right, left, right, left and reach C. Thus, the entire message\nis BAC.")) "" (data/ssub {:title "Generating Huffman Trees"} (md {} "Given an \"alphabet\" of symbols and their relative frequencies, how do\nwe construct the \"best\" code? (In other words, which tree will encode\nmessages with the fewest bits?) Huffman gave an algorithm for doing\nthis and showed that the resulting code is indeed the best\nvariable-length code for messages where the relative frequency of the\nsymbols matches the frequencies with which the code was constructed. We\nwill not prove this optimality of Huffman codes here, but we will show\nhow Huffman trees are constructed.<<See Hanning 1980 for a discussion\nof the mathematical properties of Huffman codes.>>\n\nThe algorithm for generating a Huffman tree is very simple. The idea is\nto arrange the tree so that the symbols with the lowest frequency\nappear farthest away from the root. Begin with the set of leaf nodes,\ncontaining symbols and their frequencies, as determined by the initial\ndata from which the code is to be constructed. Now find two leaves with\nthe lowest weights and merge them to produce a node that has these two\nnodes as its left and right branches. The weight of the new node is the\nsum of the two weights. Remove the two leaves from the original set and\nreplace them by this new node. Now continue this process. At each step,\nmerge two nodes with the smallest weights, removing them from the set\nand replacing them with a node that has these two as its left and right\nbranches. The process stops when there is only one node left, which is\nthe root of the entire tree. Here is how the Huffman tree of figure\n2.18 was generated:") "" (table {} (tr {} (td {} "Initial leaves") (td {} "{(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)}")) (tr {} (td {} "Merge   ") (td {} "{(A 8) (B 3) ({C D} 2) (E 1) (F 1) (G 1) (H 1)}")) (tr {} (td {} "Merge ") (td {} "{(A 8) (B 3) ({C D} 2) ({E F} 2) (G 1) (H 1)}")) (tr {} (td {} "Merge") (td {} "{(A 8) (B 3) ({C D} 2) ({E F} 2) ({G H} 2)}")) (tr {} (td {} "Merge") (td {} "{(A 8) (B 3) ({C D} 2) ({E F G H} 4)}")) (tr {} (td {} "Merge") (td {} "{(A 8) ({B C D} 5) ({E F G H} 4)}")) (tr {} (td {} "Merge") (td {} "{(A 8) ({B C D E F G H} 9)}")) (tr {} (td {} "Final merge") (td {} "{({A B C D E F G H} 17)}"))) "" (md {} "The algorithm does not always specify a unique tree, because there may\nnot be unique smallest-weight nodes at each step. Also, the choice of\nthe order in which the two nodes are merged (i.e., which will be the\nright branch and which will be the left branch) is arbitrary.")) "" (data/ssub {:title "Representing Huffman Trees"} (md {} "In the exercises below we will work with a system that uses Huffman\ntrees to encode and decode messages and generates Huffman trees\naccording to the algorithm outlined above. We will begin by discussing\nhow trees are represented.\n\nLeaves of the tree are represented by a list consisting of the symbol\n`leaf`, the symbol at the leaf, and the weight:\n\n```clj\n(defn make-leaf [symbol weight]\n  (list 'leaf symbol weight))\n(defn leaf? [object]\n  (= (first object) 'leaf))\n(defn symbol-leaf [x] (second x))\n(defn weight-leaf [x] (nth x 2))\n```\n\nA general tree will be a list of a left branch, a right branch, a set\nof symbols, and a weight. The set of symbols will be simply a list of\nthe symbols, rather than some more sophisticated set representation.\nWhen we make a tree by merging two nodes, we obtain the weight of the\ntree as the sum of the weights of the nodes, and the set of symbols as\nthe union of the sets of symbols for the nodes. Since our symbol sets\nare represented as lists, we can form the union by using the `concat`\nprocedure we defined in section 2.2.1:\n\n```clj\n(defn make-code-tree [left right]\n  (list left\n        right\n        (concat (symbols left) (symbols right))\n        (+ (weight left) (weight right))))\n```\n\nIf we make a tree in this way, we have the following selectors:\n\n```clj\n(defn left-branch [tree] (first tree))\n\n(defn right-branch [tree] (second tree))\n(defn symbols [tree]\n  (if (leaf? tree)\n      (list (symbol-leaf tree))\n      (nth tree 2)))\n(defn weight [tree]\n  (if (leaf? tree)\n      (weight-leaf tree)\n      (nth tree 3)))\n```\n\nThe procedures `symbols` and `weight` must do something slightly\ndifferent depending on whether they are called with a leaf or a general\ntree. These are simple examples of *generic procedures* (procedures\nthat can handle more than one kind of data), which we will have much\nmore to say about in sections 2.4 and 2.5.")) "" (data/ssub {:title "The Decoding Procedure"} (md {} "The following procedure implements the decoding algorithm. It takes as\narguments a list of zeros and ones, together with a Huffman tree.\n\n```clj\n(defn choose-branch [bit tree]\n  (cond (= bit 0) (left-branch branch)\n        (= bit 1) (right-branch branch)\n        :else (throw (Exception. (str \"Bad bit -- CHOOSE-BRANCH \" bit)))))\n\n(defn decode [decode-bits huffman-tree]\n  (loop [accu '()\n         bits decode-bits\n         tree huffman-tree]\n    (if (empty? bits) (reverse accu)\n      (let [next (choose-branch (first bits) tree)]\n        (if (leaf? next)\n            (recur (conj accu (symbol-leaf next))\n                   (rest bits)\n                   huffman-tree)\n            (recur accu (rest bits) next))))))\n```\n\nThe `loop` in this procedure moves \"down\" the tree, choosing a left or\na right branch according to whether the next bit in the list is a zero\nor a one. (This is done with the procedure `choose-branch`.) When it\nreaches a leaf, it returns the symbol at that leaf as the next symbol\nin the message by `conj`ing it onto the accumulator (`accu`). Note the\nerror check in the final clause of choose-branch, which complains if\nthe procedure finds something other than a zero or a one in the input\ndata.\n\nAs a little supplemental exercise, tweak the `decode` procedure to warn\nthe user if the decoding ends on a node rather than a leaf.") "" (data/q-a {} (md {} "```clj\n(defn decode [decode-bits huffman-tree]\n  (loop [accu '()\n         bits decode-bits\n         tree huffman-tree]\n    (if (empty? bits) \n      (if (= tree huffman-tree)\n          (reverse accu)\n          (do (throw (Exception. \"Error: DECODE ended on a partial code.\"))\n              (reverse accu)))\n      (let [next (choose-branch (first bits) tree)]\n        (if (leaf? next) (recur (conj accu (symbol-leaf next))\n                                (rest bits)\n                                huffman-tree)\n            (recur accu (rest bits) next))))))\n```\n\nBut with that, we notice that we have to determine equality of trees,\nwhich is probably a very taxing procedure. To shorten it, we can\ninstead compare their respective weights. Since we are guaranteed\nthat `tree` will either be `huffman-tree` or a subtree of it, we know\nthat if their respective weights are equal, `tree` must be\n`huffman-tree`. So,\n\n```clj\n(defn decode [decode-bits huffman-tree]\n  (loop [accu '()\n         bits decode-bits\n         tree huffman-tree]\n    (if (empty? bits) \n      (if (= (weight tree) (weight huffman-tree))\n          (reverse accu)\n          (do (throw (Exception. \"Error: DECODE ended on a partial code.\"))\n              (reverse accu)))\n      (let [next (choose-branch (first bits) tree)]\n        (if (leaf? next) (recur (conj accu (symbol-leaf next))\n                                (rest bits)\n                                huffman-tree)\n            (recur accu (rest bits) next))))))\n```"))) "\n" (data/ssub {:title "Sets of Weighted Elements"} (md {} "In our representation of trees, each non-leaf node contains a set of\nsymbols, which we have represented as a simple list. However, the\ntree-generating algorithm discussed above requires that we also work\nwith sets of leaves and trees, successively merging the two smallest\nitems. Since we will be required to repeatedly find the smallest item\nin a set, it is convenient to use an ordered representation for this\nkind of set.\n\nWe will represent a set of leaves and trees as a list of elements,\narranged in increasing order of weight. The following `adjoin-set`\nprocedure for constructing sets is similar to the one described in\nexercise 2.61; however, items are compared by their weights, and the\nelement being added to the set is never already in it.\n\n```clj\n(defn adjoin-set [x set]\n  (cond (empty? set) (list x)\n        (< (weight x) (weight (first set)))\n          (conj set x)\n        :else (conj (adjoin-set x (rest set))\n                    (first set))))\n```;>\n\nNote: If we want our program to deal with large lists, we would have to\nalter our `adjoin-set` procedure so as to avoid stack overflows. Design\na non-recursive version of `adjoin-set`.") "" (data/q-a {} (md {} "```clj\n(defn adjoin-set [x set]\n  (loop [accu   '()\n         things set]\n    (cond (empty? things) (reverse (conj accu x))\n          (< (weight x) (weight (first things)))\n            (concat (reverse accu) (conj things x))\n          :else (recur (conj accu (first things)) (rest things)))))\n```;>")) "" (md {} "The following procedure takes a list of symbol-requency pairs such as\n`((A 4) (B 2) (C 1) (D 1))` and constructs an initial ordered set of\nleaves, ready to be merged according to the Huffman algorithm:\n\n```clj\n(defn make-leaf-set [pairs]\n  (if (empty? pairs)\n      '()\n      (let [pair (first pairs)]\n        (adjoin-set (make-leaf (first pair)   ; symbol\n                               (second pair)) ; frequency\n                    (make-leaf-set (rest pairs))))))\n```")) "" (data/exercises {} (data/exercise {} (md {} "Define an encoding tree and a sample message:\n\n```clj\n(def sample-tree\n  (make-code-tree (make-leaf 'A 4)\n                  (make-code-tree\n                    (make-leaf 'B 2)\n                    (make-code-tree (make-leaf 'D 1)\n                                    (make-leaf 'C 1)))))\n\n(def sample-message\n  '(0 1 1 0 0 1 0 1 0 1 1 1 0))\n```\n\nUse the `decode` procedure to decode the message, and give the result.") "" (data/q-a {} (md {} "```clj\n'(0 1 1 0 0 1 0 1 0 1 1 1 0)\n'(A     D A   B   B     C A)\n```"))) "" (data/exercise {} (md {} "The `encode` procedure takes as arguments a message and a tree and\nproduces the list of bits that gives the encoded message.\n\n```clj\n(defn encode [message tree]\n  (if (empty? message)\n      '()\n      (concat (encode (rest message) tree)\n              (encode-symbol (first message) tree))))\n```\n\n`encode-symbol` is a procedure, which you must write, that returns\nthe list of bits that encodes a given symbol according to a given\ntree. You should design `encode-symbol` so that it signals an error\nif the symbol is not in the tree at all. Test your procedure by\nencoding the result you obtained in exercise 2.67 with the sample\ntree and seeing whether it is the same as the original sample\nmessage.") "" (data/q-a {} (md {} "```clj\n(defn encode-symbol* [symbol tree]\n  (loop [accu   '()\n         things tree]\n    (cond (leaf? things)\n            (reverse accu)\n          (element-of-set? (symbols (left-branch tree)))\n            (recur (conj accu 0) (left-branch tree))\n          :else (recur (conj accu 1) (right-branch tree)))))\n\n(defn encode-symbol [symbol tree]\n  (if (element-of-set? (symbols tree))\n      (encode-symbol* symbol tree)\n      (throw\n        (Exception. \n          (str \"The symbol: \" symbol \"was not recognized. Please remove it and try again.\")))))\n```\n\nThe function `throw` is very important. As you can see, this\nfunction does not simply return a string value if the symbol is not\nin the tree. It throws an exception, which means that it stops all\nfurther computation that the function would call and sends this\nmessage directly to the top. So any function calling\n`encode-symbol` is notified immediately when an error occurs, and\nyou can see the benefit therein.  Note that the function `str`\ntakes any number of arguments and places them in a string in the\nsame order. Test it out using variables and whatnot. It's a very\nuseful function.\n\nHow many arguments does this call to `str` have?") "" (data/q-a {} (md {} "3. \"The symbol: \" is the first, `symbol` is the second, and the\nremaining string is the third.")))) "" (data/exercise {} (md {} "The following procedure takes as its argument a list of\nsymbol-frequency pairs (where no symbol appears in more than one\npair) and generates a Huffman encoding tree according to the Huffman\nalgorithm.\n\n```clj\n(defn generate-huffman-tree [pairs]\n  (successive-merge (make-leaf-set pairs)))\n```\n\n`make-leaf-set` is the procedure given above that transforms the list\nof pairs into an ordered set of leaves. `successive-merge` is the\nprocedure you must write, using `make-code-tree` to successively\nmerge the smallest-weight elements of the set until there is only one\nelement left, which is hte desired Huffman tree. (This procedure is\nslightly tricky, but not really complicated. If you find yourself\ndesigning a complex procedure, then you are almost certainly doing\nsomething wrong. You can take advantage of the fact that we are using\nan ordered set representation.)") "" (data/q-a {} (md {} "```clj\n(defn successive-merge [set]\n  (loop [things set]\n    (let [right (last things)\n          not-r (drop-last things)]\n      (if (empty? not-r)\n          right\n          (let [left   (last not-r)\n                others (drop-last not-r)]\n            (recur \n              (adjoin-set\n                (make-code-tree left right)\n                others)))))))\n```"))) "" (data/exercise {} (md {} "The following eight-symbol alphabet with associated relative\nfrequencies was designed to efficiently encode the lyrics of 1950s\nrock songs. (Note that the \"symbols\" of an \"alphabet\" need not be\nindividual letters.)") "" (table {} (tr {} (td {} "A") (td {} "2") (td {} "NA") (td {} "16")) (tr {} (td {} "BOOM") (td {} "1") (td {} "SHA") (td {} "3")) (tr {} (td {} "GET") (td {} "2") (td {} "YIP") (td {} "9")) (tr {} (td {} "JOB") (td {} "2") (td {} "WAH") (td {} "1"))) "" (md {} "Use `generate-huffman-tree` (exercise 2.69) to generate a\ncorresponding Huffman tree, and use `encode` (exercise 2.68) to\nencode the following message:\n\nGet a job\n\nSha na na na na na na na na\n\nGet a job\n\nSha na na na na na na na na\n\nWah yip yip yip yip yip yip yip yip yip\n\nSha boom\n\nHow many bits are required for the encoding? What is the smallest\nnumber of bits that would be needed to encode this song if we used a\nfixed-length code for the eight-symbol alphabet?") "" (data/q-a {} (md {} "The encoding for this will depend on the order in which the\nelements are given to `make-leaf-set` among other things. As an\nexample, the version of `successive-merge` we used in the previous\nexercise creates a tree with the \"smaller\" weight on the right\nwhich will affect things, as we'll see. The key is all in the map.\nOne acceptable code might be:\n\n00011000100010\n\n000011111111\n\n00011000100010\n\n000011111111\n\n00111010101010101010101\n\n000000110\n\nThere are a total of 5 bits required for this encoding. We would\nneed 3 bits if it were a fixed-length encdoding. The reason why we\nwould need 3 bits is, \\\\(2^3=8\\\\) and there are 8 symbols."))) "" (data/exercise {} (md {} "Suppose we have a Huffman tree for an alphabet of \\\\(n\\\\) symbols,\nand that the relative frequencies of the symbols are \\\\(1, 2, 4, ...,\n2^{n-1}\\\\). Sketch the tree for \\\\(n=5\\\\); for \\\\(n=10\\\\). In such a\ntree (for general \\\\(n\\\\)) how many bits are required to encode the\nmost frequent symbol? the least frequent?") "" (data/q-a {} (md {} "Due to some technical difficulties (read \"I really want to get\nthrough this section already\") I wion't be including the drawings.\nIf you would like them, please feel free to contact me and let me\nknow!\n\nAs for the frequencies: the most frequent symbol will need only one\nbit. The reason for this is that the frequency of that symbol is\ngreater than or equal to the sum of the frequencies of all the\nother symbols. So it will only be combined at the very end of the\ncombination process.\n\nAssuming that there are at least 2 elements in the tree, the least\nfrequent symbol will require \\\\(n-1\\\\) bits to encode. The reason\nfor this one is a bit more complicated, but at every step, the\npartial tree containing the least frequent symbol has the least\nweight, so it is combined. Since only two things can be combined at\na time, we see that the partial tree containing the least frequent\nelement must be combined with a leaf at every stage. So we can\nreduce our problem to the problem of \"how many leaves are there\nthat can be combined with this leaf containing the least frequent\nsymbol?\" The answer to that is clearly \\\\(n-1\\\\) because there are\n\\\\(n\\\\) leaves."))) "" (data/exercise {} (md {} "Consider the encoding procedure that you designed in exercise 2.68.\nWhat is the order of growth in the number of steps needed to encode a\nsymbol? Be sure to include the number of steps needed to search the\nsymbol list at each node encountered. To answer this question in\ngeneral is difficult. Consider the special case where the relative\nfrequencies of the \\\\(n\\\\) symbols are as described in exercise 2.71,\nand give the order of growth (as a function of \\\\(n\\\\)) of the number\nof steps needed to encode the most frequent and least frequent\nsymbols in the alphabet.") "" (data/q-a {} (md {} "We first note that the most expensive operations in this procedure\nis the search through the list at each level, and the `reverse` at\nthe end. The `reverse` is \\\\(\\Theta(m)\\\\) where \\\\(m\\\\) is the\nlength of the code, and the search is \\\\(\\Theta(k)\\\\) where \\\\(k\\\\)\nis the length of the left branch at the current stage.\n\nSince our sets are ordered by frequency (with the most frequent in\nfront), and the most frequent symbol is encoded as a single bit\neach time (due to the distribution given in exercise 2.71), we know\nthat the very first left branch will be the leaf containing the\nmost frequent symbol. Also, since the code is only a single bit,\nthe `reverse` procedure can be done in constant time as well.\nHence we can encode the most frequent symbol in constant time, so\n\\\\(\\Theta(1)\\\\).\n\nTo encode the least fequent symbol, we would have to traverse the\nlists all the way down to the end, but each time the left branch\nhas only one element in it, so the traversing would be\n\\\\(\\Theta(1)+\\Theta(1)+...+\\Theta(1)\\\\). The length of the code\nwill be the number of symbols in the list (i.e. \\\\(n\\\\)). So our\norder of growth should be\n\n$$\\begin{align*}\n&\\Theta(n)+\\underbrace{\\Theta(1)+\\Theta(1)+...+\\Theta(1)}_{n-1\\text{ times}}\n\\\\\\\\=&\\Theta(n)\n\\end{align*}$$"))))))
