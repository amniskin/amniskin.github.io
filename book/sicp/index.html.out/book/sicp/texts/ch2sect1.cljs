(ns book.sicp.texts.ch2sect1 (:require [tailrecursion.hoplon.markdown :as md] [book.sicp.book-data :as data] [tailrecursion.hoplon :refer [form audio input hgroup do! timeout $text base h1 embed h3 body keygen on-append! progress main cite on-page-load object i p nav ruby check-val! a menu blockquote img $comment span track seq?* data u dl select html thead del eventsource append-child fieldset aside figure figcaption sentinel q on! bdi video address caption parse-args dd rp hr tbody table acronym frame applet html-var add-initfn! pre ul dir html-time add-attributes! html-map sup dfn sub mark script big button wbr strong li dt frameset td tr section th optgroup iframe legend em kbd spliced article isindex abbr command <!-- source output basefont route-cell header datalist tfoot s ins footer title is-ie8 h5 canvas param font div option summary samp center small style textarea loop-tpl* strike h4 tt head add-children! ol details col vector?* label rt when-dom h6 link page-load colgroup meter html-meta text-val! bdo --> b code node? noframes replace-children! noscript safe-nth h2 area br]] [tailrecursion.javelin :refer [input? cell cell? destroy-cell! ^{:private true} last-rank ^{:deprecated true} lift lens? set-formula! cell-doseq* ^{:dynamic true, :private true} *tx* deref* set-cell! lens formula? alts! dosync* cell-map formula]]) (:require-macros [tailrecursion.hoplon.markdown :refer [md]] [tailrecursion.hoplon :refer [text with-timeout sexp defelem def-values with-page-load with-dom loop-tpl with-interval with-init!]] [tailrecursion.javelin :refer [with-let mx2 dosync cell= set-cell!= prop-cell cell-doseq defc cell-let-1 defc= macroexpand-all mx cell-let]]))

(sexp {} "defelem content [_ _]" (div {} (data/sect {:title "Introduction to Data Abstraction"} (md {} "In [section 1.1.8](#!/sicp/ch/1/sect/1/sub/8/), we noted that a\nprocedure used as an element in creating a more complex procedure could\nbe regarded not only as a collection of particular operations but also\nas a procedural abstraction. That is, the details of how the procedure\nwas implemented could be suppressed, and the particular procedure\nitself could be replaced by any other procedure with the same overall\nbehavior. In other words, we could make an abstraction that would\nseparate the way the procedure would be used from the details of how\nthe procedure would be implemented in terms of more primitive\nprocedures. The analogous notion for compound data is called *data\nabstraction*. Data abstraction is a methodology that enables us to\nisolate how a compound data object is used from the details of how it\nis constructed from more primitive data objects.\n\nThe basic idea of data abstraction is to structure the programs that\nare to use compound data objects so that they operate on \"abstract\ndata.\" That is, our programs should use data in such a way as to make\nno assumptions about the data that are not strictly necessary for\nperforming the task at hand. At the same time, a \"concrete\" data\nrepresentation is defined independent of the programs that use the\ndata. The interface between these two parts of our system will be a set\nof procedures, called *selectors* and *constructors*, that implement\nthe abstract data in terms of the concrete representation. To\nillustrate this technique, we will consider how to design a set of\nprocedures for manipulating rational numbers.")) "" (data/subsect {:title "Example: Arithmetic Operations for Rational Numbers"} (md {} "Suppose we want to do arithmetic with rational numbers. We want to be\nable to add, subtract, multiply, and divide them and to test whether\ntwo rational numbers are equal.\n\nLet us begin by assuming that we already have a way of constructing a\nrational number from a numerator and a denominator. We also assume\nthat, given a rational number, we have a way of extracting (or\nselecting) its numerator and its denominator. Let us further assume\nthat the constructor and selectors are available as procedures:\n\n- `(make-rat <n> <d>)` returns the rational number whose numerator is\nthe integer `<n>` and whose denominator is the integer `<d>`.  -\n`(numer <x>)` returns the numerator of the rational number `<x>`.\n- `(denom <x>)` returns the denominator of the rational number `<x>`.\n\nWe are using here a powerful strategy of synthesis: *wishful thinking*.\nWe haven't yet said how a rational number is represented, or how the\nprocedures `numer`, `denom`, and `make-rat` should be implemented. Even\nso, if we did have these three procedures, we could then add, subtract,\nmultiply, divide, and test equality by using the following relations:\n\n$$\\begin{align*}\n\\frac{n_1}{d_1}+\\frac{n_2}{d_2}=&\\frac{n_1d_2+n_2d_1}{d_1d_2}\n\\\\\\\\\\frac{n_1}{d_1}-\\frac{n_2}{d_2}=&\\frac{n_1d_2-n_2d_1}{d_1d_2}\n\\\\\\\\\\frac{n_1}{d_1}\\cdot\\frac{n_2}{d_2}=&\\frac{n_1n_2}{d_1d_2}\n\\\\\\\\\\frac{n_1}{d_1}/\\frac{n_2}{d_2}=&\\frac{n_1d_2}{n_2d_1}\n\\\\\\\\\\frac{n_1}{d_1}=\\frac{n_2}{d_2}\\iff& n_1d_2=n_2d_1\\end{align*}$$\n\nWe can express these rules as procedures:\n\n```clj\n(defn add-rat [x y]\n  (make-rat (+ (* (numer x) (* denom y))\n               (* (numer y) (* denom x)))\n            (* (denom x) (denom y))))\n(defn sub-rat [x y]\n  (make-rat (- (* (numer x) (* denom y))\n               (* (numer y) (* denom x)))\n            (* (denom x) (denom y))))\n(defn mul-rat [x y]\n  (make-rat (* (numer x) (numer y))\n            (* (denom x) (denom y))))\n(defn div-rat [x y]\n  (make-rat (* (numer x) (denom y))\n            (* (denom x) (numer y))))\n(defn equal-rat? [x y]\n  (= (* (numer x) (denom y))\n     (* (numer y) (denom x))))\n```\n\nNow we have the operations on rational numbers defined in terms of the\nselector and constructor procedures `numer`, `denom`, and `make-rat`.\nBut we haven't yet defined these. What we need is some way to glue\ntogether a numerator and a denominator to form a rational number.")) "" (data/ssub {:title "Pairs (or Lists, for Us)"} (md {} "To enable us to implement the concrete level of our data abstraction,\nour language provides a compound structure abstraction called a\n*sequential object*. These sequential objects are really just anything\nthat has a concept of a *first* item and a *rest* of the items. Hence,\na sequential object is any object which allows use of the `first` and\n`rest` protocols (kind of like procedures, except their actual\nexecution may be different from data type to data type). One example of\na sequential object -- the one we will be using instead of the \"pairs\"\nthey use for this section in Scheme -- is called a *list*. Lists can be\nconstructed via the procedure `list` like so `(list 1 2 3)` gives you a\nlist containing 1, 2, and 3 as its elements. So `(first (list 1 2 3))`\nwould return `1`, and `(rest (list 1 2 3))` returns `(2 3)`, which is\nto say the list containing 2 and 3 as its elements. To check if what\nwe've been given is indeed a list, we can use the procedure `list?`\nlike so: `(list? (rest (list 1 2 3)))`. Lists are actually made via\npairs (as will be described later in this section), but all of that is\nunder the hood. Lists can also be constructed from old lists with the\nprocedure `conj`.<<We should note that since these lists are immutable,\nthe only way to \"edit\" a list would be to create a new one with the\ndesired changes and then destroy the old one.  While this may seem\nunfortunate at first, it is actually quite a desireable feature when\ndealing with concurrency.>> This procedure takes two or more arguments,\na sequential object and any number of values to append to the\nsequential object, then returns a sequential object of the same type\nwith the values appended in whatever method appropriate to that\nsequential object in the order they appear. We will see later that\nlists are constructed in such a way that prepending is very cheap, so\n`conj` does exactly that. Hence, `(conj (list 1 2 3) 4)` returns `(4 1\n2 3)`, and `(conj (list 1 2 3) 4 5)` returns `(5 4 1 2 3)` (remember\nthat they are prepended in the order they appear!).\n\nIn Scheme, however, their building block is the *pair*, wich can be\nconstructed via the primitive procedure `cons` (which also works in\nClojure... kinda) and has procedures `car` and `cdr` for obtaining the\nfirst and second values of the pair respectively.<<The name `cons`\nstands for \"construct.\" The names `car` and `cdr` derive from the\noriginal implementation of Lisp on the IBM 704. That machine had an\naddressing scheme that allowed one to reference the \"address\" and\n\"decrement\" parts of a memory location. `car` stands for \"Contents of\nAddress part of Register\" and `cdr` (pronounced \"could-er\") stands for\n\"Contents of Decrement part of Register.\">> Thus, we in Scheme, we\nwould be able to use `cons`, `car`, and `cdr` as follows: \n\n```scm\n(define x (cons 1 2))\n```\n\nGo ahead and try this in Clojure (can you translate that?)") "" (data/q-a {} "```clj\n(def x (cons 1 2))\n```") "" (md {} "If you tried the previous example. you probably got an error. That is\nbecause Clojure implements `cons` differently. If we try \n\n```clj\n(def x (cons 1 (cons 2 nil)))\n```\n\nThen we shouldn't get any errors. The reason is that the second\nargument of `cons` must be sequential object (or `nil`). Either way, we\nwill not be using `cons` for our discourse in this chapter, but rather\nthe procedures `list` and `conj`, which are more general anyway. Along\nwith `first` and `rest`, lists also have `second` and `nth` which give\nyou exactly what you'd expect, the second and the nth values in the\nlist. So,\n\n```clj\n(def x (list 1 2))\n(first x)\n1\n(second x)\n2\n```\n\nNotice that a list is a data object that can be given a name and\nmanipulated, just like a primitive data object. Moreover, `list` can be\nused to form pairs whose elements are pairs, and so on:\n\n```clj\n(def x (list 1 (list 2 nil)))\n(def y (list 3 (list 4 nil)))\n(def z (list x y))\n\n(first (first z))\n1\n(first (second z))\n3\n```\n\nIn [section 2.2](#!/sicp/ch/2/sect/2/) we will see how this ability to\ncombine pairs means that pairs can be used as general-purpose building\nblocks to create all sorts of complex data structures. The single\ncompound-data primitive *pair*, implemented in Scheme by the procedures\n`cons`, `car`, and `cdr`, is the only glue we need. Data objects\nconstructed from pairs are called *list-structured* data. In fact, we\nwill explore how lists are acutally implemented in Clojure and we will\nsee that it is very similar to Scheme in that respect. For now, let's\npretend like our `list`s are really pairs (for the purposes of learning\nthe lessons meant to be learned in the following sections).")) "" (data/ssub {:title "Representing Rational Numbers"} (md {} "Pairs offer a natural way to complete the rational-number system.\nSimply represent a rational number as a pair of two integers: a\nnumerator and a denominator. Then `make-rat`, `numer`, and `denom` are\nreadily implemented as follows:<<Another way to define the selectors\nand constructor is `(define make-rat cons)` `(define numer car)`\n`(define denom cdr)` The first definition associates the name\n`make-rat` with the value of the expression `cons`, which is the\nprimitive procedure that constructs pairs. Thus `make-rat` and `cons`\nare names for the same primitive constructor. Defining selectors and\nconstructors this way is efficient: Instead of `make-rat` *calling*\n`cons`, `make-rat` *is* `cons`, so there is only one procedure called,\nnot two, when `make-rat` is called. On the other hand, doing this\ndefeats debugging aids that trace procedure calls or put breakpoints on\nprocedure calls: You may want to watch `make-rat` being called, but you\ncertainly don not want to watch every call to `cons`.>>\n\n```scm\n(define (make-rat n d) (list n d))\n(define (numer x) (first x))\n(define (denom x) (second x))\n```\n\nAlso, in order to display the results of our computations, we can print\nrational numbers by printing the numerator, a slash, and the\ndenominator.<<Note that `print` and `println` (there are others but we\nneed not go into them right now) return values. Being as how the values\nare not currently of use to us, we show only what these functions print\nand not what the interpreter prints as the returned values.>>\n\n```clj\n(defn print-rat [x]\n  (println (numer x) \"/\" (denom x)))\n```\n\nNote that `println` is a function that takes any number of arguments,\nconverts them to a string, prints them to the screen followed by a new\nline, then it returns the value `nil` (remember, everything has a value\nin Lisp!).\n\nNow we can try our rational-number procedures:\n\n```clj\n(def one-half (make-rat 1 2))\n(print-rat one-half)\n1/2\n\n(def one-third (make-rat 1 3))\n(print-rat (add-rat one-half one-third))\n5/6\n\n(print-rat (mul-rat one-half one-third))\n1/6\n\n(print-rat (add-rat one-third one-third))\n6/9\n```\n\nAs the final example shows, our rational-number implementation does not\nreduce rational numbers to lowest terms. We can rememdy this by\nchanging `make-rat`. If we have a `gcd` procedure like the one used in\n[section 1.2.5](#!/sicp/ch/1/sect/2/sub/5/) that produces the greatest\ncommon divisor of two integers, we can use `gcd` to reduce the\nnumerator and the denominator to lowest terms before constructing the\npair:\n\n```clj\n(defn make-rat [n d]\n  (let [g (gcd n d)]\n    (list (/ n g) (/ d g))))\n```\n\nNow we have,\n\n```clj\n(print-rat (add-rat one-third one-third))\n2/3\n```\nas desired. This modification was accomplished by changing the\nconstructor `make-rat` without changing any of the procedures (such as\n`add-rat` and `mul-rat`) that implement the actual operations.")) "" (data/exercises {} (data/exercise {} (md {} "Define a better version of `make-rat` that handles both positive and\nnegative arguments. `make-rat` should normalize the sign so that if\nthe rational number is positive, both the numerator and denominator\nare positive, and if the rational number is negative, only the\nnumerator is negative.") "" (data/q-a {} (md {} "```clj\n(defn make-rat [n d]\n  (let [doit #(let [g (gcd %1 %2)]\n                (list (/ %1 g) (/ %2 g)))]\n    (if (> (* n d) 0)\n        (doit (Math/abs n) (Math/abs d))\n        (doit (- (Math/abs n)) (Math/abs d)))))\n```")))) "" (data/subsect {:title "Abstraction Barriers"} (md {} "Before continuing with more examples of compound data and data\nabstraction, let us consider some of the issues raised by the\nrational-number example. We defined the rational-number operations in\nterms of a constructor `make-rat` and selectors `numer` and `denom`. In\ngeneral, the underlying idea of data abstraction is to identify for\neach type of data object the basic set of operations in terms of which\nall manipulations op data objects of that type will be expressed, and\nthen to use only those operations in manipulating the data.\n\nWe can envision the structure of the rational-number system as shown in\n[figure 2.1](#!/sicp/ch/2/fig/1/). The horizontal lines represent\n*abstraction barriers* that isolate different \"levels\" of the system.\nAt each level, the barrier separates the programs (above) that use th\nedata abstraction from the programs (below) that implement the data\nabstraction. Programs that use rational numbers manipulate them solely\nin terms of the procedures supplied \"for public use\" by the\nrational-number package: `add-rat`, `sub-rat`, `mul-rat`, `div-rat`,\n`numer`, and `denom`, which themselves are implemented in terms of\nlists. The details of how lists are implemented are irrelevant to the\nrest of the rational-number package so long as lists can be manipulated\nby the use of `list`, `first`, and `second`. In effect, procedures at\neach level are the interfaces that define the abstraction barriers and\nconnect the different levels.") "" (data/fig {:footer "Data-abstraction barriers in the rational-number package."}) "" (md {} "This simple idea has many advantages. One advantage is that it makes\nprograms much easier to maintain and modify. Any complex data structure\ncan be represented in a variety of ways within primitive data\nstructures provided by a programming language. Of course, the choice of\nrepresentation influences the programs that operate on it; thus, if the\nrepresentation were to be changed at some later time, all such programs\nmight have to be modified accordingly. This task could be\ntime-consuming and expensive in the vase of large programs unless the\ndependence on the representation were to be confined by design to a\nvery few program modules.\n\nFor example, an alternate way to address the problem of reducing\nrational numbers to lowest terms is to perform the reduction whenever\nwe acces the parts of a rational number, rather than when we construct\nit. This leads to different constructor and selector procedures:\n\n```clj\n(defn make-rat [n d]\n  (list n d))\n(defn numer [x]\n  (let [g (gcd (first x) (second x))]\n    (/ (first x) g)))\n(defn denom [x]\n  (let [g (gcd (first x) (second x))]\n    (/ (second x) g)))\n```\n\nThe difference between this implementation and the previous one lies in\nwhen we compute the `gcd`. If in our typical use of rational numbers we\naccess the numerators and denominators of the same rational numbers\nmany times, it would be preferable to compute the `gcd` when the\nrational numbers are constructed. If not, we may be better off waiting\nuntil access time to compute the `gcd`. In any case, when we change\nfrom one representation to the other, the procedures `add-rat`,\n`sub-rat` and so on do not have to be modified at all.\n\nConstraining the dependence on the representation to a few interface\nprocedures helps us design programs as well as modify them, because it\nallows us to maintain the flexibility to consider alternate\nimplementations. To continue with our simple example, suppose we are\ndesigning a rational-number package and we can't decide initially\nwhether to perform the `gcd` at construction time or at selection time.\nThe data-abstraction methodology gives us a way to defer that decision\nwithout losing the ability to make progress on the rest of the system.")) "" (data/exercises {} (data/exercise {} (md {} "Consider the problem of representing line segments in a plane. Each\nsegment is represented as a pair of points: a starting point and an\nending point. Define a constructor `make-segment` and selectors\n`start-segment` and `end-segment` that define the representation of\nsegments in terms of points. Furthermore, a point can be represented\nas a pair of numbers: the \\\\(x\\\\) coordinate and the \\\\(y\\\\)\ncoordinate. Accordingly, specify a constructor `make-point` and\nselectors `x-point` and `y-point` that define this representation.\nFinally, using your selectors and constructors, define a procedure\n`midpoint-segment` that takes a line segment as argument and returns\nits midpoint (the point whose coordinates are the average of the\ncoordinates of the endpoints). To try your procedures, you'll need a\nway to print points:\n\n```clj\n(defn print-point [p]\n  (println \"(\" (x-point p) \",\" (y-point p) \")\"))\n```") "" (data/q-a {} (md {} "```clj\n(defn make-point [x y]\n  (list x y))\n(defn x-point [p]\n  (first p))\n(defn y-point [p]\n  (second p))\n(defn make-segment [p q]\n  (list p q))\n(defn start-segment [l]\n  (first l))\n(defn end-segment [l]\n  (second l))\n```\n\nOnce we have those,\n\n```clj\n(defn midpoint-segment [l]\n  (let [p  (start-segment l)\n        q  (end-segment l)\n        x1 (x-point p)\n        y1 (y-point p)\n        x2 (x-point q)\n        y2 (y-point q)]\n    (make-point (average x1 x2) (average y1 y2))))\n```"))) "" (data/exercise {} (md {} "Implement a representation for rectangles in a plane. (Hint: you may\nwant to make use of [exercise 2.2](#!/sicp/ch/2/ex/2/) In terms of\nyour constructors and selectors, create procedures that compute the\nperimeter and the area of a given rectangle. Now implement a\ndifferent representation for rectangles. Can you design your system\nwith suitable abstraction barriers, so that the same perimeter and\narea procedures will work using either representation?") "" (data/q-a {} (md {} "Assuming we are given coordinates of an actual rectangle (so that\nwe don't have to use the Pythagorean theorem or some other method\nto confirm that the points are what they claim to be), will\nsimplify our lives considerably. Since any rectangle is determined\nby three of its vertices, we can assume that we are given three\nsequentially adjacent vertices.\n\n```clj\n(defn make-rectangle [a b c]\n  (list a b c))\n```\n\nThen, we realize that in order to compute the area and perimeter,\nwe need to know the length and width of the rectangle. So, let's\nwrite a separate procedure to do that. But before we do that, it\nmight be a good idea to have a procedure that can find the length\nof a segment (we could do without this procedure, but it seems like\na useful procedure to have if we are to be working with segments,\nso why not allow ourselves this tool?).\n\n```clj\n(defn length-segment [l]\n  (let [p  (start-segment l)\n        q  (end-segment l)\n        x1 (x-point p)\n        y1 (y-point p)\n        x2 (x-point q)\n        y2 (y-point q)]\n    (Math/sqrt (+ (square (- x1 x2))\n                  (square (- y1 y2))))))\n```\n\nGood, now we can move on. I'm not sure if it would be useful to\ndefine a global procedure to get the sides of a rectangle as\nline-segments, but if it gets in the way, we can use a `let`\nbinding instead. For now, let's define it globally.\n\n```clj\n(defn side1-rectangle [r]\n  (make-segment (first r) (second r)))\n(defn side2-rectangle [r]\n  (make-segment (second r) (nth r 2)))\n```\n\nNow we're ready to make our area and perimeter procedures.\n\n```clj\n(defn area-rectangle [r]\n  (* (length-segment (side1-rectangle r))\n     (length-segment (side2-rectangle r))))\n(defn perimeter-rectangle [r]\n  (* 2 (+ (length-segment (side1-rectangle r))\n          (length-segment (side2-rectangle r)))))\n```\n\nNow, if our implementation for rectangles were something different,\nlike:\n\n```clj\n(defn make-rectangle [a b c]\n  (list (list a b) (list b c)))\n```\n\nIn this representation, we're defining rectangles by their sides\nrather than by their vertices. Let's see how things must change.\n\n```clj\n(defn side1-rectangle [r]\n  (first r))\n(defn side2-rectangle [r]\n  (second r))\n```\n\nThen everything else works just fine.\n\nNote: if we wanted to check to make sure that the points were in\nfact vertices of a rectangle, we could just add an `if` statement\nto our definition of `make-rectangle` such that if it passes the\nPythagorean test \n\n```clj\n(= (square (diagonal-rectangle r)) \n   (+ (square (side1-rectangle r)) \n      (square (side2-rectangle r))))\n```\n\nWhere `diagonal-rectangle` would be defined in the necessary way to\nget what should be the diagonal of the rectangle.")))) "" (data/subsect {:title "What is Meant by Data?"} (md {} "We began the rational-number implementation in [section\n2.1.1](#!/sicp/ch/2/sect/1/sub/1/) by implementing the rational-number\noperations `add-rat`, `sub-rat`, and so on in terms of three\nunspecified procedures: `make-rat`, `numer`, and `denom`. At that\npoint, we could think of the operations as being defined in terms of\ndata objects -- numerators, denominators, and rational numbers -- whose\nbehavior was specified by the latter three procedures.\n\nBut exactly what is meant by *data*? It is not enough to say \"whatever\nis implemented by the given selectors and constructors.\" Clearly, not\nevery arbitrary set of three procedures can serve as an appropriate\nbasis for the rational-number implementation. We need to guarantee\nthat, if we construct a rational number `x` from a pair of integers `n`\nand `d`, then extracting the `numer` and the `denom` of `x` and\ndividing them should yield the same result as dividing `n` by `d`. In\nother words, `make-rat`, `numer`, and `denom` must satisfy the\ncondition that, for any integer `n` and any non-zero integer `d`, if\n`x` is `(make-rat n d)`, then\n\n$$\\frac{\\text{(numer x)}}{\\text{(denom x)}}=\\frac{\\text{n}}{\\text{d}}$$\n\nIn fact, this is the only condition `make-rat`, `numer` and `denom`\nmust fulfill in order to form a suitable basis for a rational-number\nrepresentation. In general, we can think of data as defined by some\ncollection of selectors and constructors, together with specified\nconditions that these procedures must fulfill in order to be a valid\nrepresentation.<<Surprisingly, this idea is very difficult to formulate\nrigorously. There are two approaches to giving such a formulation. One,\npioneered by C. A. R. Hoare (1972), is known as the method of *abstract\nmodels*. It formalizes the \"procedures plus conditions\" specification\nas outlined in the rational-number example above. Note that the\ncondition on the rational-number representation was stated in terms of\nfacts about integers (equality and division). In general, abstract\nmodels define new kinds of data objects in terms of previously defined\ntypes of data objects. Assertions about data objects can therefore be\nchecked by reducing them to assertions about previously defined data\nobjects. Another approach, introduced by Zilles at MIT, by Goguen,\nThatcher, Wagner, and Wright at IBM (see Thatcher, Wagner, and Wright\n1978), and by Guttag at Toronto (see Guttag 1977), is called *algebraic\nspecification*. It regards the \"procedures\" as elements of an abstract\nalgebraic system whose behavior is specified by axioms that correspond\nto our \"conditions,\" and uses the techniques of abstract algebra to\ncheck assertions about data objects. Both methods are surveyed in the\npaper by Liskov and Zilles (1975).>>\n\nThis point of view can serve to define not only \"high-level\" data\nobjects, such as rational numbers, but lower-level objects as well.\nConsider the notion of a list or a pair (a list of two elements), which\nwe used in order to define our rational numbers. We never actually said\nwhat these were, only that the language supplied procedures `list`,\n`first`, and `second` for operating on them. But the only thing we need\nto know about these three operations is that if we glue two objects\ntogether using `cons` or `list`, we can retrieve the objects using\n`first`, `rest`, `second` and `nth`. That is, the operations satisfy\nthe condition that, for any objects `x` and `y`, if `z` is `(list x y)`\nthen `(first z)` is `x` and `(second z)` is `y`. Indeed, we mentioned\nthat these three procedures are included as primitives in our language.\nHowever, any triple of procedures that satisfies the above condition\ncan be used as the basis for implementing pairs. This point is\nillustrated strikingly by the fact that we could implement `cons`,\n`first`, and `second` for lists without using any data structures at\nall but only using procedures. Here are the definitions:\n\n```clj\n(defn cons [x y]\n  (let [dispatch (fn [m] (cond (= m 0) x\n                               (= m 1) y\n                               :else (throw (Exception. \"Argument not 0 or 1 -- CONS\" m))))]\n    dispatch))\n\n(defn car [x] (z 0))\n\n(defn cdr [x] (z 1))\n```\n\nIn the above definitions I used `cons`, `car`, and `cdr` instead of\n`list`, `first`, and `second` simply because I like to not deviate from\nthe book whenever possible and it doesn't necessarily add anything to\ndeviate. On the down side (of deviating from the text), this\nconstruction would not work if we used lists because lists can have any\nnumber of elements so we'd have to use other methods to make it work.\nWe digress...\n\nThis use of procedures corresponds to nothing like our intuitive notion\nof what data should be. Nevertheless, all we need to do to show that\nthis is a valid way to represent pairs is to verify that these\nprocedures satisfy the condition given above.\n\nThe subtle point to notice is that the value returned by `(cons x y)`\nis a procedure -- namely the internally defined procedure `dispatch`,\nwhich takes one argument and returns either `x` or `y` depending on\nwhether the argument is 0 or 1. Correspondingly, `(car z)` is defined\nto apply `z` to 0. Hence, if `z` is the procedure formed by `(cons x\ny)`, then `z` applied to 0 will yield `x`. Thus, we have shown that\n`(car (cons x y))` yields `x`, as desired. Similarly, `(cdr (cons x\ny))` applies the procedure returned by `(cons x y)` to 1, which returns\n`y`. Therefore, this procedural implementation of pairs is a valid\nimplementation, and if we access pairs using only `cons`, `car`, and\n`cdr` we cannot distinguish this implementation from one that uses\n\"real\" data structures.\n\nThe point of exhibiting the procedural representation of pairs is not\nthat our language works this way (Scheme, and Lisp systems in general,\nimplement pairs directly, and Clojure implements lists directly as Java\nobjects, for efficiency reasons) but that it could work this way. The\nprocedural representation, although obscure, is a perfectly adequate\nway to represent pairs, since it fulfills the only conditions that\npairs need to fulfill. This example also demonstrates that the ability\nto manipulate procedures as objects automatically provides the ability\nto represent compound data. This may seem a curiosity now, but\nprocedural representations of data will play a central role in our\nprogramming repertoire. This style of programming is often called\nmessage passing, and we will be using it as a basic tool in chapter 3\nwhen we address the issues of modeling and simulation.")) "" (data/exercises {} (data/exercise {} (md {} "Here is an alternative procedural representation of pairs. For this\nrepresentation, verify that (car (cons x y)) yields x for any objects\nx and y.\n\n```clj\n(defn cons [x y]\n  (fn [m] (m x y)))\n(defn car [z]\n  (z (fn [p q] p)))\n```\n\nWhat is the corresponding definition of `cdr`? (Hint: To verify that\nths works, make use of the substitution model of [section\n1.1.5](#!/sicp/ch/1/sect/1/sub/5/).)") "" (data/q-a {} (md {} "```clj\n(defn cdr [z]\n  (z (fn [p q] q)))\n```"))) "" (data/exercise {} (md {} "Show that we can represent pairs of nonnegative integers using only\nnumbers and arithmetic operations if we represent the pair \\\\(a\\\\)\nand \\\\(b\\\\) as the integer that is the product \\\\(2^a3^b\\\\).  Give\nthe corresponding definitions of the procedures `cons`, `car`, and\n`cdr`.") "" (data/q-a {} (md {} "```clj\n(defn cons [x y]\n  (* (exp 2 x) (exp 2 y)))\n(defn car [z]\n  (loop [a    z\n         accu 0]\n    (if (= (mod a 2) 0)\n        (recur (/ a 2) (inc accu))\n        accu)))\n(defn cdr [z]\n  (loop [a    z\n         accu 0]\n    (if (= (mod a 3) 0)\n        (recur (/ a 3) (inc accu))\n        accu)))\n```"))) "" (data/exercise {} (md {} "In case representing pairs as procedures wasn't mind-boggling enough,\nconsider that, in a language that can manipulate procedures, we can\nget by without numbers (at least insofar as nonnegative integers are\nconcerned) by implementing 0 and the operation of adding 1 as\n\n```clj\n(def zero (fn [f] (fn [x] x)))\n(defn add-1 [n]\n  (fn [f] (fn [x] (f ((n f) x)))))\n```\n\nThis representation is known as *Church numerals*, after its\ninventor, Alanzo Church, the logician who invented the λ calculus.\n\nDefine `one` and `two` directly (not in terms of `zero` and `add-1`).\n(Hint: Use substitution to evaluate `(add-1 zero)`). Give a direct\ndefinition of the addition procedure + (not in terms of repeated\napplication of `add-1`).") "" (data/q-a {} (md {} "```clj\n(def one\n  (fn [f] (fn [x] (f x))))\n(def two\n  (fn [f] (fn [x] (f (f x)))))\n```\n\nAs for addition, first let's build up a some functions to make this\neasier to reason about.\n\n```clj\n(defn compose [f g]\n  (fn [x] (f (g x))))\n```\n\nWith that, we can now define\n\n```clj\n(defn add [a b]\n  (fn [f]\n    (compose (a f) (b f))))\n```")))) "" (data/subsect {:title "Extended Exercise: Interval Arithmetic"} (md {} "Alyssa P. Hacker is designing a system to help people solve engineering\nproblems. One feature she wants to provide in her system is the ability\nto manipulate inexact quantities (such as measured parameters of\nphysical devices) with known precision, so that when computations are\ndone with such approximate quantities the results will be numbers of\nknown precision.\n\nElectrical engineers will be using Alyssa's system to compute\nelectrical quantities. It is sometimes necessary for them to compute\nthe value of a parallel equivalent resistance \\\\(R_p\\\\) of two\nresistors \\\\(R_1\\\\) and \\\\(R_2\\\\) using the formula\n\n$$R_p=\\frac{1}{1/R_1+1/R_2}$$\n\nResistance values are usually known only up to some tolerance\nguaranteed by the manufacturer of the resistor. For example, if you buy\na resistor labeled \"6.8 ohms with 10% tolerance\" you can only be sure\nthat the resistor has a resistance between 6.8 - 0.68 = 6.12 and 6.8 +\n0.68 = 7.48 ohms. Thus, if you have a 6.8-ohm 10% resistor in parallel\nwith a 4.7-ohm 5% resistor, the resistance of the combination can range\nfrom about 2.58 ohms (if the two resistors are at the lower bounds) to\nabout 2.97 ohms (if the two resistors are at the upper bounds).\n\nAlyssa's idea is to implement \"interval arithmetic\" as a set of\narithmetic operations for combining \"intervals\" (objects that represent\nthe range of possible values of an inexact quantity). The result of\nadding, subtracting, multiplying, or dividing two intervals is itself\nan interval, representing the range of the result.\n\nAlyssa postulates the existence of an abstract object called an\n\"interval\" that has two endpoints: a lower bound and an upper bound.\nShe also presumes that, given the endpoints of an interval, she can\nconstruct the interval using the data constructor `make-interval`.\nAlyssa first writes a procedure for adding two intervals. She reasons\nthat the minimum value the sum could be is the sum of the two lower\nbounds and the maximum value it could be is the sum of the two upper\nbounds:\n\n```clj\n(defn add-interval [x y]\n  (make-interval (+ (lower-bound x) (lower-bound y))\n                 (+ (upper-bound x) (upper-bound y))))\n```\n\nAlyssa also works out the product of two intervals by finding the\nminimum and the maximum of the products of the bounds and using them as\nbounds of the resulting interval. (`min` and `max` are primitives that\nfind the minimum and maximum of any number of arguments.)\n\n```clj\n(defn mul-interval [x y]\n  (let [p1 (* (lower-bound x) (lower-bound y))\n        p2 (* (lower-bound x) (upper-bound y))\n        p3 (* (upper-bound x) (lower-bound y))\n        p4 (* (upper-bound x) (upper-bound y))]\n    (make-interval (min p1 p2 p3 p4)\n                   (max p1 p2 p3 p4))))\n```\n\nTo divide two intervals, Alyssa multiplies the first by the reciprocal\nof the second. Note that the bounds of the reciprocal interval are the\nreciprocal of the upper-bound and the reciprocal of the lower-bound, in\nthat order.\n\n```clj\n(defn div-interval [x y]\n  (mul-interval x\n                (make-interval (/ 1.0 (upper-bound y))\n                               (/ 1.0 (lower-bound y)))))\n```")) "" (data/exercises {} (data/exercise {} (md {} "Alyssa's program is incomplete because she has not specified the\nimplementation of the interval abstraction. Here is a definition of\nthe interval constructor:\n\n```clj\n(defn make-interval [a b]\n  (list a b))\n```\n\nDefine selectors `upper-bound` and `lower-bound` to complete the\nimplementation.") "" (data/q-a {} (md {} "```clj\n(defn upper-bound [z]\n  (second z))\n(defn lower-bound [z]\n  (first z))\n```"))) "" (data/exercise {} (md {} "Using reasoning analogous to Alyssa's, describe how the difference of\ntwo intervals may be computed. Define a corresponding subtraction\nprocedure, called `sub-interval`.") "" (data/q-a {} (md {} "Using reasoning analogous to Alyssa's, we'd define `sub-interval`\nas:\n\n```clj\n(defn sub-interval [a b]\n  (make-interval (- (lower-bound a) (upper-bound b))\n                 (- (upper-bound a) (lower-bound b))))\n```"))) "" (data/exercise {} (md {} "The *width* of an interval is half of the difference between its\nupper and lower bounds. The width is a measure of the uncertainty of\nthe number specified by the interval. For some arithmetic operations\nthe width of the result of combining two intervals is a function only\nof the widths of the argument intervals. Show that the width of the\nsum (or difference) of two intervals is a function only of the widths\nof the intervals being added (or subtracted). Give examples to show\nthat this is not true for multiplication or division.") "" (data/q-a {} (md {} "Let's define two intervals \\\\(x=(a-\\delta,a+\\delta)\\\\), and\n\\\\(y=(b-\\epsilon,b+\\epsilon)\\\\), where \\\\(\\delta,\\epsilon\\\\) are\npositive real numbers (and hence the width of their respective\nintervals). Then, the interval `(add-interval x y)` would be\n\\\\((a+b-(\\epsilon+delta),a+b+(\\epsilon+\\delta))\\\\), making the\nwidth of the sum equal to the sum of the widths.\n\nSimilarly, `(sub-interval a b)` would be,\n\n$$(a-\\delta - (b+\\epsilon),a+\\epsilon-(b-\\epsilon))=(a-b-(\\delta+\\epsilon),a-b+(\\delta-\\epsilon))$$\n  \n  making the width of the difference of intervals equal to the\n  difference of the widths of the intervals.\n\nFor multiplication, however, things are not as simple. Let's\nconsider two pairs of intervals, each pair with the same\ncorresponding widths:\n\n$$a=(0,2), b=(0,2) c=(5,7) d=(5,7)$$\n\nSince these intervals all have the same width, if the width of the\nproduct is a function of the widths of the intervals, then the\nproduct of any two of these intervals should yield an interval with\nthe same width. But this is clearly not this case because `(width\n(mul-interval a b))` is 2, but `(width (mul-interval c d))` is 12.\nSo clearly the width of the product is not a function of the widths\nalone.\n\nAs for division, we can define \\\\(a,b=(1,2)\\\\), and\n\\\\(c,d=\\\\((5,6)\\\\). Then, `(div-interval a b)` is \\\\((1/2, 2)\\\\),\nbut `(div-interval c d)` is \\\\((5/6,6/5)\\\\). The width of the first\nis 0.75 or 3/4, but the width of the second is 11/60."))) "" (data/exercise {} (md {} "Ben Bitdiddle, an expert systems programmer, looks over Alyssa's\nshoulder and comments that it is not clear what it means to divide by\nan interval that spans zero. Modify Alyssa's code to check for this\ncondition and to signal an error if it occurs.") "" (data/q-a {} (md {} "```clj\n(defn div-interval [a b]\n  (let [span-zero? #(> 0\n                       (* (lower-bound %)\n                          (upper-bound %)))]\n    (if (span-zero? b)\n        (throw (Exception. \"Can't divide by zero!\"))\n        (mul-interval a\n                      (make-interval (/ 1.0 (upper-bound b))\n                                     (/ 1.0 (lower-bound b)))))))\n```"))) "" (data/exercise {} (md {} "In passing, Ben also cryptically comments: \"By testing the signs of\nthe endpoints of the intervals, it is possible to break mul-interval\ninto nine cases, only one of which requires more than two\nmultiplications.\" Rewrite this procedure using Ben's suggestion.") "" (data/q-a {} (md {} "```clj\n(defn mul-interval [a b]\n  (cond (> (lower-bound a) 0)\n        (cond (> (lower-bound b) 0)\n              (make-interval (* (lower-bound a)\n                                (lower-bound b))\n                             (* (upper-bound a)\n                                (upper-bound b)))\n              (> 0 (upper-bound b))\n              (make-interval (* (upper-bound a)\n                                (lower-bound b))\n                             (* (lower-bound a)\n                                (upper-bound b)))\n              :else \n              (make-interval (* (upper-bound a)\n                                (lower-bound b))\n                             (* (upper-bound a)\n                                (upper-bound b))))\n        (> 0 (upper-bound a))\n        (cond (> (lower-bound b) 0)\n              (make-interval (* (lower-bound a)\n                                (upper-bound b))\n                             (* (upper-bound a)\n                                (lower-bound b)))\n              (> 0 (upper-bound b))\n              (make-interval (* (upper-bound a)\n                                (upper-bound b))\n                             (* (lower-bound a)\n                                (lower-bound b)))\n              :else \n              (make-interval (* (lower-bound a)\n                                (upper-bound b))\n                             (* (lower-bound a)\n                                (lower-bound b))))\n        :else\n        (cond (> (lower-bound b) 0)\n              (make-interval (* (lower-bound a)\n                                (upper-bound b))\n                             (* (upper-bound a)\n                                (upper-bound b)))\n              (> 0 (upper-bound b))\n              (make-interval (* (upper-bound a)\n                                (lower-bound b))\n                             (* (lower-bound a)\n                                (lower-bound b)))\n              :else \n              (let [w (* (lower-bound a)\n                         (upper-bound b))\n                    x (* (lower-bound a)\n                         (lower-bound b))\n                    y (* (upper-bound a)\n                         (upper-bound b))\n                    z (* (upper-bound a)\n                         (lower-bound b))]\n                (make-interval (min w x y z)\n                               (max w x y z))))))\n```")) "" (md {} "After debugging her program, Alyssa shows it to a potential user, who\ncomplains that her program solves the wrong problem. He wants a\nprogram that can deal with numbers represented as a center value and\nan additive tolerance; for example, he wants to work with intervals\nsuch as 3.5± 0.15 rather than [3.35, 3.65]. Alyssa returns to her\ndesk and fixes this problem by supplying an alternate constructor and\nalternate selectors:\n\n```clj\n(defn make-center-width [c w]\n  (make-interval (- c w) (+ c w)))\n(defn center [i]\n  (/ (+ (lower-bound i) (upper-bound i)) 2))\n(defn width [i]\n  (/ (- (upper-bound i) (lower-bound i)) 2))\n```\n\nUnfortunately, most of Alyssa's users are engineers. Real engineering\nsituations usually involve measurements with only a small\nuncertainty, measured as the ratio of the width of the interval to\nthe midpoint of the interval. Engineers usually specify percentage\ntolerances on the parameters of devices, as in the resistor\nspecifications given earlier.")) "" (data/exercise {} (md {} "Define a constructor `make-center-percent` that takes a center and a\npercentage tolerance and produces the desired interval. You must also\ndefine a selector `percent` that produces the percentage tolerance\nfor a given interval. The `center` selector is the same as the one\nabove.") "" (data/q-a {} (md {} "```clj\n(defn make-center-percent [c p]\n  (let [width (* c p)]\n    (make-interval (- c width) (+ c width))))\n(defn percent [i]\n  (/ (width i) (center i)))\n```"))) "" (data/exercise {} (md {} "Show that under the assumption of small percentage tolerances there\nis a simple formula for the approximate percentage tolerance of the\nproduct of two intervals in terms of the tolerances of the factors.\nYou may simplify the problem by assuming that all numbers are\npositive.") "" (data/q-a {} (md {} "Let's take two intervals, \\\\((a-\\epsilon,a+\\epsilon)\\\\) and\n\\\\((b-\\delta,b+\\delta)\\\\), where \\\\(a,b\\\\) and\n\\\\(\\epsilon,\\delta\\\\) are positive numbers and\n\\\\(\\epsilon,\\delta\\\\) are small. Then, the product is given by,\n\n$$\\begin{align*}&\\left((a-\\epsilon)(b-\\delta),(a+\\epsilon)(b+\\delta)\\right)\n\\\\\\\\=&\\left(ab-a\\delta-b\\epsilon+\\epsilon\\delta,ab+a\\delta+b\\epsilon+\\epsilon\\delta\\right)\n\\\\\\\\=&\\left((ab+\\epsilon\\delta)-(a\\delta+b\\epsilon),(ab+\\epsilon\\delta)+(a\\delta+b\\epsilon)\\right)\\end{align*}$$\n\nSo, we see that the width in question is, \\\\(a\\delta+b\\epsilon\\\\),\nand the center is \\\\(ab+\\epsilon\\delta\\\\). Hence, the percentage\ntolerance is,\n\n$$\\begin{align*}\n\\frac{a\\delta+b\\epsilon}{ab+\\epsilon\\delta}\\approx& \\frac{a\\delta\n+b\\epsilon}{ab+0} \\\\\\\\=&\\frac{a\\delta+b\\epsilon}{ab}\n\\\\\\\\=&\\frac{\\delta}{b}+\\frac{\\epsilon}{a}\\end{align*}$$\n\nWhich is the sum of the respective percentages.\n\nSo, as long as the percentages are small enough for their squares\nto become negligible, the percentage tolerance of a product of\nintervals is sum of the percentage tolerances of the two respective\nintervals.")) "" (md {} "After considerable work, Alyssa P. Hacker delivers her finished\nsystem. Several years later, after she has forgotten all about it,\nshe gets a frenzied call from an irate user, Lem E. Tweakit. It seems\nthat Lem has noticed that the formula for parallel resistors can be\nwritten in two algebraically equivalent ways:\n\n$$\\frac{R_1R_2}{R_1+R_2}$$\n\nand\n\n$$\\frac{1}{1/R_1+1/R_2}$$\n\nHe has written the following two programs, each of which computes the\nparallel-resistors formula differently:\n\n```clj\n(defn par1 [r1 r2]\n  (div-interval (mul-interval r1 r2)\n                (add-interval r1 r2)))\n(defn par2 [r1 r2]\n  (let [one (make-interval 1 1)]\n    (div-interval one\n                  (add-interval (div-interval one r1)\n                                (div-interval one r2)))))\n```\n\nLem complains that Alyssa's program gives different answers for the\ntwo ways of computing. This is a serious complaint.")) "" (data/exercise {} (md {} "Demonstrate that Lem is right. Investigate the behavior of the system\non a variety of arithmetic expressions. Make some intervals A and B,\nand use them in computing the expressions A/A and A/B. You will get\nthe most insight by using intervals whose width is a small percentage\nof the center value. Examine the results of the computation in\ncenter-percent form (see [exercise 2.12](#!/sicp/ch/2/ex/12/)).") "" (data/q-a {} (md {} "If we define \\\\(A=(29.9,30.1)\\\\), and \\\\(B=(49.9,51.1)\\\\), what\nhappens when we divide \\\\(A\\\\) by itself? \\\\(B\\\\) by itself?\n\\\\(A\\\\) by \\\\(B\\\\)? \\\\(B\\\\) by \\\\(A\\\\)?"))) "" (data/exercise {} (md {} "Eva Lu Ator, another user, has also noticed the different intervals\ncomputed by different but algebraically equivalent expressions. She\nsays that a formula to compute with intervals using Alyssa's system\nwill produce tighter error bounds if it can be written in such a form\nthat no variable that represents an uncertain number is repeated.\nThus, she says, `par2` is a \"better\" program for parallel resistances\nthan `par1`. Is she right? Why?") "" (data/q-a {} (md {} "She is correct. The reason is, if we write an equation,\n\\\\(\\frac{x+1}{x}\\\\), for instance, the assumption is that both\n\\\\(x\\\\)s in the equation have the same value. If we do this with\nthe interval arithmetic we've defined here, that is not necessarily\ntrue. ie, if we define \\\\(A=(2,4)\\\\) then compute the above formula\nusing our interval arithmetic assuming that \\\\(x\\\\) is in the\ninterval \\\\(A\\\\), we get\n\n$$\\begin{align*}\n\\frac{A+1}{A}=&\\frac{(3,5)}{(2.4)}\n\\end{align*}$$\n\nwhich is another way of saying, \"the interval obtained by taking\nany number between 3 and 5 and dividing it by another number\nbetween 2 and 4.\" But then, 3/4, for instance, would be in that\ninterval by letting the numerator be 3 and the denominator be 4.\nBut the problem is, if the numerator is to be 4, then \\\\(x=2\\\\),\nwhich means the denominator would be 2 as well.\n\nThe issue we're arriving at is that different instances of the same\nvariable can have different values (if we use our current system of\ninterval arithmetic)."))) "" (data/exercise {} (md {} "Explain, in general, why equivalent algebraic expressions may lead to\ndifferent answers. Can you devise an interval-arithmetic package that\ndoes not have this shortcoming, or is this task impossible? (Warning:\nThis problem is very difficult.)") "" (data/q-a {} (md {} "I guess this would depend on what we mean by \"equivalent\". Already\ndue to what we've seen in [exercise 2.15](#!/sicp/ch/1/ex/15/),\nvery strange things happen algebraically. For instance, our\ninterval arithmetic does not have the distributive property. To\nshow this, just observe that the distributive property states,\n\\\\(A(B+C)=AB+AC\\\\), but since \\\\(A\\\\) appears twice on the right\nhand side and there are no repeated variables on the left, by the\nprevious exercise we know that the left hand side must have\n\"tighter error bounds\". Hence the two sides cannot be equal unless\nthere is no error in \\\\(A\\\\) (in which case \\\\(A\\\\) is not an\ninterval, but a number).\n\nSo, I'm not too sure if this is possible, but when would we use\nthis? If it is an engineering (or scientific) concern, then we are\nnot really interested in intervals, but rather statistical\nprobabilities, in which case we can use some theorems about error\npropagation to achieve our goal."))))))
