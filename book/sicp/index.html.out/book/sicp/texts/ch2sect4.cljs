(ns book.sicp.texts.ch2sect4 (:require [tailrecursion.hoplon.markdown :as md] [book.sicp.book-data :as data] [tailrecursion.hoplon :refer [form audio input hgroup do! timeout $text base h1 embed h3 body keygen on-append! progress main cite on-page-load object i p nav ruby check-val! a menu blockquote img $comment span track seq?* data u dl select html thead del eventsource append-child fieldset aside figure figcaption sentinel q on! bdi video address caption parse-args dd rp hr tbody table acronym frame applet html-var add-initfn! pre ul dir html-time add-attributes! html-map sup dfn sub mark script big button wbr strong li dt frameset td tr section th optgroup iframe legend em kbd spliced article isindex abbr command <!-- source output basefont route-cell header datalist tfoot s ins footer title is-ie8 h5 canvas param font div option summary samp center small style textarea loop-tpl* strike h4 tt head add-children! ol details col vector?* label rt when-dom h6 link page-load colgroup meter html-meta text-val! bdo --> b code node? noframes replace-children! noscript safe-nth h2 area br]] [tailrecursion.javelin :refer [input? cell cell? destroy-cell! ^{:private true} last-rank ^{:deprecated true} lift lens? set-formula! cell-doseq* ^{:dynamic true, :private true} *tx* deref* set-cell! lens formula? alts! dosync* cell-map formula]]) (:require-macros [tailrecursion.hoplon.markdown :refer [md]] [tailrecursion.hoplon :refer [text with-timeout sexp defelem def-values with-page-load with-dom loop-tpl with-interval with-init!]] [tailrecursion.javelin :refer [with-let mx2 dosync cell= set-cell!= prop-cell cell-doseq defc cell-let-1 defc= macroexpand-all mx cell-let]]))

(sexp {} "defelem content [_ _]" (div {} (data/sect {:title "Multiple Representations for Abstract Data"} (md {} "We have introduced data abstraction, a methodology for structuring\nsystems in such a way that much of a program can be specified\nindependent of the choices involved in implementing the data objects\nthat the program manipulates. For example, we saw in section 2.1.1 how\nto separate the task of designing a program that uses rational numbers\nfrom the task of implementing rational numbers in terms of the computer\nlanguage's primitive mechanisms for constructing compound data. The key\nidea was to erect an abstraction barrier -- in this case, the selectors\nand constructors for rational numbers (`make-rat`, `numer`, `denom`) --\nthat isolates the way rational numbers are used from their underlying\nrepresentation in terms of list structure. A similar abstraction\nbarrier isolates the details of the procedures that perform rational\narithmetic (`add-rat`, `sub-rat`, `mul-rat`, and `div-rat`) from the\n\"higher-level\" procedures that use rational numbers. The resulting\nprogram has the structure shown in figure 2.1.\n\nThese data-abstraction barriers are powerful tools for controlling\ncomplexity. By isolating the underlying representations of data\nobjects, we can divide the task of designing a large program into\nsmaller tasks that can be performed separately. But this kind of data\nabstraction is not yet powerful enough, because it may not always make\nsense to speak of \"the underlying representation\" for a data object.\n\nFor one thing, there might be more than one useful representation for a\ndata object, and we might like to design systems that can deal with\nmultiple representations. To take a simple example, complex numbers may\nbe represented in two almost equivalent ways: in rectangular form (real\nand imaginary parts) and in polar form (magnitude and angle). Sometimes\nrectangular form is more appropriate and sometimes polar form is more\nappropriate. Indeed, it is perfectly plausible to imagine a system in\nwhich complex numbers are represented in both ways, and in which the\nprocedures for manipulating complex numbers work with either\nrepresentation.\n\nMore importantly, programming systems are often designed by many people\nworking over extended periods of time, subject to requirements that\nchange over time. In such an environment, it is simply not possible for\neveryone to agree in advance on choices of data representation. So in\naddition to the data-abstraction barriers that isolate representation\nfrom use, we need abstraction barriers that isolate different design\nchoices from each other and permit different choices to coexist in a\nsingle program. Furthermore, since large programs are often created by\ncombining pre-existing modules that were designed in isolation, we need\nconventions that permit programmers to incorporate modules into larger\nsystems additively, that is, without having to redesign or reimplement\nthese modules.\n\nIn this section, we will learn how to cope with data that may be\nrepresented in different ways by different parts of a program. This\nrequires constructing *generic procedures* -- procedures that can\noperate on data that may be represented in more than one way. Our main\ntechnique for building generic procedures will be to work in terms of\ndata objects that have *type tags*, that is, data objects that include\nexplicit information about how they are to be processed. We will also\ndiscuss *data-directed* programming, a powerful and convenient\nimplementation strategy for additively assembling systems with generic\noperations.\n\nWe begin with the simple complex-number example. We will see how type\ntags and data-directed style enable us to design separate rectangular\nand polar representations for complex numbers while maintaining the\nnotion of an abstract \"complex-number\" data object. We will accomplish\nthis by defining arithmetic procedures for complex numbers\n(`add-complex`, `sub-complex`, `mul-complex`, and `div-complex`) in\nterms of generic selectors that access parts of a complex number\nindependent of how the number is represented. The resulting\ncomplex-number system, as shown in figure 2.19, contains two different\nkinds of abstraction barriers. The \"horizontal\" abstraction barriers\nplay the same role as the ones in figure 2.1. They isolate\n\"higher-level\" operations from \"lower-level\" representations. In\naddition, there is a \"vertical\" barrier that gives us the ability to\nseparately design and install alternative representations.") "" (data/fig {:footer "Data-abstraction barriers in the complex-number system."}) "" (md {} "In section 2.5 we will show how to use type tags and data-directed\nstyle to develope a generic arithmetic package. This provides\nprocedures (`add`,`mul`, and so on) that can be used to manipulate all\nsorts of \"numbers\" and can be easily extended when a new kind of number\nis needed. In section 2.5.3, we'll show how to use generic arithmetic\nin a system that performs symbolic algebra.")) "" (data/subsect {:title "Representations for Complex Numbers"} (md {} "We will develope a system that performs arithmetic operations on\ncomplex numbers as a simple but unrealistic example of a program that\nuses generic operations. We begin by discussing two plausible\nrepresentations for complex numbers as ordered pairs: rectangular form\n(real part and imaginary part) and polar form (magnitude and\nangle).<<In actual computational systems, rectangular form is\npreferable to polar form most of the time because of roundoff errors in\nconversion between rectangular and polar form. This is why the\ncomplex-number example is unrealistic. Nevertheless, it provides a\nclear illustration of the design of a system using generic operations\nand a good introduction to the more substantial systems to be developed\nlater in this chapter.>> Section 2.4.2 will show how both\nrepresentations can be made to coexist in a single system through the\nuse of type tags and generic operations.\n\nLike rational numbers, complex numbers are naturally represented as\nordered pairs. The set of complex numbers can be thought of as a\ntwo-dimensional space with two orthogonal axes, the \"real\" axis and the\n\"imaginary\" axis. (See figure 2.20.) From this point of view, the\ncomplex number \\\\(z=x+iy\\\\) (where \\\\(i^2=-1\\\\)) can be thought of as\nthe point in the plane whose real coordinate is \\\\(x\\\\) and whose\nimaginary coordinate is \\\\(y\\\\). Addition of complex numbers reduces in\nthis representation to addition of coordinates:\n\n$$\\text{Real-part }(z_1+z_2)=\\text{Real-part }(z_1)+\\text{Real-part }(z_2)\n\\\\\\\\\\text{Imaginary-part }(z_1+z_2) = \\text{Imaginary-part }(z_1)+\\text{Imaginary-part }(z_2)$$\n\nWhen multiplying complex numbers, it is more natural to think in terms\nof representing a complex number in polar form, as a magnitude and an\nangle (\\\\(r\\\\) and \\\\(A\\\\) in figure 2.20). The product of two complex\nnumbers is the vector obtained by stretching one complex number by the\nlength of the other and then rotating it through the angle of the\nother:\n\n$$\\text{Magnitude }(z_1\\cdot z_2)= \\text{Magnitude }(z_1)\\cdot\\text{Magnitude }(z_2)\n\\\\\\\\\\text{Angle }(z_1\\cdot z_2)=\\text{Angle }(z_1)+\\text{Angle }(z_2)$$\n\nThus, there are two different representations for complex numbers,\nwhich are appropriate for different operations. Yet, from the viewpoint\nof someone writing a program that uses complex numbers, the principle\nof data abstraction suggests that all the operations for manipulating\ncomplex numbers should be available regardless of which representation\nis used by the computer. For example, it is often useful to be able to\nfind the magnitude of a complex number that is specified by rectangular\ncoordinates. Similarly, it is often useful to be able to determine the\nreal part of a complex number that is specified by polar coordinates.") "\n" (data/fig {:footer "Complex numbers as points in the plane."}) "" (md {} "To design such a system, we can follow the same data-abstraction\nstrategy we followed in designing the rational-number package in\nsection 2.1.1. Assume that the operations on complex numbers are\nimplemented in terms of four selectors: `real-part`, `imag-part`,\n`magnitude`, and `angle`. Also assume that we have two procedures for\nconstructing complex numbers: `make-from-real-imag` which returns a\ncomplex number with the specified real and imaginary parts, and\n`make-from-mag-ang` which returns a complex number with the specified\nmagnitude and angle. These procedures have the property that, for any\ncomplex number \\\\(z\\\\), both\n\n```clj\n(make-from-real-imag (real-part z) (imag-part z))\n```\n\nand \n```clj\n(make-from-mag-ang (magnitude z) (angle z))\n```\n\nproduce complex numbers that are equal to \\\\(z\\\\).\n\nUsing these constructors and selectors, we can implement arithmetic on\ncomplex numbers using the \"abstract data\" specified by the constructors\nand selectors, just as we did for rational numbers in section 2.1.1. As\nshown in the formulas above, we can add and subtract complex numbers in\nterms of real and imaginary parts while multiplying and dividing\ncomplex numbers in terms of magnitudes and angles:\n\n```clj\n(defn add-complex [z1 z2]\n  (make-from-real-imag (+ (real-part z1) (real-part z2))\n                       (+ (imag-part z1) (imag-part z2))))\n\n(defn sub-complex [z1 z2]\n  (make-from-real-imag (- (real-part z1) (real-part z2))\n                       (- (imag-part z1) (imag-part z2))))\n\n(defn mul-complex [z1 z2]\n  (make-from-mag-ang (* (magnitude z1) (magnitude z2))\n                     (+ (angle z1) (angle z2))))\n\n(defn div-complex [z1 z2]\n  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))\n                     (- (angle z1) (angle z2))))\n```\n\nTo complete the complex-number package, we must choose a representation\nand we must implement the constructors and selectors in terms of\nprimitive numbers and primative list structure. There are two obvious\nways to do this: We can represent a complex number in \"rectangular\nform\" as a pair (real part, imaginary part) or in \"polar form\" as a\npair (magnitude, angle). Which shall we choose?\n\nIn order to make the different choices concrete, imagine that there are\ntwo programmers, Ben Bitdiddle and Alyssa P. Hacker, who are\nindependently designing representations for the complex-number system.\nBen chooses to represent complex numbers in rectangular form. With this\nchoice, selecting the real and imaginary parts of a complex number is\nstraightforward, as is constructing a complex number with given real\nand imaginary parts. To find the magnitude and the angle, or to\nconstruct a complex number with a given magnitude and angle, he uses\nthe trigonometric relations:\n\n$$\\begin{align*}\nx=&r\\cos A & r=&\\sqrt{x^2+y^2}\n\\\\\\\\y=&r\\sin A & A=&\\arctan(y,x)\n\\end{align*}$$\n\nwhich relate the real and imaginary parts \\\\((x,y)\\\\) to the magnitude\nand angle \\\\((r,A)\\\\).<<The arctangent function referred to here, is a\ncombination of the Java arctan function and a conditional that accounts\nfor the quadrants via the signs of the arguments.>> Ben's\nrepresentation is therefore given by the following selectors and\nconstructors:\n\n```clj\n(defn real-part [z] (first z))\n\n(defn imag-part [z] (second z))\n\n(defn magnitude [z]\n  (sqrt (+ (square (real-part z)) (square (imag-part z)))))\n\n(defn angle [z]\n  (arctan (imag-part z) (real-part z)))\n\n(defn make-from-real-imag [x y]\n  (list x y))\n\n(defn make-from-mag-ang [r a]\n  (list (* r (Math/cos a)) (* r (Math/sin a))))\n```\n\nIf you tried this code (which I hope you did), you may have noticed\nthat our `angle` procedure doesn't work! The `arctan` function is not\ndefined. If you define it, remember to account for the quadrants!\n\nAlyssa, in contrast, chooses to represent complex numbers in polar\nform. For her, selecting the magnitude and angle is straightforward,\nbut she has to use the trigonometric relations to obtain the real and\nimaginary parts. Alyssa's representation is:\n\n```clj\n(defn real-part [z]\n  (* (magnitude z) \n     (Math/cos (angle z))))\n\n(defn imag-part [z]\n  (* (magnitude z)\n     (Math/sin (angle z))))\n\n(defn magnitude [z]\n  (first z))\n\n(defn angle [z]\n  (second z))\n\n(defn make-from-real-imag [x y]\n  (list (sqrt (+ (square x) \n                 (square y)))\n        (arctan y x)))\n\n(defn make-from-mag-ang [r a]\n  (list r a))\n```\n\nThe discipline of data abstraction ensures that the same implementation\nof `add-complex`, `sub-complex`, `mul-complex`, and `div-complex` will\nwork with either Ben's representation or Alyssa's representation.")) "" (data/subsect {:title "Tagged Data"} (md {} "One way to view data abstraction is as an application of the \"principal\nof least commitment.\" In implementing the complex-number system in\nsecion 2.4.1, we can use either Ben's rectangular representation or\nAlyssa's polar representation. The abstraction barrier formed by the\nselectors and constructors permits us to defer to the last possible\nmoment the choice of a concrete representation for our data objects and\nthus retain maximum flexibility in our system design.\n\nThe principle of least commitment can be carried to even further\nextremes. If we desire, we can maintain the ambiguity of representation\neven *after* we have designed the selectors and constructors, and elect\nto use both Ben's representation *and* Alyssa's representaion. If both\nrepresentations are included in a single system, however, we will need\nsome way to distinguish data in polar form from data in rectangular\nform. Otherwise, if we were asked, for instance, to find the\n`magnitude` of the pair (3,4), we wouldn't know whether to answer 5\n(interpreting the number in rectangular form) or 3 (interpreting the\nnumber in polar form). A straightforward way to accomplish this\ndistinction is to include a *type tag* -- the symbol `rectangular` or\n`polar` -- as part of each complex number. Then when we need to\nmanipulate a complex number we can use the tag to decide which selector\nto apply.\n\nIn order to manipulate tagged data, we will assume that we have\nprocedures `type-tag` and `contents` that extract from a data object\nthe tag and the actual contents (the polar or rectangular coordinates,\nin the case of a complex number). We will also postulate a procedure\n`attach-tag` that takes a tag and contents and produces a tagged data\nobject. A straightforward way to implement this is to ordinary list\nstructure:\n\n```clj\n(defn attach-tag [type-tag contents]\n  (list type-tag contents))\n\n(defn type-tag [datum]\n  (if (list? datum)\n      (first datum)\n      (throw (Exception. \"Bad tagged dataum -- TYPE-TAG\"))))\n\n(defn contents [datum]\n  (if (list? datum)\n      (rest datum)\n      (throw (Exception. \"Bad tagged datum -- CONTENTS\"))))\n```\n\nUsing these procedures, we can define predicates `rectangular?` and\n`polar?`, which recognize polar and rectangular numbers, respectively:\n\n```clj\n(defn rectangular? [z]\n  (= (type-tag z) 'rectangular))\n\n(defn polar? [z]\n  (= (type-tag z) 'polar))\n```\n\nWith type tags, Ben and Alyssa can now modify their code so that their\ntwo different representations can coexist in the same system. Whenever\nBen constructs a complex number, he tags it as rectangular. Whenever\nAlyssa constructs a complex number, she tags it as polar. In addition,\nBen and Alyssa must make sure that the names of their procedures do not\nconflict. One way to do this is for Ben to append the suffix\n`rectangular` to the name of each of his representation procedures and\nfor Alyssa to append `polar` to the names of hers. Here is Ben's\nrevised rectangular representation from section 2.4.1:\n\n```clj\n(defn real-part-rectangular [z] (first z))\n\n(defn imag-part-rectangular [z] (second z))\n\n(defn magnitude-rectangular [z]\n  (sqrt (+ (square (real-part z)) (square (imag-part z)))))\n\n(defn angle-rectangular [z]\n  (arctan (imag-part z) (real-part z)))\n\n(defn make-from-real-imag-rectangular [x y]\n  (attach-tag 'rectangular (list x y)))\n\n(defn make-from-mag-ang-rectangular [r a]\n  (attach-tag 'rectangular \n    (list (* r (Math/cos a)) \n          (* r (Math/sin a)))))\n```\n\nand here is Alyssa's revised polar representation:\n\n```clj\n(defn real-part-polar [z]\n  (* (magnitude z) \n     (Math/cos (angle z))))\n\n(defn imag-part-polar [z]\n  (* (magnitude z)\n     (Math/sin (angle z))))\n\n(defn magnitude-polar [z]\n  (first z))\n\n(defn angle-polar [z]\n  (second z))\n\n(defn make-from-real-imag-polar [x y]\n  (attach-tag 'polar\n              (list (sqrt (+ (square x) \n                             (square y)))\n                    (arctan y x))))\n\n(defn make-from-mag-ang-polar [r a]\n  (attach-tag 'polar\n              (list r a)))\n```\n\nEach generic selector is implemented as a procedure that checks the tag\nof its argument and calls the appropriate procedure for handling data\nof that type. For example, to obtain the real part of a complex number,\n`real-part` examines the tag to determine whether to use Ben's\n`real-part-rectangular` or Alyssa's `real-part-polar`. In either case,\nwe use `contents` to extract the bare, untagged datum and send this to\nthe rectangular or polar procedure as required:\n\n```clj\n(defn real-part [z]\n  (cond (rectangular? z) (real-part-rectangular (contents z))\n        (polar? z)       (real-part-polar       (contents z))\n        :else (throw (Exception. \"Unknown type -- REAL-PART\"))))\n\n(defn imag-part [z]\n  (cond (rectangular? z) (imag-part-rectangular (contents z))\n        (polar? z)       (imag-part-polar       (contents z))\n        :else (throw (Exception. \"Unknown type -- IMAG-PART\"))))\n\n(defn magnitude [z]\n  (cond (rectangular? z) (magnitude-rectangular (contents z))\n        (polar? z)       (magnitude-polar       (contents z))\n        :else (throw (Exception. \"Unknown type -- MAGNITUDE\"))))\n\n(defn angle [z]\n  (cond (rectangular? z) (angle-rectangular (contents z))\n        (polar? z)       (angle-polar       (contents z))\n        :else (throw (Exception. \"Unknown type -- ANGLE\"))))\n```\n\nTo implement the complex-number arithmetic operations, we can use the\nsame procedures `add-complex`, `sub-complex`, `mul-complex`, and\n`div-complex` from section 2.4.1, because the selectors they call are\ngeneric, and so will work with either representation. For example, the\nprocedure `add-complex` is still\n\n```clj\n(defn add-complex [z1 z2]\n  (make-from-real-imag (+ (real-part z1) (real-part z2))\n                       (+ (imag-part z1) (imag-part z2))))\n```\n\nFinally, we must choose whether to construct complex numbers using\nBen's representation or Alyssa's representation. One reasonable choice\nis to construct rectangular numbers whenever we have real and imaginary\nparts and to construct polar numbers whenever we have magnitudes and\nangles:\n\n```clj\n(defn make-from-real-imag [x y]\n  (make-from-real-imag-rectangular x y))\n\n(defn make-from-mag-ang [r a]\n  (make-from-mag-ang-polar r a))\n```") "" (data/fig {:footer "Structure of the generic complex-arithmetic system."}) "" (md {} "The resulting complex-number system has the structure shown in figure\n2.21. The system has been decomposed into three relatively independent\nparts: the complex-number-arithmetic operations, Alyssa's polar\nimplementation, and Ben's rectangular implementation. The polar and\nrectangular implementations could have been written by Ben and Alyssa\nworking seperately, and both of these can be used as underlying\nrepresentations by a third programmer implementing the\ncomplex-arithmetic procedures in terms of the abstract\nconstructor/selector interface.\n\nSince each data object is tagged with its type, the selectors operate\non the data in a generic manner. That is, each selector is defined to\nhave a behavior that depends upon the particular type of data it is\napplied to. Notice the general mechanism for interfacing the separate\nrepresentations: Within a given representation implementation (say,\nAlyssa's polar package) a complex number is an untyped pair (magnitude,\nangle). When a generic selector operates on a number of `polar type`,\nit strips off the tag and passes the contents on to Alyssa's code.\nConversely, when Alyssa constructs a number for general use, she tags\nit with a type so that it can be appropriately recognized by the\nhigher-level procedures. This discipline of stripping off and attaching\ntags as data objects are passed from level to level can be an important\norganizational strategy, as we shall see in section 2.5.")) "" (data/subsect {:title "Data-Directed Programming and Additivity"} (md {} "The general strategy of checking the type of a datum and calling an\nappropriate procedure is called *dispatching on type*. This is a\npowerful strategy for obtaining modularity in system design. On the\nother hand, implementing the dispatch as in section 2.4.2 has two\nsignificant weaknesses. One weakness is that the generic interface\nprocedures (`real-part`, `imag-part`, `magnitude`, and `angle`) must\nknow about all the different representations. For instance, suppose we\nwanted to incorporate a new representation for complex numbers into our\ncomplex-number system. We would need to indentify this new\nrepresentation with a type, and then add a clause to each of the\ngeneric interface procedures to check for the new type and apply the\nappropriate selector for that representation.\n\nAnother weakness of the technique is that even though the individual\nrepresentations can be designed separately, we must guarantee that no\ntwo procedures in the entire system have the same name. This is why Ben\nand Alyssa had to change the names of their original procedures from\nsection 2.4.1.\n\nThe issue underlying both of these weaknesses is that the technique for implementing generic interfaces is not additive. The person implementing the generic selector procedures must modify those procedures each time a new representation is installed, and the people interfacing the individual representations must modify their code to avoid name conflicts. In each of these cases, the changes that must be made to the code are straightforward, but they must be made nonetheless, and this is a source of inconvenience and error. This is not much of a problem for the complex-number system as it stands, but suppose there were not two but hundreds of different representations for complex numbers. And suppose that there were many generic selectors to be maintained in the abstract-data interface. Suppose, in fact, that no one programmer knew all the interface procedures or all the representations. The problem is real and must be addressed in such programs as large-scale data-base-management systems.\n\nWhat we need is a means for modularizing the system design even further. This is provided by the programming technique known as data-directed programming. To understand how data-directed programming works, begin with the observation that whenever we deal with a set of generic operations that are common to a set of different types we are, in effect, dealing with a two-dimensional table that contains the possible operations on one axis and the possible types on the other axis. The entries in the table are the procedures that implement each operation for each type of argument presented. In the complex-number system developed in the previous section, the correspondence between operation name, data type, and actual procedure was spread out among the various conditional clauses in the generic interface procedures. But the same information could have been organized in a table, as shown in figure 2.22.\n\nData-directed programming is the technique of designing programs to work with such a table directly. Previously, we implemented the mechanism that interfaces the complex-arithmetic code with the two representation packages as a set of procedures that each perform an explicit dispatch on type. Here we will implement the interface as a single procedure that looks up the combination of the operation name and argument type in the table to find the correct procedure to apply, and then applies it to the contents of the argument. If we do this, then to add a new representation package to the system we need not change any existing procedures; we need only add new entries to the table."))))
